<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大汇总</title>
    <url>/2024/12/18/%E5%A4%A7%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ul>
<li><h2 id="1，并发编程的优缺点"><a href="#1，并发编程的优缺点" class="headerlink" title="1，并发编程的优缺点"></a>1，并发编程的优缺点</h2><ul>
<li>优点<ul>
<li>1，拆分复杂的业务，可以同时操作io和cpu</li>
<li>2，可以最大程度的利用多核cpu</li>
</ul>
</li>
<li>缺点<ul>
<li>1，线程从暂停(阻塞，等待)到运行切换需要进行上下文切换，很耗资源</li>
<li>2，多线程操作可能对临界区带来线程安全问题，比如一致性问题和死锁</li>
</ul>
</li>
</ul>
<h2 id="2，java中定位死锁"><a href="#2，java中定位死锁" class="headerlink" title="2，java中定位死锁"></a>2，java中定位死锁</h2><ul>
<li>1，去jdk的bin目录，使用jps指令来获取正在运行的jvm进程id</li>
<li>2，jstack -l  pid ,就直接可以看到死锁信息</li>
</ul>
<h2 id="3，如何创建线程"><a href="#3，如何创建线程" class="headerlink" title="3，如何创建线程"></a>3，如何创建线程</h2><ul>
<li>1，继承Thread类，调用对象start方法<ul>
<li>缺点，单继承</li>
</ul>
</li>
<li>2，实现runnable接口，传入Thread构造，调用Thread对象的start<ul>
<li>缺点，无返回值</li>
</ul>
</li>
<li>3，实现callable接口，交给线程池的submit方法执行，返回一个futrue，调用get方法阻塞获取返回值</li>
</ul>
<span id="more"></span>

<h2 id="4，java中线程的状态"><a href="#4，java中线程的状态" class="headerlink" title="4，java中线程的状态"></a>4，java中线程的状态</h2><ul>
<li>1，NEW<ul>
<li>start方法调用之前</li>
</ul>
</li>
<li>2，RUNNABLE<ul>
<li>调用start之后</li>
<li>由等待转化过来：notify、signal、unpark</li>
<li>获取到锁由阻塞转化过来</li>
</ul>
</li>
<li>3，WAITING<ul>
<li>等待通知或中断</li>
<li>调用Tread.sleep、object.wait、condition.await、Locksuport.park、thread.join、lock.lock获取锁失败后</li>
</ul>
</li>
<li>4，TIMED_WAITING<ul>
<li>带定时参数的WAITING</li>
</ul>
</li>
<li>5，BLOCKED<ul>
<li>进入synchronized方法，代码块，获取锁失败</li>
</ul>
</li>
</ul>
</li>
<li><p>6，TERMINAL</p>
<ul>
<li>执行完毕</li>
</ul>
<h2 id="5，线程的基本操作"><a href="#5，线程的基本操作" class="headerlink" title="5，线程的基本操作"></a>5，线程的基本操作</h2><ul>
<li>1，thread.interrupt<ul>
<li>改变thread线程的标志位</li>
</ul>
</li>
<li>2，thread.isInterrupt<ul>
<li>判断标志位是否改变</li>
</ul>
</li>
<li>3，Thread.isInterrupt(thread)<ul>
<li>判断标志位是否改变后，清除标志位</li>
</ul>
</li>
<li>4，thread.join<ul>
<li>调用后，当前线程会等待thread线程执行完，当前线程进入WAITING或者TIMED_WAITING状态</li>
</ul>
</li>
<li>5，Thead.sleep<ul>
<li>调用此方法的线程会睡眠，进入TIMED_WAITING状态</li>
<li>常与object.wait比较：<ul>
<li>区别是wait要先获取锁才能调用(同步块里),并且会释放锁</li>
<li>sleep随时调用，有锁也不会释放</li>
</ul>
</li>
</ul>
</li>
<li>6，守护线程<ul>
<li>守护线程是为非守护线程服务的线程，比如垃圾回收线程</li>
</ul>
</li>
<li>thread.setDaemon(true)设置为守护线程<ul>
<li>所有非守护线程执行完毕之后，jvm会直接关闭，并不会等待守护线程执行完，所以，不要在守护线程里写finally释放资源</li>
</ul>
</li>
</ul>
<h2 id="6，JMM是什么"><a href="#6，JMM是什么" class="headerlink" title="6，JMM是什么"></a>6，JMM是什么</h2><ul>
<li>1，JMM是java的内存模型，规定了java线程的通信模型以及线程之间如何完成同步<ul>
<li>java线程通信是共享内存模型：每个线程从主内存拿数据会在工作内存弄一个副本，修改后再同步到主内存</li>
</ul>
</li>
<li>2，对编译器制定了重排序的规则<ul>
<li>as-if-serial：在单线程中程序执行的结果不被改变</li>
</ul>
</li>
<li>happens before：JMM保证根据此规则编写正确的程序结果不被改变<ul>
<li>在确保以上两个规则实现的情况下，可以随意进行指令重排序</li>
</ul>
</li>
</ul>
<h2 id="7，happens-before的具体规则"><a href="#7，happens-before的具体规则" class="headerlink" title="7，happens-before的具体规则"></a>7，happens-before的具体规则</h2><ul>
<li>1，单线程中的每个操作，h-b此线程的之后任意操作</li>
<li>2，对一个监视器的加锁，h-b对这个监视器的解锁</li>
<li>3，对volatile的写，h-b任意对这个volatile的读</li>
<li>4，传递性，a h-b b,b h-b c,a h-b c</li>
</ul>
</li>
<li><p>5，start，某线程的start方法 h-b线程内的所有操作</p>
<ul>
<li>6，线程A调用B.join方法并成功返回，则b线程的所有操作h-bA线程</li>
</ul>
<h2 id="8，synchronized使用"><a href="#8，synchronized使用" class="headerlink" title="8，synchronized使用"></a>8，synchronized使用</h2><ul>
<li>1，方法上：进入方法时获取锁，方法结束或异常释放锁<ul>
<li>静态方法：锁类class对象</li>
<li>实例方法：锁this</li>
</ul>
</li>
</ul>
</li>
<li><p>2，代码块上</p>
<ul>
<li>手动指定对象，可以是任何类的class、this、任何实例对象</li>
</ul>
<h2 id="9，synchronized的原理"><a href="#9，synchronized的原理" class="headerlink" title="9，synchronized的原理"></a>9，synchronized的原理</h2><ul>
<li>1，每个锁对象的对象头的markword都关联了一个monitor，由monitor实际控制同步</li>
<li>2，获取到锁，monitor存储获取到锁的线程，只能有一个线程获取到锁</li>
<li>3，获取失败，进入monitor的阻塞队列，锁释放的时候唤醒阻塞队列的线程</li>
</ul>
</li>
<li><p>4，可重入性，monitor有计数器，获取到锁的线程再次获取，只需要计数器+1即可，无需执行monitorenter指令</p>
<ul>
<li>5，获取到锁执行monitorenter，释放执行monitorexit</li>
</ul>
<h2 id="10，synchronized的原子性，有序性，可见性"><a href="#10，synchronized的原子性，有序性，可见性" class="headerlink" title="10，synchronized的原子性，有序性，可见性"></a>10，synchronized的原子性，有序性，可见性</h2><ul>
<li>1，原子性<ul>
<li>Synchronized保证一系列操作这能被一个线程访问，不会被其他的线程打断，在其他线程的视角，这一系列操作执行时是不可见的</li>
</ul>
</li>
<li>2，有序性<ul>
<li>monitorenter happens-before monitorexit，这保证了同步块内的代码不会和同步块外的代码进行重排序</li>
</ul>
</li>
<li>3，可见性</li>
<li>Synchronized的内存语义就是，在线程释放锁的时候把自身的工作空间的内容刷新到主内存，在线程获取锁的时候，强行读取主内存最新的变量内容<ul>
<li>刷新到主内存的操作导致被其它所有线程可见</li>
</ul>
</li>
</ul>
<h2 id="11，Synchronized的锁分类，以及特点，场景"><a href="#11，Synchronized的锁分类，以及特点，场景" class="headerlink" title="11，Synchronized的锁分类，以及特点，场景"></a>11，Synchronized的锁分类，以及特点，场景</h2><ul>
<li>重量级锁<ul>
<li>特点：使用monitor监视器，当获取锁失败会直接进入阻塞队列</li>
<li>场景：适合在同步任务需要执行很久的时候使用，将线程阻塞降低cpu损耗</li>
</ul>
</li>
<li>轻量级锁：<ul>
<li>特点：<ul>
<li>加锁：不使用monitor，获取锁的时候，在虚拟机栈中创造一片锁空间，存储锁对象markword的内容，再将对象的markword存指向锁记录的指针；获取锁失败会自旋</li>
<li>解锁：尝试使用cas把索空间的内容重新赋值给对象的markword</li>
</ul>
</li>
<li>场景：适合同步任务需要执行的时间很短的情况，这种情况下，线程阻塞时间过短，上下文切换消耗的资源过多，不如使用自旋代替阻塞</li>
</ul>
</li>
<li>偏向锁：<ul>
<li>特点：<ul>
<li>加锁：把markword存到栈帧中的lockrecord里，markword存线程id；在此之后，只需要比较对象头的线程id和自身的id是否一样就可以了，就不用cas获取</li>
</ul>
</li>
<li>解锁：不会解锁，锁始终属于这个线程无论线程是否存活</li>
<li>场景：适合冲突极少，同步代码几乎都是单个线程执行的情况</li>
</ul>
</li>
</ul>
<h2 id="12，Synchronized锁升级的过程"><a href="#12，Synchronized锁升级的过程" class="headerlink" title="12，Synchronized锁升级的过程"></a>12，Synchronized锁升级的过程</h2><ul>
<li>1，轻量级锁升级到重量级：A线程获取了轻量级锁，B线程来尝试获取<ul>
<li>B自旋10获取锁：<ul>
<li>B线程先自旋cas十次，尝试把markword存到栈针并把对象对的markword改成指向栈帧的指针</li>
</ul>
</li>
<li>B改markword开启锁升级：<ul>
<li>获取锁依然失败，开启锁升级，先把锁对象的markword改变(临时的重量级锁指针)，让A线程释放锁时的cas操作失败</li>
</ul>
</li>
<li>A创建monitor、改对象头：<ul>
<li>·A线程释放锁失败后，先初始化monitor对象，再将自己栈中的锁对象的markword保存到monitor的一个变量中，再把对象头的markword指向monitor，再设置锁对象的对象头锁标志位为重量级锁00</li>
</ul>
</li>
<li>A唤醒B线程</li>
</ul>
</li>
<li>2，偏向锁升级到轻量级锁：锁偏向A线程，B线程来获取锁</li>
<li>B尝试cas替换markword为自己的线程id，失败执行锁升级<ul>
<li>暂停锁偏向的线程，检查是否还活着，线程没活着直接恢复无锁状态；活着的话，遍历栈帧中的锁纪录，锁记录中的markword和对象头的线程id，要么偏向B，要么恢复到无锁</li>
</ul>
</li>
</ul>
<h2 id="13，volatile的可见性和有序性"><a href="#13，volatile的可见性和有序性" class="headerlink" title="13，volatile的可见性和有序性"></a>13，volatile的可见性和有序性</h2></li>
<li><p>1，可见性：volatile写之后会直接刷新到主内存，并且其他线程在volatile读的时候强行读主内存中最新的，常用于标志位</p>
<ul>
<li>2，有序性：volatile使用内存屏障来实现happens-before规则：先执行的volatile写一定先于volatile读</li>
</ul>
<h2 id="14，lock接口的api"><a href="#14，lock接口的api" class="headerlink" title="14，lock接口的api"></a>14，lock接口的api</h2><ul>
<li>lock：获取锁，失败会阻塞</li>
<li>unlock：解锁，lock只能通过unlock解锁，就算出异常也不会自动释放锁</li>
<li>tryLock：获取锁，失败立即返回false</li>
</ul>
</li>
<li><p>tryLock(time):获取锁，一定时间内获取不到自动返回</p>
<ul>
<li>lockInterruptibly：可中断的获取锁，获取锁失败阻塞的线程，其他线程中断，会导致阻塞的线程取消获取锁并在此方法抛出异常</li>
</ul>
<h2 id="15，AQS的理解"><a href="#15，AQS的理解" class="headerlink" title="15，AQS的理解"></a>15，AQS的理解</h2><ul>
<li>1，AQS是同步器，面向锁的制造者，让程序员轻松自定义自己的锁</li>
<li>2，AQS提供了模板方法可以调用，模板方法定义了同步的逻辑，比如获取锁成功后，失败后，释放成功后，释放失败后，如何入阻塞队列，如何阻塞唤醒线程等等；以下是常用模板方法<ul>
<li><code>acquire(int arg)</code>：尝试获取独占锁，失败则入队列等待。</li>
<li><code>release(int arg)</code>：释放独占锁，并唤醒后继线程。</li>
<li><code>acquireShared(int arg)</code>：尝试获取共享锁，失败则入队列等待。</li>
<li><code>releaseShared(int arg)</code>：释放共享锁，并唤醒其他线程。</li>
<li><code>acquireInterruptibly(int arg)</code>：可中断地获取独占锁。</li>
<li><code>acquireSharedInterruptibly(int arg)</code>：可中断地获取共享锁。</li>
<li><code>tryAcquireNanos(int arg, long nanosTimeout)</code>：限时尝试获取独占锁。</li>
<li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：限时尝试获取共享锁。</li>
<li><code>isQueued(Thread thread)</code>：判断线程是否在等待队列中。</li>
</ul>
</li>
<li>3，模板方法会调用可重写的方法，以下是常用可重写的方法<ul>
<li><code>tryAcquire(int arg)</code>：独占方式尝试获取资源，成功则返回true，失败则返回false。</li>
<li><code>tryRelease(int arg)</code>：独占方式尝试释放资源，成功则返回true，失败则返回false。</li>
<li><code>tryAcquireShared(int arg)</code>：共享方式尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
</ul>
</li>
<li><code>tryReleaseShared(int arg)</code>：共享方式尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。<ul>
<li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
</ul>
</li>
</ul>
<h2 id="16，利用AQS自制锁"><a href="#16，利用AQS自制锁" class="headerlink" title="16，利用AQS自制锁"></a>16，利用AQS自制锁</h2><ul>
<li>1，定义自己的锁，实现lock接口</li>
<li>2，lock接口应当调用AQS的模板方法，定义匿名内部类，继承AQS，直接调用匿名内部类继承下来的模板方法<ul>
<li>之所以要继承AQS，是因为AQS的模板方法调用了AQS中可重写的方法，需要使用子类重写</li>
</ul>
</li>
<li>3，重写模板方法需要调用的protected方法，主要是定义加锁解锁逻辑：如何才算成功加锁，如何才算成功解锁</li>
<li>加锁解锁的逻辑是自定义的，只需要方法返回true，AQS就认为获取锁成功，反之返回false，AQS认为加锁失败，就会进行加入阻塞队列，排队等一系列操作</li>
<li>4，代码演示</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SYNC</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SYNC</span>();</span><br><span class="line">    <span class="comment">//实现了lock的加锁和解锁，调用的是AQS的模板方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SYNC</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 加锁逻辑，定义什么情况是加锁成功，什么时候是加锁失败</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 加锁成功return ture，加锁失败返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1，逻辑，尝试将锁的state改为1，成功表示之前是0，没有线程加锁(cas)过，这次加锁成功</span></span><br><span class="line">            <span class="comment">//2，加锁成功要存储下获得了锁的线程，如果获取锁成功了，直接存当前线程</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(getState(),getState()+arg)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setState(getState()-arg);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="17，ReentrantLock的可重入性实现"><a href="#17，ReentrantLock的可重入性实现" class="headerlink" title="17，ReentrantLock的可重入性实现"></a>17，ReentrantLock的可重入性实现</h2></li>
<li><p>1，在线程获取锁的时候，先判断是否被线程获取(lock.getExclusiveOwnerThread)</p>
<ul>
<li>2，如果没有被获取了，判断是否是当前线程，是的话给计数器加一，否的话获取锁失败进阻塞队列</li>
</ul>
<h2 id="18，ReentrantLock的公平锁和非公平锁"><a href="#18，ReentrantLock的公平锁和非公平锁" class="headerlink" title="18，ReentrantLock的公平锁和非公平锁"></a>18，ReentrantLock的公平锁和非公平锁</h2><ul>
<li>1，公平锁指的是，按照线程请求锁的时间，请求失败在阻塞队列排序</li>
<li>2，非公平锁指的是，线程获取锁失败后，会先自旋一段时间，如果在自旋时间内获取锁成功了，就省掉了一次从阻塞队列WAITING状态转化成RUNNABLE状态的上下文切换</li>
<li>3，优缺点对比:<ul>
<li>公平锁可能会比非公平锁多一些上下文切换，但是不会出现饥饿问题</li>
</ul>
</li>
</ul>
</li>
<li><p>4，默认:</p>
<ul>
<li>使用new的无参构造默认获取的是非公平锁，传入true为参数可获取公平锁</li>
</ul>
<h2 id="19，Condition的使用"><a href="#19，Condition的使用" class="headerlink" title="19，Condition的使用"></a>19，Condition的使用</h2><ul>
<li>1，使用Lock.newCondition()方法可以创建一个condition，每个lock能够关联多个condition，这也是和Synchronized的等待集合不同的点，每个monitor只支持一个waitset</li>
<li>2，当获取到lock锁之后，可以调用condition.await()方法，线程将会释放锁，并进入condition的等待队列中，等待队列是单链表，采用尾插法</li>
<li>3，获取到lock的线程可以调用signal方法，来唤醒等待队列的头结点，使头结点线程加入到lock的阻塞队列，可以争抢锁<ul>
<li>signalAll方法可以唤醒所有等待队列的线程，全部加入阻塞队列</li>
</ul>
</li>
<li>4，进入阻塞队列争抢到锁后，await方法才真正结束，原本await线程最终以获取到锁的状态继续执行</li>
<li>5，使用举例：A，B两个线程</li>
<li>A以想要的资源做条件来循环，条件也可以是标志位变量(注意用volatile修饰，在其他线程改标志位后第一时间拿到最新值)，循环刚开始调用await，线程释放锁，代码暂停<ul>
<li>B获取锁(获取锁才能使用signal)，给A资源(使A的循环条件为false)，B唤醒A，并释放锁，A在阻塞队列争抢到锁，第二次跳出循环(循环条件为false)，继续执行代码，执行完后释放锁</li>
</ul>
</li>
</ul>
<h2 id="20，LockSupport是干嘛用的"><a href="#20，LockSupport是干嘛用的" class="headerlink" title="20，LockSupport是干嘛用的"></a>20，LockSupport是干嘛用的</h2><ul>
<li><p>1，作用就是阻塞线程和唤醒线程</p>
</li>
<li><p>2，LockSupport的方法:以下方法全部都是类方法</p>
<ul>
<li>park</li>
<li>parkNanos</li>
<li>park(object)</li>
</ul>
</li>
<li><p>parkUntil()</p>
<ul>
<li>unpark(Thread)</li>
</ul>
</li>
<li><p>3，注意park对线程的阻塞不需要获取锁，而且可以直接指定解锁某一个线程、</p>
</li>
<li><p>4，condition的await和signal底层 就是调用的park，unpark，park是native方法</p>
</li>
</ul>
<h2 id="21，ConcurrentHashMap"><a href="#21，ConcurrentHashMap" class="headerlink" title="21，ConcurrentHashMap"></a>21，ConcurrentHashMap</h2><ul>
<li>1，HashMap在多线程并发下可能出现的问题<ul>
<li>写写覆盖：两个线程同时读取到桶为null，都觉得可以插入，线程1先插入成功，线程2再插入其他值覆盖了线程1的内容；实际上，他们只是发生了hash冲突，应该用拉链法形成链表</li>
<li>读写异常：遍历的时候，另一个线程对Hashmap的增删改操作，都会使遍历的方法抛出异常ConcurrentModificationException</li>
<li>删除期间put，导致的数据丢失：某线程先执行的删除某个桶的数据的指令，另一个线程要put那个桶，正常应该先删除，再添加，结果是添加成功；然而在删除未结束之前，添加就已经完成，就会删除了刚添加的，导致结果那个桶为空</li>
<li>扩容和删除同时进行导致的循环链表问题：扩容线程执行中途，有线程删除了链表的某节点</li>
</ul>
</li>
<li>2，ConcurrentHashMap的解决方案<ul>
<li>对于null桶覆盖，cas可以解决；对于成链表的桶的写入(头插法)要用Synchronized锁住头结点，来保证 遍历链表使用equals确定在链表插入的位置后再插入这一系列操作的原子性以及可见性 </li>
<li>遍历时修改表不会出异常，使用了volatile来保证可见性，node包含了K,V,next域，K是永远不变的，不用volatile；V要保证修改时可见，需要volatile；next变动报名有增加或者删除元素，需要可见性，要volatile</li>
</ul>
</li>
<li>使用Synchronized锁住头结点，删除和增加都竞争同一个锁<ul>
<li>扩容：todo</li>
</ul>
</li>
</ul>
<h2 id="22，CopyOnWriteArrayList"><a href="#22，CopyOnWriteArrayList" class="headerlink" title="22，CopyOnWriteArrayList"></a>22，CopyOnWriteArrayList</h2><ul>
<li>1，问题：在一个线程遍历ArrayList的时候，另一个线程做list的结构性更改，遍历的方法会抛出ConcurrentModificationException异常<ul>
<li>结构性更改：删元素；加元素；使用list的set方法改元素；拿出list中的数组，修改后再放回去</li>
</ul>
</li>
<li>2，解决：<ul>
<li>给arraylist对象加锁，每次使用对象都先获取互斥锁，不管是用来读还是写-&gt;不行，只读没有线程安全问题不能阻塞才对</li>
<li>使用读写锁可以保证多线程读，写的时候互斥，不能读也不能写，好处是高一致性，每次读都是最新值</li>
<li>CopyOnWriteArrayList:丢弃强一致性，什么情况下都可以读</li>
</ul>
</li>
<li>3，CopyOnWriteArrayList原理：<ul>
<li>有改结构性的操作，直接Arrays.copyOf复制一个数组，在那个里面操作，其他线程继续遍历原table数组</li>
<li>数组的引用变量是volatile的，复制的数组操作完了，要改list中变量的值，使其等于新数组的引用，volatile保证一改变其他线程新的线程操作list对象时都能拿到新的数组引用</li>
</ul>
</li>
</ul>
</li>
<li><p>4，遍历未完成的，换了数组，后半部分遍历咋办？</p>
<ul>
<li>迭代器创建时，会存下原数组的引用，使用迭代器引用的原数组来遍历，即使在遍历中CopyOnWriteArrayList的变量引用了新的数组，也和迭代器遍历的数组无关</li>
</ul>
<h2 id="23，BlockingQueue"><a href="#23，BlockingQueue" class="headerlink" title="23，BlockingQueue"></a>23，BlockingQueue</h2><h2 id="24，为什么要使用线程池"><a href="#24，为什么要使用线程池" class="headerlink" title="24，为什么要使用线程池"></a>24，为什么要使用线程池</h2><ul>
<li>1，线程复用</li>
</ul>
</li>
<li><p>2，核心线程会在创建线程池就创建，在运行时能更快的响应任务</p>
<ul>
<li>3，线程管理</li>
</ul>
<h2 id="25，ThreadPoolExecutor-线程池-的参数和原理"><a href="#25，ThreadPoolExecutor-线程池-的参数和原理" class="headerlink" title="25，ThreadPoolExecutor(线程池)的参数和原理"></a>25，ThreadPoolExecutor(线程池)的参数和原理</h2><ul>
<li>1，ThreadPoolExecutor的参数<ul>
<li>核心线程数</li>
<li>阻塞队列</li>
<li>最大线程数</li>
<li>空闲线程过期时间</li>
<li>过期时间单位</li>
<li>拒绝策略</li>
<li>线程工厂</li>
</ul>
</li>
<li>2，ThreadPoolExecutor的原理，任务到达后<ul>
<li>先用核心线程，核心线程不够，往下</li>
<li>使用阻塞队列，阻塞队列满了，往下</li>
</ul>
</li>
<li>线程没有超过最大线程，创建线程，超过了，往下<ul>
<li>拒绝策略：直接拒绝、抛出异常、丢弃最久没执行的任务、使用用户线程执行任务</li>
</ul>
</li>
</ul>
<h2 id="26，线程池的关闭方法"><a href="#26，线程池的关闭方法" class="headerlink" title="26，线程池的关闭方法"></a>26，线程池的关闭方法</h2><ul>
<li>shutdown<ul>
<li>标记线程池为关闭状态，拒绝接收新任务，等待正在执行的任务和阻塞队列中的任务执行完</li>
</ul>
</li>
</ul>
</li>
<li><p>shutdownNow</p>
<ul>
<li>尝试使用interrupt方法中断所有线程，是否能立即中断成功取决于线程是否对中断标志位做出反应；放弃所有阻塞队列的任务并返回一个list存储所有没执行的任务</li>
</ul>
<h2 id="27，Executors"><a href="#27，Executors" class="headerlink" title="27，Executors"></a>27，Executors</h2><ul>
<li>1，通过Executors工具类来创建4种线程池，4种线程池再构造方法调用的都是ThreadPoolExecutor的new方法，预写了不同的参数</li>
<li>2，FixedThreadPool：固定线程数线程池<ul>
<li>用户设置固定线程数，核心线程等于最大线程等于固定线程，说明不会有非核心线程出现</li>
<li>阻塞队列使用的没有指定长度的LinkedBlockingQueue，可以理解无界队列，长度Int最大值，说明永远不会使用非核心线程以及拒绝策略</li>
</ul>
</li>
<li>3，SingleThreadExector：线程数为1的固定线程池，队列也一样</li>
<li>4，CatchedThreadPool：只有非核心线程的线程池，线程总是按需创建<ul>
<li>无需传入任何参数</li>
<li>默认参数<ul>
<li>核心线程：0，说明阻塞队列不能放任务，否则队列中任务无法执行</li>
<li>队列：SynchronousQueue，这个队列没有容量，只传递任务</li>
<li>最大线程数：int最大值</li>
<li>非核心过期时间：60s</li>
<li>拒绝策略：不需要，因为最大线程数是无界的</li>
</ul>
</li>
</ul>
</li>
<li>5，缺点总结：<ul>
<li>Fixed和Single都使用的无界队列，当核心线程执行的速度小于任务添加进队列的速度，造成队列中任务无限积压；拒绝策略无法使用</li>
</ul>
</li>
<li>Catched最大线程数是无界的，高并发下出现大量线程同时运行，消耗完cpu资源<ul>
<li>都非常不实用，single有时可以作为异步操作的执行线程，其他几乎没用</li>
</ul>
</li>
</ul>
<h2 id="28，SchedulePoolExecutor"><a href="#28，SchedulePoolExecutor" class="headerlink" title="28，SchedulePoolExecutor"></a>28，SchedulePoolExecutor</h2><ul>
<li><p>1，使用定时线程池，最推荐方式</p>
<ul>
<li><pre><code class="java">//建议使用Excutors获取，和调用new是一样的
//输入核心线程数即可，队列使用的delayQueue
ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = 
    (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(5);
//Executors.newScheduledThreadPool返回的是ScheduledExecutorService，是一个接口，建议强转成子类，获取子类的方法


    /**
     * @param command：任务，可以是runnable或者是callable
     * @param delay 第一次等多长时间调用
     * @param unit 时间单位
     */
    public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay, TimeUnit unit);

    /**
     * @param initialDelay：第一次调用等多长时间
     * @param period：多久调用一次
     */
    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);

    /**
     * @param initialDelay：第一次调用等多长时间
     * @param delay：多久调用一次
     */
    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                   TimeUnit unit);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 2,调用方法的区别</span><br><span class="line"></span><br><span class="line">  + schedule，调用一次</span><br><span class="line">  + scheduleAtFixedRate：按固定的时间间隔调用，按上一次任务开始的时间算起</span><br><span class="line">    + 如果上一次调用的时间小于时间间隔，等待开始时间+时间间隔后再调用</span><br><span class="line">    + 如果上一次执行的时间超过了时间间隔，下一次会等上一次执行完后再立即调用</span><br><span class="line">+ scheduleWithFixedDelay：按固定的时间间隔调用，按上一次任务结束的时间算起</span><br><span class="line">    + 无论上一次执行的时间是多久，在上一次结束后，加上时间间隔就是这次开始执行的时间</span><br><span class="line"></span><br><span class="line">## 29，FutureTask简介和基本使用</span><br><span class="line"></span><br><span class="line">+ 1，介绍：FutureTask是Future接口的实现类，同时实现了Runnable接口</span><br><span class="line"></span><br><span class="line">+ 2，使用：</span><br><span class="line"></span><br><span class="line">  ~~~java</span><br><span class="line">  FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">              return Thread.currentThread().getName();</span><br><span class="line">          &#125;);</span><br><span class="line">          task.run();</span><br><span class="line">        System.out.println(task.get());</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>FutureTask可以包装callable或者runnable接口，无论run方法在哪个线程被调用，都可以利用get获取任务的返回值</p>
</li>
</ul>
</li>
<li><p>FutureTask实现了Runnable接口，可以把一个Callable传入FutrueTask，把FutureTask本身作为Runnable给线程池execute执行，也可以使用FutureTask.get获取Callable的返回值</p>
<ul>
<li>无需线程池，直接调用run方法后，使用get也能获取返回值</li>
</ul>
</li>
<li><p>3，FutureTask的状态变化</p>
<ul>
<li>未启动：调用FutureTask的run之前<ul>
<li>get：阻塞</li>
<li>cancel(flase&#x2F;true)：任务不会执行</li>
</ul>
</li>
<li>已启动：调用run之后<ul>
<li>get：阻塞</li>
<li>cancel(false):不起作用</li>
<li>cancel(true):尝试使用中断取消</li>
</ul>
</li>
<li>已完成：执行完成，或者任务期间cancel，或者任务期间异常</li>
<li>get：获取结果，或者抛出异常<ul>
<li>cancel：返回false</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="30，atomic包"><a href="#30，atomic包" class="headerlink" title="30，atomic包"></a>30，atomic包</h2><ul>
<li><p>1，原子基本类型</p>
<ul>
<li>AtomicInteger:getAndIncrement，IncrementAndGet，addAndGet(int i),getAndAdd(int i)<ul>
<li>要减法的话，直接i为负数即可</li>
</ul>
</li>
</ul>
</li>
<li><p>AtomicIong：类似</p>
<ul>
<li>AtomicBoolean：类似</li>
</ul>
<p>2，原子数组类型</p>
<ul>
<li>new AtomicIntegerArray(array[])：compareAndSet(index,expect,update)</li>
<li>要指明需要修改的数组元素<ul>
<li>注意修改的是AtomicIntegerArray中复制的一份数组，不会修改原数组，因此在使用下标获取的时候，要使用get(index)</li>
</ul>
</li>
</ul>
</li>
<li><p>3，原子引用类型，整体替换对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//创建一个原子引用对象</span></span><br><span class="line">  AtomicReference&lt;User&gt; UserAtomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//初始对象和原子引用对象绑定</span></span><br><span class="line">  UserAtomicReference.set(user1);</span><br><span class="line">  <span class="comment">//改变对象</span></span><br><span class="line">  UserAtomicReference.compareAndSet(user2);</span><br><span class="line">  <span class="comment">//使用get可以获得改变之后的对象</span></span><br><span class="line">UserAtomicReference.get();</span><br></pre></td></tr></table></figure>

<ul>
<li>4，原子字段类型，改变单个字段的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  有三种：</span></span><br><span class="line"><span class="comment">  AtomicIntegeFieldUpdater</span></span><br><span class="line"><span class="comment">  AtomicLongFieldUpdater AtomicStampedReference</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">     </span><br><span class="line">  <span class="comment">//举例int类型,根据类方法newUpdater创建一个对象</span></span><br><span class="line">  AtomicIntegerFieldUpdater&lt;User&gt; name = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">  <span class="comment">//为指定对象的name字段修改值</span></span><br><span class="line">name.compareAndSet(对象，原值，新值)</span><br></pre></td></tr></table></figure>



<h2 id="31，CountDownLatch-倒计时"><a href="#31，CountDownLatch-倒计时" class="headerlink" title="31，CountDownLatch(倒计时)"></a>31，CountDownLatch(倒计时)</h2><ul>
<li>1，作用</li>
<li>指定倒计时的数量，调用等待方法的线程倒计时结束后才会继续运行</li>
<li>2，示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//创建5个倒计时</span></span><br><span class="line">  <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">                  <span class="comment">//调用await方法开始等待倒计时</span></span><br><span class="line">                  countDownLatch.await();</span><br><span class="line">                  <span class="comment">//倒计时减完后会继续运行</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;等待完毕&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;).start();</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">              <span class="comment">//打印倒计时数量，倒计时减1</span></span><br><span class="line">              System.out.println(<span class="string">&quot;还剩&quot;</span>+countDownLatch.getCount());</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//控制台</span></span><br><span class="line">  开始等待</span><br><span class="line">  还剩<span class="number">5</span></span><br><span class="line">  还剩<span class="number">4</span></span><br><span class="line">  还剩<span class="number">3</span></span><br><span class="line">  还剩<span class="number">2</span></span><br><span class="line">  还剩<span class="number">1</span></span><br><span class="line">等待完毕</span><br></pre></td></tr></table></figure>

<ul>
<li>3，方法<ul>
<li>await，等待倒计时结束</li>
</ul>
</li>
<li>countDown，倒计时减1<ul>
<li>getcount，剩余倒计时次数</li>
</ul>
</li>
</ul>
<h2 id="32，CyclicBarrier"><a href="#32，CyclicBarrier" class="headerlink" title="32，CyclicBarrier"></a>32，CyclicBarrier</h2><ul>
<li>作用</li>
<li>循环栅栏，调用指定次数的await后哦，所有await将被放行，并可以再次调用await</li>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//设定屏障拦截的数量，调用6次await后，6个await方法同时可以放行，并且这时runnable会被执行</span></span><br><span class="line">  <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">6</span>, () -&gt; System.out.println(<span class="string">&quot;同时出发&quot;</span>));</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      System.out.println(Thread.currentThread()+<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">                      <span class="comment">//调用await表示该线程到达屏障，会阻塞等待其他线程</span></span><br><span class="line">                      cyclicBarrier.await();</span><br><span class="line">                      System.out.println(Thread.currentThread()+<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;).start();</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//控制台</span></span><br><span class="line">  Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]开始等待</span><br><span class="line">  Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]开始等待</span><br><span class="line">  Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]开始等待</span><br><span class="line">  Thread[Thread-<span class="number">5</span>,<span class="number">5</span>,main]开始等待</span><br><span class="line">  Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]开始等待</span><br><span class="line">  Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]开始等待</span><br><span class="line">  同时出发</span><br><span class="line">  Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]开始执行</span><br><span class="line">  Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]开始执行</span><br><span class="line">  Thread[Thread-<span class="number">3</span>,<span class="number">5</span>,main]开始执行</span><br><span class="line">  Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]开始执行</span><br><span class="line">  Thread[Thread-<span class="number">2</span>,<span class="number">5</span>,main]开始执行</span><br><span class="line">Thread[Thread-<span class="number">5</span>,<span class="number">5</span>,main]开始执行</span><br></pre></td></tr></table></figure>

<ul>
<li>3，对比countDownLatch<ul>
<li>cyclicBarrier相当于可以重复使用的倒计时，全部到达了屏障(调用await)后，自动重置，可以再次await</li>
</ul>
</li>
<li>可以使用reset方法重置，避免某线程出异常或被中断，导致其余线程一直在await等它<ul>
<li>countDown方法不阻塞，所以可以在同一个线程倒计时多次；await是阻塞的，每一个线程调用一次就进阻塞状态了，不会再执行同一线程的第二次await代码，实际每个线程只能使用一次await</li>
</ul>
</li>
</ul>
<h2 id="33，Semaphore-信号量"><a href="#33，Semaphore-信号量" class="headerlink" title="33，Semaphore(信号量)"></a>33，Semaphore(信号量)</h2></li>
<li><p>作用：用于控制吞吐量，可以指定许可数量，每个线程要获取许可才能继续执行，许可用完后，想获得许可的线程阻塞等待其他线程释放许可</p>
<ul>
<li>理解：可以看作可以同时被指定个线程获取的锁，其余的线程需要阻塞等待锁释放</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//指定通行证的数量</span></span><br><span class="line">  <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">//获取通行证，5次后阻塞</span></span><br><span class="line">  semaphore.acquire();</span><br><span class="line">  <span class="comment">//释放通行证，释放后可以被获取</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>



<h2 id="34，Exchanger-交换器"><a href="#34，Exchanger-交换器" class="headerlink" title="34，Exchanger(交换器)"></a>34，Exchanger(交换器)</h2><ul>
<li><p>作用，两个线程之间交换数据，只能是两个线程，不能是多个</p>
</li>
<li><p>示例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//创建一个交换器</span></span><br><span class="line">  Exchanger&lt;String&gt; stringExchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//A线程先调用exchange方法，把自己的数据存进交换器，阻塞等待B线程调用exchange方法，等待B把数据放进aResult中</span></span><br><span class="line">          <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;A线程的数据&quot;</span>;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">aResult</span> <span class="operator">=</span> stringExchanger.exchange(a);</span><br><span class="line">                  System.out.println(<span class="string">&quot;A获得的数据=&quot;</span>+aResult);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="comment">//B线程后调用，发现以经有A的数据，获取，交换自己的过去</span></span><br><span class="line">          <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;B线程的数据&quot;</span>;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">bResult</span> <span class="operator">=</span> stringExchanger.exchange(a);</span><br><span class="line">                  System.out.println(<span class="string">&quot;B获得的数据=&quot;</span>+bResult);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          thread1.start();</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          thread2.start();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//打印结果</span></span><br><span class="line">  A获得的数据=B线程的数据</span><br><span class="line">B获得的数据=A线程的数据</span><br></pre></td></tr></table></figure>

<ul>
<li>注意<ul>
<li>只能两个线程之间交换数据</li>
</ul>
</li>
<li>会阻塞等待交换<ul>
<li>交换的数据就是exchange方法的返回值</li>
</ul>
</li>
</ul>
<h2 id="35，生产者消费者问题"><a href="#35，生产者消费者问题" class="headerlink" title="35，生产者消费者问题"></a>35，生产者消费者问题</h2></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>大汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>苍穹外卖</title>
    <url>/2025/08/27/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/</url>
    <content><![CDATA[<h3 id="1，项目中各种java类的作用"><a href="#1，项目中各种java类的作用" class="headerlink" title="1，项目中各种java类的作用"></a>1，项目中各种java类的作用</h3><p>entity，与数据库表一一对应的实体</p>
<p>dto，数据传输对象，前端的数据使用dto接，后端返回也应该是dto</p>
<p>vo，视图对象，待了解</p>
<p>pojo，代表普通java对象，对象内只有属性和getter，setter；包括了entity，vo和dto</p>
<h3 id="2，配置git提交时的排除文件"><a href="#2，配置git提交时的排除文件" class="headerlink" title="2，配置git提交时的排除文件"></a>2，配置git提交时的排除文件</h3><ul>
<li>.gitignore文件中配置不需要交给git管理的文件目录</li>
</ul>
<h3 id="3，写代码前初始化本地仓库"><a href="#3，写代码前初始化本地仓库" class="headerlink" title="3，写代码前初始化本地仓库"></a>3，写代码前初始化本地仓库</h3><ul>
<li>点击vcs，创建本地仓库，使用项目最大目录最为本地仓库就可以了，再本地中添加，提交后，才能推到远程仓库</li>
</ul>
<h3 id="4，连接远程仓库"><a href="#4，连接远程仓库" class="headerlink" title="4，连接远程仓库"></a>4，连接远程仓库</h3><ul>
<li>点击推送，会需要输入仓库url，输入完后，还需要输入账号密码，然后才可以推送</li>
</ul>
<h3 id="5，旧的mysql存在，需要重置密码"><a href="#5，旧的mysql存在，需要重置密码" class="headerlink" title="5，旧的mysql存在，需要重置密码"></a>5，旧的mysql存在，需要重置密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">忘记密码</span><br><span class="line">在忘记密码的情况下如何强制修改密码，我在此提供一种办法。</span><br><span class="line"></span><br><span class="line">1. 以超级管理员打开cmd，关闭mysql服务</span><br><span class="line">net stop mysql</span><br><span class="line"></span><br><span class="line">2. 跳过权限验证登录mysql</span><br><span class="line">mysqld --shared-memory --skip-grant-tables</span><br><span class="line"></span><br><span class="line">3. 在新的窗口中登录mysql</span><br><span class="line">mysql -u root -p</span><br><span class="line">无需输入密码，直接回车即可。</span><br><span class="line"></span><br><span class="line">4. 切换到mysql，将密码置空。</span><br><span class="line">use mysql;</span><br><span class="line">update user set authentication_string=&#x27;&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">5.然后刷新权限:</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">6. 设置加密规则并更新新密码，授权(直接复制这些SQL语句你的密码会更新为123456)</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27; PASSWORD EXPIRE NEVER; </span><br><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">grant all privileges  on *.*  to &quot;root&quot;@&#x27;localhost&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">6. 设置成功后，重启mysql服务，使用新密码登录</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<h3 id="6，导入sql执行文件或者navicate备份文件"><a href="#6，导入sql执行文件或者navicate备份文件" class="headerlink" title="6，导入sql执行文件或者navicate备份文件"></a>6，导入sql执行文件或者navicate备份文件</h3><ul>
<li>如果是sql执行文件，可以navicate右击库然后执行</li>
</ul>
<img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250901184649941.png" alt="image-20250901184649941" style="zoom: 33%;" />

<ul>
<li><p>如果用的黑框，使用source指令，source 路径</p>
<ul>
<li>绝对路径和相对都行</li>
<li>路径中使用的是&#x2F;这个斜杠</li>
<li>相对路径的操作<ul>
<li>.&#x2F;代表当前目录，source  .&#x2F;zxr.sql代表执行当前目录下的sql文件，.&#x2F;一般可以省略</li>
<li>..&#x2F;代表上一级目录，source  ..&#x2F;zxr.sql 代表去上一级中执行sql文件</li>
<li>每一个..&#x2F;代表上一级，source  ..&#x2F;..&#x2F;zxr.sql  代表去上两级执行sql文件</li>
<li>注意，如果在user目录 执行 mysql&#x2F;bin&#x2F;mysql -uroot -p,那么相对路径的基准目录是user而不是bin；配置环境变量同理，环境变量只影响是否能找到该执行文件，并不是先进入目录再执行，而是在当前目录，通过路径直接找到指令然后执行，当前目录依旧是基准目录</li>
</ul>
</li>
</ul>
</li>
<li><p>如果是navicate的备份文件，右击备份选择还原</p>
</li>
</ul>
<img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250901184831795.png" alt="image-20250901184831795" style="zoom:33%;" />

<h3 id="7，更改项目jdk版本"><a href="#7，更改项目jdk版本" class="headerlink" title="7，更改项目jdk版本"></a>7，更改项目jdk版本</h3><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250901224904182.png" alt="image-20250901224904182" style="zoom:33%;" />

<ul>
<li>项目结构中可以更改sdk也就是jdk版本，至于底下的模块，选择和项目语言相同这个选项就可以了</li>
</ul>
<h3 id="8，对密码进行md5加密处理"><a href="#8，对密码进行md5加密处理" class="headerlink" title="8，对密码进行md5加密处理"></a>8，对密码进行md5加密处理</h3><ul>
<li>md5加密会生成一个32位的字符串</li>
<li>md5加密是单向不可逆的，不能通过结果反推原本的密码，因此在比对的时候，先进行加密在与数据库中加密好的数据进行比对即可</li>
</ul>
<p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250901235001914.png" alt="image-20250901235001914"></p>
<ul>
<li>digestutils是基于springframework的，用于加密的工具类</li>
<li>md5digestashex会生成一个32位的字符串作为结果，相比于md5digest的128位二进制字节数组更加易于人类查看</li>
</ul>
<h3 id="9，后端生成接口文档，接口测试，knife4j"><a href="#9，后端生成接口文档，接口测试，knife4j" class="headerlink" title="9，后端生成接口文档，接口测试，knife4j"></a>9，后端生成接口文档，接口测试，knife4j</h3><p>1，knife4j是一个框架，集成了swagger，简化了swagger的操作</p>
<p>2，在springboot中使用knife4j</p>
<ul>
<li>导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置类中创建需要的bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//设置主页信息</span></span><br><span class="line">    <span class="type">ApiInfo</span> <span class="variable">apiInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">        .title(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">        .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">        .description(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//指定swagger版本为swagger2</span></span><br><span class="line">    <span class="type">Docket</span> <span class="variable">docket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(apiInfo)</span><br><span class="line">        .select()</span><br><span class="line">        <span class="comment">//指定需要扫描的包</span></span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.sky.controller&quot;</span>))</span><br><span class="line">        .paths(PathSelectors.any())</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> docket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置静态资源映射，把访问地址映射到静态资源上；如果没有设置映射，springmvc会把这个路径当做一个controller的路径，就找不到会404</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//knife4j会吧生成的静态资源都放到classpath下的路径中，在浏览器访问/doc.html的时候，要映射才能访问到classpath下的真正的静态资源</span></span><br><span class="line">    registry</span><br><span class="line">        .addResourceHandler(<span class="string">&quot;/doc.html&quot;</span>)</span><br><span class="line">        .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">    registry</span><br><span class="line">        .addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">        .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过服务的ip+端口+&#x2F;doc.html可以直接访问主页</li>
</ul>
<img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250902115930274.png" alt="image-20250902115930274" style="zoom: 50%;" />

<p>3，knife4j常用注解</p>
<ul>
<li>@Api：用在类上，比如controller类，描述类的作用、<ul>
<li>tags参数写描述信息</li>
</ul>
</li>
<li>@ApiModel：用在实体类上，比如dto，vo，entity，描述作用<ul>
<li>description参数写描述信息</li>
</ul>
</li>
<li>@ApiModelProperties：用在实体类的属性上<ul>
<li>value参数写描述信息</li>
</ul>
</li>
<li>@ApiOperation：用在方法上，描述方法的信息，作用，参数，返回值等<ul>
<li>value参数写描述信息</li>
</ul>
</li>
<li>@ApiImplicitParams：用于描述参数信息，可以包含一个参数列表</li>
<li>@ApiImplicitParam：描述参数列表中的每一个参数<ul>
<li>name：必填，和方法签名中的参数名必须一致</li>
<li>value：非必填，对参数的描述</li>
<li>required：非必填，描述参数是否可以不传</li>
<li>paramType：必填，指定参数所在的位置<ul>
<li>query：代表在路径中通过？拼接的参数</li>
<li>path：代表路径中使用{}restfull风格的参数</li>
<li>header：请求头中的参数</li>
<li>cookie：cookie中的参数</li>
<li>body：请求体中的参数</li>
<li>cookie和header都可以通过httprequest对象获取</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10，接口设计，apifox"><a href="#10，接口设计，apifox" class="headerlink" title="10，接口设计，apifox"></a>10，接口设计，apifox</h3><p>1，接口设计是在写代码之前开会讨论需要什么接口，形成一个文档，同时管理和维护；后面按照文档开发即可，可以使用apifox或yapi等</p>
<p>2，swagger是后端进行开发的时候，用于自测接口功能的，和设计文档不是一个作用</p>
<h3 id="11，接口开发流程"><a href="#11，接口开发流程" class="headerlink" title="11，接口开发流程"></a>11，接口开发流程</h3><p>1，通过需求看参数</p>
<ul>
<li>是否必须</li>
<li>参数类型</li>
<li>请求头中参数传递方式，是否是JSON</li>
<li>参数校验：号码11位，身份证号18位，用户名和手机号唯一，参数是否必须</li>
<li>返回类型，是否要封装成Result对象，一般包含<ul>
<li>code：请求结果码</li>
<li>data：如果有，代表实际返回的值</li>
<li>message：如果有，代表后端传来的错误信息，一般用于展示给用户</li>
</ul>
</li>
</ul>
<p>2，看数据库</p>
<ul>
<li>是否需要唯一</li>
<li>是否需要主键</li>
<li>是否需要默认值</li>
</ul>
<h3 id="12，数据接收，传递，入库"><a href="#12，数据接收，传递，入库" class="headerlink" title="12，数据接收，传递，入库"></a>12，数据接收，传递，入库</h3><p>1，前端数据直接使用dto接收</p>
<p>2，传输使用dto，入库需要把dto转成entity，因为dto的属性不完全</p>
<p>3，可以使用：</p>
<ul>
<li>BeanUtils.copypropertise转化，并且手动赋值其他没有的属性</li>
<li>使用lombok的builder，Entity.Builder().build()能链式的赋值，注意返回的是新对象，需要接收，不保留之前对象属性的值，所以两种方法不要混用</li>
</ul>
<h3 id="13，前端传入JSON对象"><a href="#13，前端传入JSON对象" class="headerlink" title="13，前端传入JSON对象"></a>13，前端传入JSON对象</h3><p>1，需要用@RequestBody接收，不然收不到</p>
<h3 id="14，全局异常处理"><a href="#14，全局异常处理" class="headerlink" title="14，全局异常处理"></a>14，全局异常处理</h3><p>1，设定一个自定义异常，通常继承运行时异常类，或者继承自自定义异常基类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> <span class="keyword">extends</span> <span class="title class_">BaseException</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message, <span class="type">int</span> code)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置了三个构造器，在手动throw的时候可以选择参数</li>
</ul>
<p>2，通过方法增强，捕获异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获全局自定义异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex 异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 异常信息以及状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler()</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">exceptionHandler</span><span class="params">(CustomException ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(ex.getMessage(),ex.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@RestControllerAdvice是切面，切点是所有的controller方法，rest表示方法return的结果以JSON形式返回，而不是作为路径跳转</li>
<li>@ExceptionHandler()是专门在切面中进行异常捕获功能增强的注解，在注解的Value参数中写需要捕获的异常类型，没写的话会根据方法参数类型推出来</li>
<li>原理就是，对所有controller方法都做了增强，也就是代理，代理原理就是在controller方法外加上try-catch代码，catch的类型就是指定的类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 代理方法(原始方法)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        原始方法.invoke();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(CustomException e)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15，获取用户上下文信息"><a href="#15，获取用户上下文信息" class="headerlink" title="15，获取用户上下文信息"></a>15，获取用户上下文信息</h3><p>1，在进行增删改操作时，要获取用户信息并存入记录中，以记录是谁进行的修改</p>
<p>2，方案一：在拦截器中，通过token反推出存入token的信息，再去库里查询完整的信息，存入threadlocal</p>
<ul>
<li>创建threadLocal实例，一般都会对threadlocal进行包装，提供静态的存取删方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 员工上下文，用于传递当前请求的员工信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Employee&gt; employeeHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Employee <span class="title function_">getEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> employeeHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setEmployee</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        employeeHolder.set(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        employeeHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过请求头中的token，获取信息，再去库查询完整信息，再存入ThreadLocal</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span>&#123;</span><br><span class="line">    <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、校验令牌,令牌生成时是利用id，所以可以通过令牌反推出id</span></span><br><span class="line"><span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line"><span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//将员工信息放入threadLocal</span></span><br><span class="line">Employee employee;</span><br><span class="line">employee = employeeMapper.getById(empId);</span><br><span class="line">EmployeeContext.setEmployee(employee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//别忘了在请求结束后移除ThreadLocal中的内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//请求完成时删除清空threadLocal</span></span><br><span class="line">    EmployeeContext.removeEmployee();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意请求结束后清空内容</li>
<li>由于一个请求在controller，service，mapper直至返回都是同一个线程，所以这种方式在3层都可以获取</li>
</ul>
<p>3，方案二：自定义一个注解，例如@Login，注解类型为修饰参数，例如User user</p>
<ul>
<li>在参数解析器中，取到有@Login修饰且参数类型是User的参数</li>
<li>通过token和库查到用户信息</li>
<li>将用户信息通过反射插入该参数</li>
<li>这时参数就有用户信息，在每一层方法都带上此参数，就能获取到用户信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUserResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数解析器和拦截器都是在controller之前执行，但是分工不一样，应正确使用</li>
<li>这种方法只能给controller的参数赋值，如果其他层想用，那么将此参数作为参数传递下去即可</li>
</ul>
<h3 id="16，mybatis中带条件的分页查询"><a href="#16，mybatis中带条件的分页查询" class="headerlink" title="16，mybatis中带条件的分页查询"></a>16，mybatis中带条件的分页查询</h3><p>1，传入的数据为，需要展示的页码，每一页的数量，查询条件；前端的数据应当专门建一个pageXXXDTO来接收</p>
<ul>
<li>注意前端的的参数是quey类型(路径中拼接)，后端使用对象可以直接接收；如果前端传入的是JSON，那么后端要加@RequestBody</li>
</ul>
<p>2，分页的结果应当封装到一个pageResult类里，类的属性根据前端需要的属性来定，正常需要的是总条数，和当前展示页的数据列表</p>
<p>3，一般返回前端的都是Result统一结果，一般包含响应信息，响应码，data数据；这个data一般用T泛型表示或者是Object，所以返回的时候返回Result&lt;pageResult&gt; 就指明了data类型是pageResult，然后pageResult又包含总条数和数据列表</p>
<p>4，手动方案进行分页</p>
<ul>
<li>手动先根据条件筛选，然后计算需要页码的开始和结束条目，使用limit截取返回即可</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryEmployeePage&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from employee</span><br><span class="line">    <span class="comment">&lt;!--需要动态判断条件存在不存在，使用动态标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 模糊查询使用concat拼接比较好--&gt;</span></span><br><span class="line">            and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--谨记limit不需要打括号，limit的含义是跳过start条数据，取pageSize条数据--&gt;</span></span><br><span class="line">    limit #&#123;start&#125;,#&#123;pageSize&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>start计算的时候，page一定要减一，比如需要第一页的，那就从0*pageSize&#x3D;0开始；第二页就是从1*pageSize&#x3D;pageSize开始</li>
</ul>
<p>5,使用插件进行分页，原理就是，把pageNum，pageSize保存到threadLocal中，在sql执行之前，拦截执行sql的方法，判断threadLocal是否有分页信息，有的话就进行拼接limit然后执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定分页的页码，每一页的条数</span></span><br><span class="line">PageHelper.startPage(pageNum,pageSize);</span><br><span class="line"><span class="comment">//直接使用条件查询，插件会自动拦截下一条sql，把计算好的limit的值拼接到sql后面，这里返回的一定是Page对象 </span></span><br><span class="line">Page&lt;Employee&gt; page = employeeMapper.queryEmployeePageList(name);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//page对象中包含了结果和总数，直接用就行</span></span><br><span class="line">pageResult.setRecords(page.getResult());</span><br><span class="line">pageResult.setTotal(page.getTotal());</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注意分页的返回值是Page&lt;Employee&gt;中的泛型类型，而不是Page类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryEmployeePageList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sky.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--习惯写上and，where标签会自动去除不需要的and和or，但是多条件不写and就会出错--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在mapper接口中，如果安装了mybatisx插件，mapper接口没有对应sql会爆红，alt+enter可以自动创建sql，自动填写id和返回值</li>
<li>必须导入pagehelper依赖才可以使用</li>
</ul>
<h3 id="17，后端返回给前端日期类型的格式化"><a href="#17，后端返回给前端日期类型的格式化" class="headerlink" title="17，后端返回给前端日期类型的格式化"></a>17，后端返回给前端日期类型的格式化</h3><h3 id="18-在乌班图中下载并安装redis"><a href="#18-在乌班图中下载并安装redis" class="headerlink" title="18.在乌班图中下载并安装redis"></a>18.在乌班图中下载并安装redis</h3><p>1，通过wget <a href="https://download.redis.io/releases/redis-6.0.5.tar.gz%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%9C%A8%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E8%BD%BD%E5%8E%8B%E7%BC%A9%E5%8C%85">https://download.redis.io/releases/redis-6.0.5.tar.gz能直接在当前目录下载压缩包</a></p>
<p>2.使用tar -zvxf redis-6.0.5.tar.gz -C &#x2F;usr&#x2F;local&#x2F;redis 把压缩包解压到&#x2F;usr&#x2F;local&#x2F;redis目录里面</p>
<ul>
<li>tar是tape archive的缩写，用于打包或者解压文件</li>
<li>z代表使用gzip压缩算法，以.tar.gz或者tgz结尾的必须加上</li>
<li>v，verbose表示显示详细的文件列表，可以不加</li>
<li>x，代表解压缩；c代表压缩</li>
<li>f，指定文件，f后面必须跟文件</li>
<li>一般的软件都建议放在&#x2F;usr&#x2F;local里，redis这个文件夹要自创；使用sudo mkdir redis创建一个文件夹，需要使用sudo给权限，首次sudo 要输用户密码</li>
</ul>
<p>3，由于redis是c语言写的，编译之前要安装编译器，sudo apt install g++，相当于在centos中的yum install gcc-c++</p>
<p>4，进入解压后的目录，使用 sudo make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install，编译并安装</p>
<ul>
<li>make用于编译，PREFIX指定安装目录</li>
</ul>
<p>5，默认redis-cli等指令放在PREFIX&#x2F;bin下；配置文件放在PREFIX&#x2F;etc下；包文件放在PREFIX&#x2F;lib下</p>
<h3 id="19，redis的配置"><a href="#19，redis的配置" class="headerlink" title="19，redis的配置"></a>19，redis的配置</h3><p>1，设置daemonize yes表示后台启动服务</p>
<p>2，设置protected-mode no关闭保护模式</p>
<p>3，设置bind 0.0.0.0 开启远程连接</p>
<p>4，设置requirepass  redis表示连接时需要密码，密码是redis字符串</p>
<p>5，默认的redis.conf文件在解压后的文件夹里，而redis-server等命令在安装目录的bin下面</p>
<ul>
<li>为了方便使用，直接复制一份conf到bin同级：sudo cp rdis.conf ..&#x2F;redisv1.conf 复制到上级一个文件并重命名</li>
<li>运行时，先切换到root用户，否则无法开启文件权限，redis的数据存不进文件里：su root，然后输入密码就行</li>
</ul>
<h3 id="20，vim的使用"><a href="#20，vim的使用" class="headerlink" title="20，vim的使用"></a>20，vim的使用</h3><p>1，安装vim ：sudo apt install vim</p>
<p>2，sudo vim 文件</p>
<p>3，操作</p>
<ul>
<li>i，进编辑模式</li>
<li>esc，回浏览模式</li>
<li>浏览模式中<ul>
<li>？txt：向后搜索txt字符串，n代表下一个，N代表上一个</li>
<li>&#x2F;txt:向前</li>
<li>：wq，保存退出，：wq！强制保存退出</li>
<li>：q！，退出不保存</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>java项目-苍穹外卖</tag>
      </tags>
  </entry>
  <entry>
    <title>注意点</title>
    <url>/2025/08/19/%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<p>1，每次编写代码之前，需要更新到最新版本，利用idean中git的update操作</p>
<p>2，在改了代码后，执行Maven生命周期的clean操作可以删除target的文件，就不会导致代码更新不及时</p>
<ul>
<li>clean，删除target，里面包含和编译好的文件</li>
<li>test，运行所有的单元测试</li>
<li>complie，编译java目录下面的源代码，不涉及测试代码</li>
<li>package，执行complied+test，根据设定的打包类型jar&#x2F;war生成可分发包在target</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>实际操作注意点</tag>
      </tags>
  </entry>
  <entry>
    <title>错题</title>
    <url>/2025/08/03/%E9%94%99%E9%A2%98/</url>
    <content><![CDATA[<h1 id="SQL-MySQL"><a href="#SQL-MySQL" class="headerlink" title="SQL-MySQL"></a>SQL-MySQL</h1><p>1，查找条件为不等于</p>
<ul>
<li>!&#x3D;</li>
<li>&lt;&gt;</li>
<li>not in()</li>
</ul>
<p>2，查找条件为非空</p>
<ul>
<li>is not null</li>
</ul>
<p>3,order by 默认 asc升序</p>
<p>4，模糊查询通配符意义，···where name like···</p>
<ul>
<li>%：多个任意字符</li>
<li>_:一个任意字符</li>
</ul>
<p>5，正则匹配，··where name regexp··· （内有乾坤，有时间了再详细去看）</p>
<ul>
<li>[abc]：abc范围内任意一个字符</li>
<li>[^abc] : abc范围外的任意一个字符</li>
</ul>
<p>6，查找某列最大值</p>
<ul>
<li>先order by xx desc降序，再limit 1，取一个<ul>
<li>limit(a,b)表示跳过a个后取b个</li>
</ul>
</li>
<li>直接select max(xx) as xx,给列取一个别名代替max(xx)</li>
</ul>
<p>7,avg，count，round，as，group by，order by，的使用</p>
<p>求每个班，男生和女生分别的，语文和数学平均成绩，人数，结果以班级为首列，性别为第二列，以班级+性别升序排列，成绩保留1位小数</p>
<ul>
<li>每个班-&gt;以班级分组；男女-&gt;以性别分组；应当有班级+性别作为分组条件</li>
<li>平均成绩用avg(成绩列) as xx；某列的平均数并起别名<ul>
<li>保留小数用round(a,b),给a保留b位小数</li>
</ul>
</li>
<li>计数用count(*),conut(列名)会略过null值</li>
<li>结果：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">#一定记住把分组条件放进结果集，不然结果意义不明，看不懂</span><br><span class="line">class,</span><br><span class="line">gender, </span><br><span class="line">#<span class="keyword">as</span>用来设置别名，也就是结果集最终的列名，<span class="keyword">as</span>写在所有的聚合函数后面，等运行好了再设置别名</span><br><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sum_num,</span><br><span class="line">round(<span class="built_in">avg</span>(math),<span class="number">1</span>) <span class="keyword">as</span> avg_math,</span><br><span class="line">round(<span class="built_in">avg</span>(chinese),<span class="number">1</span>)  <span class="keyword">as</span> avg_chinese,</span><br><span class="line"><span class="keyword">from</span> t_score </span><br><span class="line">#永远是先分组，再排序，再limit筛选</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> class,gender </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span>  class,gender;</span><br></pre></td></tr></table></figure>



<p>8，sql执行顺序</p>
<ul>
<li>通过from或者join确定原始数据来源</li>
<li>通过where进行过滤</li>
<li>过滤完通过group by进行分组</li>
<li>分组后的结果通常包含一对多，检查是否需要对多使用聚合函数，分组后结果集基本形成，对结果集进行聚合函数运算也在这一步，这样下一步having就可以拿到聚合函数结果进行判断了</li>
<li>having通过聚合函数的结果进行条件判断，比如取分组后，数学平均成绩大于80的组；<ul>
<li>注意：having子句在select执行之前执行，所以在select关键字后定义的列的别名按理是不可以在having子句中直接引用的</li>
<li>但是：mysql对此进行了语法糖优化，可以把select中对聚合函数列(只限聚合函数列，普通列不行)的别名直接用于having子句</li>
<li>然而：不提倡写这种，老老实实写聚合函数表达</li>
</ul>
</li>
<li>select ，选择需要列生成最终结果集</li>
<li>distinct，对最终的列进行去重</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">distinct</span>是对结果集的所有行去重，<span class="keyword">distinct</span>后接的是去重依据，这条依据department, employee_name对结果集去重</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department, employee_name <span class="keyword">FROM</span> employees;</span><br><span class="line">#下面这个是语法错误，</span><br><span class="line"><span class="keyword">SELECT</span> department, <span class="keyword">DISTINCT</span> employee_name <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<ul>
<li>order by，对最终的结果集排序</li>
<li>limit ，指定最终结果集的显示数量</li>
</ul>
<p>9，表连接</p>
<ul>
<li>join&#x2F;innerjoin：求交集，左表和有表都满足连接条件的行才会组合</li>
<li>left join：以左表为依据，右表满足条件的行会组合，右表没有满足条件的行，对应的select 出来的列值为null</li>
<li>right：和left相反</li>
<li>full join：左右两边都组合，不满足条件用null值替代</li>
</ul>
<h1 id="基础知识-MySQL"><a href="#基础知识-MySQL" class="headerlink" title="基础知识-MySQL"></a>基础知识-MySQL</h1><p>1，主从复制</p>
<p>2，分库分表</p>
<p>3，死锁</p>
<p>4，锁类型</p>
<p>5，索引术语</p>
<h3 id="6，索引下推"><a href="#6，索引下推" class="headerlink" title="6，索引下推"></a>6，索引下推</h3><ul>
<li>联合索引第一列命中，第二列没有命中，比如where a &#x3D;1 and c&#x3D;1，a&#x3D;1可以走索引，无需回表，这个联合索引中已经有c的值，直接在server层判断就好了</li>
<li>使用了索引下推，extra 会显示using index condition</li>
</ul>
<h3 id="7，索引合并"><a href="#7，索引合并" class="headerlink" title="7，索引合并"></a>7，索引合并</h3><ul>
<li>索引交集，where a&#x3D;1 and b &#x3D;2，a，b列都有联合索引，独立查出来，然后去重<ul>
<li>一定程度上可以替代a,b联合索引，减少索引冗余</li>
<li>联合索引效率会快一些</li>
</ul>
</li>
<li>索引并集，a&#x3D;1 or b&#x3D;2,和上面的相同</li>
</ul>
<h1 id="基础知识-Redis"><a href="#基础知识-Redis" class="headerlink" title="基础知识-Redis"></a>基础知识-Redis</h1><p>1，数据结构底层原理</p>
<p>2，io多路复用对于Redis的作用</p>
<ul>
<li>单线程的情况下应对多个并发的网络连接</li>
<li>时间驱动消除连接等待</li>
<li>最大程度消除网络阻塞带来的影响</li>
</ul>
<h1 id="基础知识-SpringCloudAlibaba"><a href="#基础知识-SpringCloudAlibaba" class="headerlink" title="基础知识-SpringCloudAlibaba"></a>基础知识-SpringCloudAlibaba</h1><p>1，openfeign底层原理和流程</p>
<h1 id="基础知识SSM"><a href="#基础知识SSM" class="headerlink" title="基础知识SSM"></a>基础知识SSM</h1><h3 id="1，spring事务失效的场景"><a href="#1，spring事务失效的场景" class="headerlink" title="1，spring事务失效的场景"></a>1，spring事务失效的场景</h3><ul>
<li>事务方法所在类没有被spring管理</li>
<li>方法被final修饰，aop无法重写方法，无法实现事务</li>
<li>非public的方法</li>
<li>同一个类自调用用的是原对象，不是代理对象，事务是代理对象增强的结果</li>
<li>传播类型错误</li>
<li>异常被内部catch了，不会触发回滚</li>
</ul>
<h3 id="2，mybatis分页的具体实现"><a href="#2，mybatis分页的具体实现" class="headerlink" title="2，mybatis分页的具体实现"></a>2，mybatis分页的具体实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑分页，先读到内存中，在进行分页</span></span><br><span class="line"><span class="type">RowBounds</span> <span class="variable">rowBounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowBounds</span>(offset, limit);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectAllUsers(rowBounds);</span><br><span class="line"><span class="comment">//物理分页，直接更改sql语句</span></span><br><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">List&lt;User&gt; users = userMapper.getAllUsers();</span><br></pre></td></tr></table></figure>

<h1 id="面试经验"><a href="#面试经验" class="headerlink" title="面试经验"></a>面试经验</h1><h3 id="1，springboot给静态字段注入值"><a href="#1，springboot给静态字段注入值" class="headerlink" title="1，springboot给静态字段注入值"></a>1，springboot给静态字段注入值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过@PostConstruct注解配合非静态临时字段来给静态字段赋值</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String apiKey; <span class="comment">// 静态字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.api.key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tempApiKey; <span class="comment">// 非静态临时字段</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initStaticFields</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将非静态字段的值赋给静态字段</span></span><br><span class="line">        apiKey = <span class="built_in">this</span>.tempApiKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ *</span><br><span class="line"><span class="number">1</span>，创建一个非静态的字段，给非静态字段注入值,</span><br><span class="line"><span class="number">2</span>，定义PostConstruct注解，这个注解在的方法，会在其他注入完成后执行(必须在<span class="meta">@value</span>执行完之后)，在方法内可以给静态字段赋值</span><br><span class="line">* /</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加上了@Value注解的方法，会吧值放进参数里，拿到参数给静态变量赋值</span></span><br><span class="line"><span class="comment">//这个方法名不限，只能有一个参数，只能是public void修饰</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String dbUrl; <span class="comment">// 静态字段</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;database.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDbUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="comment">// 在setter中直接设置静态字段</span></span><br><span class="line">        DatabaseConfig.dbUrl = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>1，alt+8可以快速唤出底下services控制台</p>
<p>2，alt+9调出git提交日志</p>
<p>3，alt+0调出提交页面，选择需要提交的类，写上提交注释，点击commitandpush</p>
<ul>
<li>如果直点击了commit，需要在导航栏点击git并点击push才能推到远程</li>
</ul>
<p>4，BeanCopyUtils.copyListPropertise(entities,dto);可以直接把一个list的对象转换类型并赋值，就不需要一个一个循环赋值或者是用stream流了</p>
<p>5，在dao上加上@mapper，再使用@mapperscan配置，即可读取到dao接口，加上@repository可以增加可读性并且启动的时候spring不会警告说找不到这个bean</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>面试八股文汇总</title>
    <url>/2025/07/28/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="语言的三大特性"><a href="#语言的三大特性" class="headerlink" title="语言的三大特性"></a>语言的三大特性</h2><p>1，封装：将属性和方法封装到类中，隐藏实现细节，通过公共接口和外界交互；可以防止外界直接修改敏感数据；安全性高</p>
<p>2，继承：子类继承父类的属性和方法；实现代码复用</p>
<p>3，多态：同一个操作作用不同对象，产生不同行为；分为编译时多态(重载)和运行时多态(重写)；提高了拓展度，降低了耦合，提高了灵活性</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>1，重载：只与参数相关，参数数量，返回类型，参数顺序；主要用于同一个类中横向拓展</p>
<p>2，重写：参数要相同，返回类型只能是被重写的同类或子类，修饰符只能大于等于被重写的；用于父类子类纵向拓展</p>
<h2 id="包装类型相对基本类型的好处"><a href="#包装类型相对基本类型的好处" class="headerlink" title="包装类型相对基本类型的好处"></a>包装类型相对基本类型的好处</h2><p>1，可以用与数组，集合，泛型</p>
<p>2，提供了操作数据的一系列方法</p>
<p>3，有null可以代表是否查到，基本类型只有0无法区分结果和没查到</p>
<h2 id="static关键字修饰变量，方法"><a href="#static关键字修饰变量，方法" class="headerlink" title="static关键字修饰变量，方法"></a>static关键字修饰变量，方法</h2><p>1，static只能修饰成员变量，不可以修饰局部变量</p>
<p>2，static方法内在只能用static变量，只能调static方法</p>
<p>3，普通方法可以调static变量和方法</p>
<h2 id="抽象类和接口异同"><a href="#抽象类和接口异同" class="headerlink" title="抽象类和接口异同"></a>抽象类和接口异同</h2><p>1，同：</p>
<ul>
<li>都不能实例化</li>
<li>都可以有抽象方法</li>
</ul>
<p>2，异：</p>
<ul>
<li>抽象类可以有成员变量和常量，接口只能有public的常量</li>
<li>抽象类可以有完整的非抽象方法，接口1.8后才有default方法</li>
<li>抽象类只能单继承，接口可以实现多个</li>
<li>接口强调单个功能实现，抽象类强调类之间所属关系</li>
</ul>
<h2 id="如何自定义一个异常"><a href="#如何自定义一个异常" class="headerlink" title="如何自定义一个异常"></a>如何自定义一个异常</h2><p>1，实现Exception或者RuntimeException</p>
<p>2，创建有参和无参构造</p>
<p>3，构造中用super调用父类的构造</p>
<p>4，使用的时候直接throw，利用构造方法创建对象</p>
<h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p>1，浅拷贝指的是调用Object的clone方法，拷贝时基本类型变量会复制一份，引用类型只会复制引用，前后的对象的变量都存储同一个对象的地址</p>
<p>2，深拷贝指的在浅拷贝的基础上，手动新建对象赋值或者递归调用浅拷贝方法，来完成引用类型的复制</p>
<p>3，需要实现cloneable接口才可以使用clone方法，否则会报异常</p>
<p>4，层级过多可以选择序列化反序列化来深拷贝</p>
<h2 id="comparator和comparable的区别"><a href="#comparator和comparable的区别" class="headerlink" title="comparator和comparable的区别"></a>comparator和comparable的区别</h2><p>1，类实现comparable接口，可以给当前类制定一个排序规则，写在compare方法里，这个类的对象互相之间被排序时将会使用这个规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//students实现的是comparable接口，直接排序即可</span></span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2，comparator接口是规则接口，指定泛型为规则适用的类，每一个comparator接口的实例都是一个排序规则，可以通过多个接口写上同一泛型类，达到给这个类多种可选的规则的目的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过传入多个comparator实例来指定排序规则</span></span><br><span class="line"><span class="comment">//按照姓名排序</span></span><br><span class="line">Collections.sort(students, <span class="keyword">new</span> <span class="title class_">NameComparator</span>());</span><br><span class="line">     </span><br><span class="line"><span class="comment">// 按年龄排序</span></span><br><span class="line">Collections.sort(students, <span class="keyword">new</span> <span class="title class_">AgeComparator</span>());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型用于指定规则适用的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.getName().compareTo(s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>1，序列化指的是从java对象转成字节序列，反序列化相反</p>
<p>2，通常在网络传输，文件持久化等地方需要序列化成字节序列</p>
<p>3，使用ObjectInputStream .readObject可以完成反序列化；ObjectOutputStream .writeObject可以完成序列化</p>
<p>4，序列化需要实现Serializable接口，需要重写版本号用于正确的反序列化；对象中不需要序列化的成员变量可以加上transient关键字</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="ArrayList和Linkedlist的区别"><a href="#ArrayList和Linkedlist的区别" class="headerlink" title="ArrayList和Linkedlist的区别"></a>ArrayList和Linkedlist的区别</h2><p>1，arraylist底层是动态数组，适合随机读取；linkedlist的底层是双链表，适合头尾的增删</p>
<p>2，linkedlist由于要存储额外的前后指针，所以占用内存较多</p>
<h2 id="list如何在遍历中删除元素"><a href="#list如何在遍历中删除元素" class="headerlink" title="list如何在遍历中删除元素"></a>list如何在遍历中删除元素</h2><p>1，获取迭代器，遍历的时候调用迭代器的remove</p>
<p>2，for i遍历的时候，使用后序遍历，删除时不会影响被删除元素之前的部分</p>
<p>3，不可以使用for i前序遍历，因为删除元素之后，后面元素会补到当前的位置，这个位置已经访问过，补上来的元素就会被略过</p>
<h2 id="HashMap容量，负载因子，扩容"><a href="#HashMap容量，负载因子，扩容" class="headerlink" title="HashMap容量，负载因子，扩容"></a>HashMap容量，负载因子，扩容</h2><p>1，初始容量16，负载因子0.75；当 元素数量&gt;容量*负载因子 时，触发扩容；扩容倍数为2</p>
<p>2，hash冲突的链表长度达到8，并且元素总数&gt;64时，触发链表转红黑树，如果没有超过64，只会扩容</p>
<h2 id="为什么hash容量设计成2的倍数"><a href="#为什么hash容量设计成2的倍数" class="headerlink" title="为什么hash容量设计成2的倍数"></a>为什么hash容量设计成2的倍数</h2><p>1，方便桶的计算：hashmap的桶，是通过调用key的hashcode方法取得32位hashcode，再hashcode与本身高16位进行异或操作，结果再与上容量-1(table长)，结果即为数组下标，用于存放value</p>
<ul>
<li>由于数组长度通常不会超过16位，因此高16位hash不起作用；通过高16和低16进行异或操作，发挥作用，增加散列程度</li>
<li>异或操作相比与和或，结果是1：1，更加均匀</li>
<li>由于数组长(容量)设计成2的倍数，那么使用&amp;操作即可达到取模的结果，位运算的速度快于取模，提高了效率</li>
</ul>
<p>2，方便扩容后的重hash：hashcode()&#x3D;&#x3D;h；r&#x3D;(h^h&gt;&gt;16)&amp;tableLen-1</p>
<ul>
<li>扩容时&amp;之前的式子不变，tableLen变成两倍也就是最高位写上1</li>
<li>只要判断r在新增的tableLen那个最高位上，是1还是0，是1代表结果总体*2，那么桶位置变化到两倍下标；如果是0，那一位&amp;的结果也是0，代表桶的位置不变</li>
<li>因此，重hash时仅需判断，高一位的r是1还是0即可完成任务，省去了从0开始重hash繁多的步骤，提高的效率</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><p>1，直接new</p>
<p>2，反射调用构造函数创建</p>
<p>3，通过对象拷贝</p>
<p>4，通过对象序列化和反序列化</p>
<h2 id="反射定义"><a href="#反射定义" class="headerlink" title="反射定义"></a>反射定义</h2><p>1，在程序运行状态中能动态的获取类信息并调用其方法的功能叫反射</p>
<h2 id="获取class对象的方式"><a href="#获取class对象的方式" class="headerlink" title="获取class对象的方式"></a>获取class对象的方式</h2><p>1，类.class</p>
<p>2，Class.forName</p>
<p>3，对象.getClass</p>
<h2 id="反射的优点和缺点"><a href="#反射的优点和缺点" class="headerlink" title="反射的优点和缺点"></a>反射的优点和缺点</h2><p>1，优点：</p>
<ul>
<li>动态操作，适用于框架</li>
<li>突破访问限制，可以访问和修改私有成员</li>
</ul>
<p>2，缺点：</p>
<ul>
<li>效率低，jvm不会对反射代码进行优化</li>
<li>安全性低，绕过访问控制，破坏封装</li>
</ul>
<h2 id="通过反射创建对象，属性赋值，调用方法举例"><a href="#通过反射创建对象，属性赋值，调用方法举例" class="headerlink" title="通过反射创建对象，属性赋值，调用方法举例"></a>通过反射创建对象，属性赋值，调用方法举例</h2><p>1，创建对象，先获取构造方法，之后直接传参调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class); <span class="comment">// 获取指定构造方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>2，对私有字段赋值时候要开启强制访问，需要指定是哪个对象的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获取私有字段</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);                   <span class="comment">// 强制访问私有属性</span></span><br><span class="line">nameField.set(user, <span class="string">&quot;Bob&quot;</span>);                      <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure>

<p>3，调用私有方法必须开启强制访问，需要指定调用的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">secretMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;secretMethod&quot;</span>);</span><br><span class="line">secretMethod.setAccessible(<span class="literal">true</span>);  <span class="comment">// 强制访问私有方法</span></span><br><span class="line">secretMethod.invoke(user);   </span><br></pre></td></tr></table></figure>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>1，使用：</p>
<ul>
<li>代码块中，锁指定的对象</li>
<li>静态方法中，锁类对象</li>
<li>普通方法中，锁this</li>
</ul>
<p>2，分类，原理：</p>
<ul>
<li>偏向锁：<ul>
<li>mark word存线程id，原mark word保存在该线程的栈帧的lock record中</li>
<li>获取锁只需要判断线程id和mark word中存的id是不是一样就可以</li>
<li>适合同步块大概率只由一个线程执行的场景</li>
</ul>
</li>
<li>轻量级锁：<ul>
<li>在栈中创建一片锁空间，markword指向该空间，空间内存markword原始值</li>
<li>加锁的时候尝试cas把markword指向自己的锁空间，失败会自旋一段时间</li>
<li>适合同步块执行时间很短的任务，短时间自旋消耗的cpu资源远小于直接阻塞导致的线程上下文切换</li>
</ul>
</li>
<li>重量级锁：<ul>
<li>加锁时，为对象创建一个monitor，对象头的markword指向monitor，monitor对象中的字段暂存markword原本的值</li>
<li>monitor中存储获取锁成功的线程，计数器计算重入次数</li>
<li>monitor拥有一个阻塞队列和一个等待队列，获取锁失败会进入阻塞队列，获取锁成功的线程调用wait会进入等待队列并释放锁；只有当线程被notify唤醒后重新获取时间片wait方法才会结束</li>
</ul>
</li>
</ul>
<p>3，升级：</p>
<p>4，性质：</p>
<ul>
<li>原子性，Synchronized包裹的代码对于其他线程来说是原子的，同时成功其他线程才可见，出现异常会失败且释放锁</li>
<li>可见性，Synchronized结束时会强行把代码块的变量刷新到主存，进入Synchronized时会直接去主存重读一个值，刷新进主存保证了对其他线程可见</li>
<li>有序性，Synchronized会保证同步块内外的指令不会重排序</li>
</ul>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>1，继承Thread类</p>
<p>2，实现Runnable接口，作为Thread的构造</p>
<p>3，实现Callable&lt;&gt;或者Runnable，交由线程池的submit执行，返回futrue，futrue的get可以异步获取结果</p>
<h2 id="线程状态以及方法"><a href="#线程状态以及方法" class="headerlink" title="线程状态以及方法"></a>线程状态以及方法</h2><p>1，NEW</p>
<ul>
<li>start方法调用之前</li>
</ul>
<p>2，RUNNABLE</p>
<ul>
<li>调用start之后</li>
<li>由等待转化过来：notify、signal、unpark</li>
<li>获取到锁由阻塞转化过来</li>
</ul>
<p>3，WAITING</p>
<ul>
<li>等待通知或中断</li>
<li>调用Tread.sleep、object.wait、condition.await、Locksuport.park、thread.join、lock.lock获取锁失败后</li>
</ul>
<p>4，TIMED_WAITING</p>
<ul>
<li>带定时参数的WAITING状态</li>
</ul>
<p>5，BLOCKED</p>
<ul>
<li>进入synchronized方法，代码块，获取锁失败</li>
</ul>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>1，线程池原理：核心线程数-&gt;阻塞队列-&gt;最大线程数-&gt;拒绝策略</p>
<p>2，作用：可以复用线程资源，管理线程</p>
<p>3，线程池参数：</p>
<ul>
<li>核心线程</li>
<li>阻塞队列</li>
<li>最大线程</li>
<li>拒绝策略:<ul>
<li>不拒绝，使用用户线程执行</li>
<li>丢弃</li>
<li>丢弃并报异常</li>
<li>丢弃最久没执行的任务</li>
</ul>
</li>
<li>空闲线程存活时间</li>
<li>时间单位</li>
<li>线程工厂</li>
</ul>
<p>4，线程池关闭</p>
<ul>
<li>shutdown：拒绝接收新任务，等待正在执行的和阻塞队列里的执行完</li>
<li>shutdownnow：拒绝新任务，尝试Interrupt正在执行的，放弃阻塞队列的任务，并返回一个未执行的任务组成的list</li>
</ul>
<h2 id="Executors提供的线程池以及它们的问题"><a href="#Executors提供的线程池以及它们的问题" class="headerlink" title="Executors提供的线程池以及它们的问题"></a>Executors提供的线程池以及它们的问题</h2><p>1，FixedThreadPool：核心线程固定，阻塞队列无界，拒绝策略无效；如果生产的速度远快于消费，会沾满内存</p>
<p>2，SingleThreadExector：核心线程为1的定长线程池</p>
<p>3，CatchedThreadPool：只有非核心线程的线程池，队列不装东西，最大线程数无限，存活时间60s，拒绝策略无效；如果并发任务过多会创建大量线程，占满cpu</p>
<p>4，SchedulePoolExecutor：主要分清楚两个方法</p>
<ul>
<li>scheduleAtFixedRate：正常情况下按照上个任务开始时间+设定的延迟时间&#x3D;这次开始时间，当时间到了后上一个还没结束，会等结束后执行后一个</li>
<li>scheduleWithFixedDelay：上次任务结束时间+设定的延迟时间&#x3D;这次开始时间</li>
</ul>
<h2 id="同步组件有哪些"><a href="#同步组件有哪些" class="headerlink" title="同步组件有哪些"></a>同步组件有哪些</h2><p>1，ReentrantLock锁：无参为非公平可重入</p>
<ul>
<li>可重入：加锁给计数器加一，解锁减一</li>
<li>公平锁：获取锁失败的线程排队，队头的先获取锁；消耗更多cpu保证只有队头能获取锁；不会出现饥饿问题</li>
<li>非公平锁：不保证入队顺序，不保证只有队头能获取锁；可能会导致饥饿问题；在入队前可以自旋，可能会减少上下文切换，获取锁之前不需要判断自己是否是队头</li>
</ul>
<p>2，Condition：条件等待队列，可以给ReentrantLock设置多个等待队列</p>
<ul>
<li>调用lock.newCondition可以创建一个等待队列</li>
<li>使用condition.await()可以释放锁后进入队列，前提是获取到了锁</li>
<li>使用condition.signal&#x2F;singnalAll可以唤醒等待队列线程</li>
<li>被唤醒线程重新获取到锁执行，此时await结束</li>
<li>对比Synchronized的waitset的好处是可以创建多个，根据不同的条件来等待和唤醒</li>
</ul>
<p>3，CountDownLatch：倒计时</p>
<ul>
<li>new的时候指定数量new CountDownLatch(5)</li>
<li>线程A调用countDownLatch.await方法等待</li>
<li>其他线程调用countDown方法时倒计时-1，减完A线程继续执行</li>
</ul>
<p>4，CyclicBarrier：循环屏障</p>
<ul>
<li>new的时候指定数量，当指定数量的线程都到达屏障，则会触发RUNNABLE：new CyclicBarrier(6，RUNNABLE)</li>
<li>6个线程分别调用cyclicBarrier.await()，最快的线程会等待所有线程都调用这个方法后，统一放行</li>
<li>之所以是循环的，是因为所有线程到达屏障后，屏障被重置，还可以继续调cyclicBarrier.await()，同样使用</li>
</ul>
<p>5，Semaphore：信号量，可以理解为一个可以被指定线程数同时获取的锁</p>
<ul>
<li>指定通行证的数量，Semaphore semaphore &#x3D; new Semaphore(5);</li>
<li>获取通行证，5次后阻塞，semaphore.acquire();</li>
<li>释放通行证，释放后可以被获取，semaphore.release();</li>
</ul>
<p>6，Exchanger：两个线程间的数据交换</p>
<ul>
<li>new Exchanger<String>()创建Exchanger，指定交换的数据类型</li>
<li>A先调用exchanger.exchange(a)方法，B后调用exchanger.exchange(b)</li>
<li>两个方法调用后，方法返回值便是交换后的数据</li>
</ul>
<h2 id="并发集合类有哪些"><a href="#并发集合类有哪些" class="headerlink" title="并发集合类有哪些"></a>并发集合类有哪些</h2><p>1，CopyOnWriteArrayList：写时复制一个新数组，在新数组上写，之后把变量指向新数组；读写分离，写不会影响读，但会导致短暂的数据不一致；变量使用volatile修饰保证修改完成之后的可见性</p>
<p>2，ConcurrentHashMap：</p>
<ul>
<li>写写操作，通过cas来保证空桶只会有一个人修改成功，避免覆盖导致某个写操作消失；对于链表和红黑树，会用Synchronized锁住头结点保证同时只会有一个线程写操作</li>
<li>读写操作(遍历时进行结构性修改)，将节点的v，和next都设置volatile，这样就无需快速失败机制，v保证修改可见，next保证增删可见</li>
<li>扩容：给就数组分成多个区间，每个区间由一个线程负责迁移进新数组<ul>
<li>修改sizeCtl为负数标记扩容进行中，防止多次进行扩容操作，sizeCtl必须使用cas操作保证修改操作的原子性</li>
<li>使用Synchronized锁住头节点，防止迁移中对链表或红黑树进行修改；这时如果读请求，直接读旧数组的数据即可；写请求会被阻塞</li>
<li>修改完后将旧数组的头节点变为ForwardingNode，扩容后这个节点在新数组的位置；这时读请求到达ForwardingNode会去指向的新数组的指定位置去读新的数据；写请求会先写到新数组，再帮助旧数组扩容</li>
</ul>
</li>
</ul>
<h2 id="atomic原子操作包"><a href="#atomic原子操作包" class="headerlink" title="atomic原子操作包"></a>atomic原子操作包</h2><p>1，CAS:通过硬件指令直接比较某内存的预期值和现在值，如果相同则更新为新值，过程原子</p>
<p>2，AtomicInteger：提供了一系列以CAS为原理的方法，getAndIncrement，IncrementAndGet，addAndGet(int i),getAndAdd(int i)</p>
<p>3，常用类AtomicIong，AtomicIntegerArray()，AtomicReference</p>
<p>4，AtomicStampedReference：同时检查预期值和当前值是否一样，版本戳是否一样，都一样才会进行更新，可以解决ABA问题</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>1，定义：JMM是Java规范定义的一套线程间同步和通信的规则，目的是解决多线程下的原子性，可见性，有序性问题</p>
<p>2，内容：JMM主要包括三方面</p>
<ul>
<li>线程通信模型：使用共享内存模型，变量放主内存共享，每个线程有自己单独的工作空间</li>
<li>内存访问方式：从主内存取副本，然后到工作空间用，之后刷新到主内存</li>
<li>指令重排序的约束(规则)</li>
</ul>
<p>3，对于指令重排的约束(约束)</p>
<ul>
<li>as-if-serial：无论怎么重排，单线程的执行结果不能变</li>
<li>happens-Before：定义了多线程下某些操作必然对后续操作可见<ul>
<li>volatile写先于volatile读</li>
<li>解锁先于后续加锁</li>
<li>线程启动先于线程内操作</li>
<li>线程内操作先于线程终止</li>
<li>happens-Before有传导性</li>
<li>A.join，A的后续所有操作先于调用方</li>
</ul>
</li>
</ul>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>1，AQS专门用于构建锁和同步器的框架，封装了改变state的方法，同步队列，排队，等待，唤醒等操作</p>
<p>2，提供了模版方法</p>
<ul>
<li><code>acquire(int arg)</code>：尝试获取独占锁，失败则入队列等待。</li>
<li><code>release(int arg)</code>：释放独占锁，并唤醒后继线程。</li>
<li><code>acquireShared(int arg)</code>：尝试获取共享锁，失败则入队列等待。</li>
<li><code>releaseShared(int arg)</code>：释放共享锁，并唤醒其他线程。</li>
<li><code>acquireInterruptibly(int arg)</code>：可中断地获取独占锁。</li>
<li><code>acquireSharedInterruptibly(int arg)</code>：可中断地获取共享锁。</li>
<li><code>tryAcquireNanos(int arg, long nanosTimeout)</code>：限时尝试获取独占锁。</li>
<li><code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：限时尝试获取共享锁。</li>
<li><code>isQueued(Thread thread)</code>：是否在排队</li>
</ul>
<p>3，模板方法会调用可重写的方法，以下是常用可重写的方法</p>
<p><code>tryAcquire(int arg)</code>：独占方式尝试获取资源，成功则返回true，失败则返回false。</p>
<p><code>tryRelease(int arg)</code>：独占方式尝试释放资源，成功则返回true，失败则返回false。</p>
<p><code>tryAcquireShared(int arg)</code>：共享方式尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
<p>tryReleaseShared(int arg)：共享方式尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
<ul>
<li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
</ul>
<p>4，使用指南：自定义锁实现lock接口，并创建静态内部类继承自AQS，实现AQS提供的被模版方法调用的几个Protected方法，主要是实现加锁解锁逻辑，如何修改state才算获取了锁，如何算解锁；在lock提供的加锁解锁方法中，调用静态内部类的模版方法即可</p>
<h2 id="死锁定位"><a href="#死锁定位" class="headerlink" title="死锁定位"></a>死锁定位</h2><p>1，去jdk的bin目录，使用jps指令来获取正在运行的jvm进程id</p>
<p>2，jstack -l pid ,就直接可以看到死锁信息</p>
<h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h1><h2 id="spring使用到的设计模式"><a href="#spring使用到的设计模式" class="headerlink" title="spring使用到的设计模式"></a>spring使用到的设计模式</h2><p>1，简单工厂模式</p>
<p>beanfactory通过传入bean的类型或者名字就可以获取不同的bean</p>
<p>2，工厂方法模式</p>
<p>FactoryBean是工厂方法模式的体现，通过实现FactoryBean接口实现不同的工厂，工厂里面写不同类的实现逻辑，好处是新增新的工厂时只需要新增类实现FactoryBean就好，不需要像简单工厂那样调整if-else if逻辑</p>
<p>3，单例模式</p>
<p>singleton的bean使用了单例模式</p>
<p>懒汉式 ，双重检验所，第一次判断可以让有bean之后不用每次都枷锁；volatile修饰禁止指令重排，保证没有被初始化的对象不会被使用</p>
<p>4，代理模式</p>
<p>aop使用了动态代理，分为jdk和cglib</p>
<p>5，模板方法模式</p>
<p>jdbctemplate，transactiontemplate</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>1，初始化创建对象放在static final的变量中，类初始化即创建唯一对象</p>
<ul>
<li>初始化由jvm控制，线程安全</li>
<li>每次都提前创建可能会浪费资源</li>
</ul>
<p>2，枚举类：需要的对象定义为枚举类的一个变量，枚举类初始化，该变量也完成创建</p>
<ul>
<li>jvm保证枚举变量唯一性，初始化时创建，线程安全</li>
<li>枚举类是构造私有的，且jvm禁止使用反射获取私有构造来创建枚举对象，天然防反射</li>
</ul>
<h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><p>1，双重检查锁</p>
<ul>
<li>外层的Synchronized是避免有对象后还要每次都进入同步块</li>
<li>volatile是为了防止指令重排曝光出还未初始化完成的对象</li>
<li>线程安全，延迟加载</li>
</ul>
<p>3，静态内部类：在静态内部类的static final变量中创建对象，只有当该变量被初次使用时，静态内部类才会初始化</p>
<ul>
<li>通过外部类延迟调用静态内部类的变量来实现延迟加载</li>
<li>通过静态内部类的初始化阶段创建对象来保证线程安全</li>
<li>线程安全，延迟加载</li>
</ul>
<h2 id="ioc和aop"><a href="#ioc和aop" class="headerlink" title="ioc和aop"></a>ioc和aop</h2><p>枚举类和管理对象的权力交给容器，好处是解耦合，增强了可测性</p>
<p>2，aop指的是切面编程，通过把横切逻辑从业务中分离形成切面；好处是可以在不修改原代码的基础上对方法进行功能增强，降低耦合，复用代码</p>
<p>3，使用注解实现aop</p>
<ul>
<li>@AspectJ标记类为切面</li>
<li>@pointcut在空方法上指定方法要切的包，类，方法等可以使用方法名复用代码</li>
<li>@Before @Around @After 在方法上指定方法要在目标的哪个位置切入；注解参数可以是@Pointcut，也可以是方法名</li>
</ul>
<p>4，spring默认有接口的情况下优先使用jdk代理，只有在没有接口的情况下才会使用cglib</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>1，实例化</p>
<p>2，属性注入</p>
<p>3，aware处理，如果bean实现了接口，spring会调用接口方法，参数包含bean想要的东西，bean可以在接口中把参数赋值给自身的成员变量</p>
<p>4，beanpostprocessor前</p>
<p>5，初始化</p>
<p>6，beanpostprocessor后；进行aop的地点</p>
<p>7，销毁</p>
<h2 id="注解-Autowired，-Resource，-Bean，-Component"><a href="#注解-Autowired，-Resource，-Bean，-Component" class="headerlink" title="注解@Autowired，@Resource，@Bean，@Component"></a>注解@Autowired，@Resource，@Bean，@Component</h2><p>1，Autowired默认使用类型注入，存在多个相同类型的bean会报错，配合qualify可以使用名字注入</p>
<p>2，Resource默认优先使用名字注入，名字不匹配再类型注入</p>
<p>3，Component用于标记类作为spring组件，对象作为bean</p>
<p>4，Bean作用于配置类中的方法，将方法的返回值作为bean放到容器中，适用于手动创建复杂对象</p>
<h2 id="Transactional的参数"><a href="#Transactional的参数" class="headerlink" title="@Transactional的参数"></a>@Transactional的参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">  propagation = Propagation.REQUIRED,  // 事务传播行为</span></span><br><span class="line"><span class="meta">  isolation = Isolation.DEFAULT,        // 隔离级别</span></span><br><span class="line"><span class="meta">  timeout = 30,                        // 超时时间（秒）</span></span><br><span class="line"><span class="meta">  readOnly = false,                    // 是否只读</span></span><br><span class="line"><span class="meta">  rollbackFor = Exception.class        // 触发回滚的异常类型</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<p>1，隔离级别</p>
<ul>
<li>读未提交</li>
<li>读已提交</li>
<li>可重复读</li>
<li>串行</li>
</ul>
<p>2，传播行为：事务方法之间调用时事务如何传播</p>
<ul>
<li><h3 id="MANDATORY-强制，调用方没有则报异常"><a href="#MANDATORY-强制，调用方没有则报异常" class="headerlink" title="MANDATORY:强制，调用方没有则报异常"></a>MANDATORY:强制，调用方没有则报异常</h3></li>
<li><h3 id="REQUIRES-NEW：新事务，被调用方总是创建新事务"><a href="#REQUIRES-NEW：新事务，被调用方总是创建新事务" class="headerlink" title="REQUIRES_NEW：新事务，被调用方总是创建新事务"></a>REQUIRES_NEW：新事务，被调用方总是创建新事务</h3></li>
<li><h3 id="REQUIRED：需要，调用方有，被调用方则使用，无则新建"><a href="#REQUIRED：需要，调用方有，被调用方则使用，无则新建" class="headerlink" title="REQUIRED：需要，调用方有，被调用方则使用，无则新建"></a>REQUIRED：需要，调用方有，被调用方则使用，无则新建</h3></li>
<li><h3 id="SUPPORTS：支持，调用方有则使用，无则不用"><a href="#SUPPORTS：支持，调用方有则使用，无则不用" class="headerlink" title="SUPPORTS：支持，调用方有则使用，无则不用"></a>SUPPORTS：支持，调用方有则使用，无则不用</h3></li>
<li><h3 id="NESTED：嵌套"><a href="#NESTED：嵌套" class="headerlink" title="NESTED：嵌套"></a>NESTED：嵌套</h3></li>
<li><h3 id="NOT-SUPPORTED：不支持，调用方有则挂起"><a href="#NOT-SUPPORTED：不支持，调用方有则挂起" class="headerlink" title="NOT_SUPPORTED：不支持，调用方有则挂起"></a>NOT_SUPPORTED：不支持，调用方有则挂起</h3></li>
<li><h3 id="NEVER：不支持，调用方有则异常"><a href="#NEVER：不支持，调用方有则异常" class="headerlink" title="NEVER：不支持，调用方有则异常"></a>NEVER：不支持，调用方有则异常</h3></li>
</ul>
<p>3，触发回滚的异常类型</p>
<p>4，是否只读</p>
<h2 id="spring的单例bean是否会出现线程安全问题"><a href="#spring的单例bean是否会出现线程安全问题" class="headerlink" title="spring的单例bean是否会出现线程安全问题"></a>spring的单例bean是否会出现线程安全问题</h2><p>1，主要是看bean是否有状态，也就是bean的成员变量是否可能被修改，如果可以被修改就会出现线程安全问题</p>
<p>2，如果有是状态的bean，那么可以使用prototype修饰，或者将用来修改的值不要放在成员变量里，可以放在ThreadLocal中</p>
<h2 id="三级缓存解决循环依赖"><a href="#三级缓存解决循环依赖" class="headerlink" title="三级缓存解决循环依赖"></a>三级缓存解决循环依赖</h2><p>1，三个缓存：</p>
<ul>
<li>一级缓存存在的是初始化完成的对象</li>
<li>二级缓存存的是早期实例，早期由三级缓存控制有需要时才会暴露</li>
<li>三级缓存存的ObjectFactory，由bean实例化时放入，控制暴露早期实例，提前进行AOP</li>
</ul>
<p>2，bean寻找过程：</p>
<ul>
<li>先在一级缓存找</li>
<li>再在二级缓存找</li>
<li>三级缓存找，找到则暴露早期实例并存入二级缓存</li>
<li>三级缓存没有证明还未实例化，先实例化</li>
</ul>
<p>3，三级缓存解决循环依赖：</p>
<ul>
<li>暴露bean的早期实例给正在初始化的bean，完成初始化</li>
<li>ObjectFactory动态判断bean是否需要aop，需要的的话先进行aop操作，暴露的就是代理对象的实例的引用</li>
</ul>
<p>4，二级缓存的作用：</p>
<ul>
<li>存储早期实例，当多个bean初始化都依赖此实例时，能保证获取的是同一个实例的引用，保持单例</li>
<li>起一个缓存作用，不用每一次依赖都去执行ObjectFactory获取早期实例的方法</li>
</ul>
<p>5，注意事项：</p>
<ul>
<li>只有单例模式可以解决循环依赖</li>
<li>互相依赖的bean如果都是构造注入的话，spring没有办法解决；可以是字段注入(Autowired,Resource)或者setter注入</li>
<li>最好不要写有循环依赖的代码</li>
</ul>
<h2 id="springmvc的请求流程"><a href="#springmvc的请求流程" class="headerlink" title="springmvc的请求流程"></a>springmvc的请求流程</h2><p>1，请求进入dispatcherServlet</p>
<p>2，分发给handlermapping：负责找合适的controller方法</p>
<p>3，分发给handlerAdopter:</p>
<ul>
<li>负责适配不同方式配置的controller，注解，接口等方式</li>
<li>调用Controller方法</li>
<li>负责处理返回值，以ModelAndView，String(解析为视图)</li>
</ul>
<p>4，handle执行</p>
<p>5，视图解析器modeView</p>
<p>6，dispatcherServlet返回给前端</p>
<h2 id="过滤器拦截器的顺序"><a href="#过滤器拦截器的顺序" class="headerlink" title="过滤器拦截器的顺序"></a>过滤器拦截器的顺序</h2><p>1，大致的顺序：过滤器-&gt;dispatcherservlet-&gt;拦截器</p>
<p>2，详细的顺序</p>
<ul>
<li>过滤器dofilter方法，chain.dofilter()之前的代码</li>
<li>进入dispatcherServlet</li>
<li>进入拦截器prehandle方法</li>
<li>调用controller方法执行</li>
<li>拦截器posthandle方法，可以修改modeandView</li>
<li>视图解析器</li>
<li>拦截器afterhandle方法</li>
<li>过滤器dofilter方法的chain.dofilter()之后的代码</li>
</ul>
<h2 id="和-的区别，-的使用场景"><a href="#和-的区别，-的使用场景" class="headerlink" title="${}和#{}的区别，${}的使用场景"></a>${}和#{}的区别，${}的使用场景</h2><p>1，#{}是预编译占位，会在变量两边自动加上单引号，可以防止sql注入，原理是预编译的会当作一个参数处理而非sql</p>
<p>2，${}是sql拼接，不会在变量两边加单引号，可能会造成sql注入，比如where name &#x3D;’Tom’ or 1&#x3D;1这个条件永远都是true、</p>
<p>3，${}的使用场景</p>
<ul>
<li>语法上不能加引号的：动态获取表名，列名，排序方式</li>
<li>在使用的时候保证${}里面的变量都来自于后端，而不是直接把前端url中的变量取出来用，前端的可能会拼接好的语句作为变量；要保证前端用户不可控</li>
</ul>
<h2 id="Mybatis的分页原理"><a href="#Mybatis的分页原理" class="headerlink" title="Mybatis的分页原理"></a>Mybatis的分页原理</h2><p>1，可以使用RowBounds进行逻辑分页，逻辑分页是把所有的数据查出来在内存里进行分页</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RowBounds</span> <span class="variable">rowBounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowBounds</span>(offset, limit);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectAllUsers(rowBounds);</span><br></pre></td></tr></table></figure>

<p>2，可以使用分页插件进行物理分页，指的是拦截负责sql语句的类，进行sql拼接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">List&lt;User&gt; users = userMapper.getAllUsers();</span><br></pre></td></tr></table></figure>

<p>3，区别及其使用场景</p>
<ul>
<li>逻辑分页使用简单，不需要更改sql语句，适合少量数据</li>
<li>物理分页性能好，不会造成内存溢出，适合大量数据查询</li>
</ul>
<h2 id="实体类属性名和表的字段名不一样"><a href="#实体类属性名和表的字段名不一样" class="headerlink" title="实体类属性名和表的字段名不一样"></a>实体类属性名和表的字段名不一样</h2><p>1，配置mapUnderscoreToCamelCase属性会true来开启自动驼峰和下划线转换</p>
<p>2，在写SQL语句的时候给字段取别名</p>
<p>3，使用resultmap来手动一一对应</p>
<h2 id="Mybatis的一级缓存和二级缓存"><a href="#Mybatis的一级缓存和二级缓存" class="headerlink" title="Mybatis的一级缓存和二级缓存"></a>Mybatis的一级缓存和二级缓存</h2><p>1，一级缓存：默认开启，作用域为同一个sqlSession，在进行增删改或者手动执行sqlsession对象的flush方法时会清除一级缓存</p>
<p>2，二级缓存：</p>
<ul>
<li>需要手动开启：配置中设置cacheEnabled为true，在需要开启的mapper文件中写上&lt; &#x2F;catched &gt;</li>
<li>二级缓存的作用域为namespace，进行增删改操作或者执行sqlsession的clearCache方法时会清除二级缓存</li>
</ul>
<h2 id="Mybatis-Mapper-接口支持重载吗？"><a href="#Mybatis-Mapper-接口支持重载吗？" class="headerlink" title="Mybatis Mapper 接口支持重载吗？"></a>Mybatis Mapper 接口支持重载吗？</h2><p>1，不支持重载，包+类(接口)+方法签名共同来确定一条mapper中的sql，重载会出现一个方法有多条sql待选</p>
<h2 id="springboot自动装配原理"><a href="#springboot自动装配原理" class="headerlink" title="springboot自动装配原理"></a>springboot自动装配原理</h2><p>1，@EnableAutoConfiguration 注解，上使用@Import导入了AutoConfigurationImportSelector类，并且可以使用exclude排除；也可以在@SpringBootApplication上排除</p>
<p>2，AutoConfigurationImportSelector对象的selectImports方法被执行</p>
<p>3，springboot启动时，加载META - INF&#x2F;spring.factories文件，文件中写的是配置类的全限定名</p>
<p>4，配置类上有@Conditional系列注解判断配置类是否生效</p>
<p>5，生效的配置类在它的方法上加@Bean和@Conditional系列注解来控制需要被spring容器创建的bean</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>1，程序计数器</p>
<p>2，虚拟机栈</p>
<p>3，本地方法栈</p>
<p>4，堆</p>
<p>5，方法区</p>
<h2 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h2><p>1，加载</p>
<ul>
<li>通过全限定名获取类的class文件二进制流</li>
<li>将字节流转化成方法区的运行时数据结构</li>
<li>堆中生成Class对象作为该类信息的入口</li>
</ul>
<p>2，链接</p>
<ul>
<li>验证：文件格式，元数据，字节码，符号引用</li>
<li>准备：赋初值，static final赋完整值</li>
<li>解析：符号引用转直接引用</li>
</ul>
<p>3，初始化</p>
<ul>
<li><clinit>方法，执行静态代码块，和成员变量赋值语句</li>
</ul>
<h2 id="初始化契机"><a href="#初始化契机" class="headerlink" title="初始化契机"></a>初始化契机</h2><p>1，类被new</p>
<p>2，子类发生初始化</p>
<p>3，访问静态方法或者非final的静态变量</p>
<p>4，class.forName</p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>1，低层收到加载请求，先委派高层加载器到最高，不在高层扫描范围内则返回给上一层加载</p>
<p>2，类加载器</p>
<ul>
<li>Bootstrap ClassLoader启动类加载器</li>
<li>Extension Class Loader拓展类加载器</li>
<li>System ClassLoader启动类加载器，负责classpath</li>
</ul>
<p>4，破坏双亲委派场景</p>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>1，G1和CMS都使用并发的可达性分析算法</p>
<p>2，并发的可达性分析：</p>
<ul>
<li>三色标记：黑色代表分析完毕可达，灰色代表正在分析，白色代表不可达</li>
</ul>
<p>3，问题：</p>
<ul>
<li>一个白色断开了所有的灰色同时连上了黑色，由于黑色不会再被分析，白色最终还是白色会被误回收</li>
</ul>
<p>4，解决：</p>
<ul>
<li>增量更新法：黑色新连上一个后，黑色转变为灰色，CMS使用</li>
<li>原始快照法：使用白色脱离灰色前的快照</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>1，复制算法：多用于新生代，不会产生碎片，但是需要两倍内存</p>
<p>2，标记清除算法：cms使用，标记内存可以使用，会产生碎片</p>
<p>3，整理算法：老年代使用，不会产生碎片，但是会改变对象地址，需要stw</p>
<p>4，分代收集算法：</p>
<ul>
<li>将堆分为新生代和老年代，新生代分为Eden：s0：s1 &#x3D; 8:1:1，新生代多使用复制算法，老年代收集器多使用标记整理算法</li>
<li>新生代复制算法：新对象优先放入Eden，进行minalGC时，将Eden存活的和某s区存活的，一起复制入另一个s区，其他的清除</li>
</ul>
<h2 id="垃圾回收器G1-CMS"><a href="#垃圾回收器G1-CMS" class="headerlink" title="垃圾回收器G1,CMS"></a>垃圾回收器G1,CMS</h2><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>1，流程：</p>
<ul>
<li>初始标记，并发标记，最终标记(stw使用原始快照)，筛选回收(选择最有价值的回收)</li>
</ul>
<p>2，优点：</p>
<ul>
<li>可以自己设置预期的回收时间</li>
<li>不会产生内存碎片</li>
</ul>
<p>3，缺点：</p>
<ul>
<li>需要额外的数据结构来管理region</li>
</ul>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>1，流程：</p>
<ul>
<li>初始标记，并发标记，重新标记，并发清除</li>
</ul>
<p>2，优点：</p>
<ul>
<li>响应快速，垃圾回收时间很短</li>
</ul>
<p>3，缺点：</p>
<ul>
<li>会产生大量的内存碎片</li>
<li>作为老年代，没有内存可以担保，在并发标记阶段新产生的浮动垃圾可能会沾满空间导致无法继续回收，这次回收可能失败</li>
</ul>
<h1 id="TODO堆分析工具"><a href="#TODO堆分析工具" class="headerlink" title="TODO堆分析工具"></a>TODO堆分析工具</h1><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>1，指定堆内存大小 -Xms设置初始大小，-Xmx设置最大大小，-Xmm设置新生代大小，-Xss设置线程栈大小</p>
<p>2，设置使用G1垃圾回收器-XX:+UseG1GC，-XX:MaxGCPauseMillis可以设置g1垃圾收集最大的停顿时间，-XX:G1HeapRegionSize设置region大小</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h2><p>1，char的长度固定，指定0-255个字符</p>
<p>2，varchar的长度可变，可以指定0-65535个字节，字符数受编码最大长度影响，还受页的大小影响，因为要保证每一页至少要存储两条记录，所以实际不一定能够分到65535个字节</p>
<p>3，这两个括号里面的数字表示的都是字符数量，varchar只有使用ASCII编码时才有机会在里面填65535</p>
<h2 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h2><p>1，对条件列使用函数或者计算：索引是按照条件列排序的，破坏条件列就无法使用索引</p>
<p>2，联合索引，排序，分组中，没有使用最左原则</p>
<p>3，发生了隐式类型转换：如果变量是数字类型，字段是字符串类型，那么mysql要先把字段转成数字才可以和变量比较，等同于对字段使用了函数</p>
<p>4，like的最左有通配符</p>
<p>5，非等值的范围查询，后面的列无法使用索引</p>
<h2 id="索引结构B-树"><a href="#索引结构B-树" class="headerlink" title="索引结构B+树"></a>索引结构B+树</h2><p>1，叶子结点存放所有数据组合成单链表，通过页目录，把记录分组，每组组成一个槽，用二分法来达成快速查找</p>
<p>2，非叶子结点只存放记录项，每一项对应一页，由指向的页的最小记录的字段值和页号等组成，该页也有页目录，同样可以快速查找</p>
<p>3，索引必须按索引列排序的</p>
<h2 id="B树，hash，B-树结构的优劣"><a href="#B树，hash，B-树结构的优劣" class="headerlink" title="B树，hash，B+树结构的优劣"></a>B树，hash，B+树结构的优劣</h2><p>1，B树：</p>
<ul>
<li>由于非叶子节点也存数据，导致树高比b+树高，每次查询都需要多io</li>
<li>范围查询需要跨越层级</li>
</ul>
<p>2，Hash表：</p>
<ul>
<li>查找迅速，O(1)级别</li>
<li>但是不能范围查询</li>
<li>不能排序</li>
<li>不好删除</li>
</ul>
<p>3，B+树：</p>
<ul>
<li>树高低</li>
<li>叶子结点单链表，适合范围查询和全表扫描</li>
<li>可以排序，可以分组</li>
</ul>
<h2 id="索引适用的场景"><a href="#索引适用的场景" class="headerlink" title="索引适用的场景"></a>索引适用的场景</h2><p>1，高频率查询列</p>
<ul>
<li>记录数量多</li>
<li>高基数列，区分度高</li>
<li>更新不频繁</li>
<li>非大列</li>
</ul>
<p>2，排序列</p>
<p>3，分组列</p>
<p>4，被连接表的连接列</p>
<h2 id="索引相关术语定义"><a href="#索引相关术语定义" class="headerlink" title="索引相关术语定义"></a>索引相关术语定义</h2><p>1，回表：通过二级索引查询时，二级索引没有包含的列需要再去聚簇索引里查</p>
<p>2，覆盖索引：级联索引已经包括了所有需要的列，这时候不需要回表</p>
<p>3，索引下推：索引中包含了where的条件字段，会直接在存储引擎级别判断，而不用再次回表去查询条件字段，再进行判断</p>
<p>4，最左匹配原则：联合索引的使用应该满足从左到右的原则，否则右侧无法使用索引</p>
<h2 id="事务的四大特性以及实现方式"><a href="#事务的四大特性以及实现方式" class="headerlink" title="事务的四大特性以及实现方式"></a>事务的四大特性以及实现方式</h2><p>1，原子性：undo日志，出错回滚</p>
<p>2，隔离性：事务之间相互隔离，使用锁和MVCC实现不同的隔离级别</p>
<p>3，一致性：使用约束，隔离级别等手段保证数据符合预期</p>
<p>4，持久性：redo日志，宕机重新执行</p>
<h2 id="事务隔离级别以及会产生的问题以及解决"><a href="#事务隔离级别以及会产生的问题以及解决" class="headerlink" title="事务隔离级别以及会产生的问题以及解决"></a>事务隔离级别以及会产生的问题以及解决</h2><p>1，读未提交：可能脏读</p>
<ul>
<li>解决：mvcc,事务内每次查询都生成readview</li>
</ul>
<p>2，读已提交：可能不可重复读</p>
<ul>
<li>解决：mvcc，每次事务内第一次查询生成readview</li>
</ul>
<p>3，可重复读：可能幻影读</p>
<ul>
<li>解决：mvcc已经解决了大部分情况下的幻影读，要想全部解决要手动添加互斥锁，select ···· for update</li>
</ul>
<p>4，序列化</p>
<h2 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h2><p>1，每条记录都有roll_ptr和trx_id两个隐藏列，roll_ptr连接着各个版本，trx_id记录最后修改这条记录的事务id</p>
<p>2，查询的时候生成read view，包含</p>
<ul>
<li>当前事务id</li>
<li>事务开启时存活的事务ids</li>
<li>存活的最小事务id</li>
<li>下一个事务将被分配的id</li>
</ul>
<p>3，从每条记录的最新版本开始，沿着版本链判断该版本是否可见</p>
<ul>
<li>判断记录trx_id是否是当前事务id，是的话可见</li>
<li>是否&lt;存活的最小事务id,是的话证明该版本记录的事务已提交，可见</li>
<li>是否&gt;下一个事务将被分配的id，是的话表示是当前事务后开启的事务，不可见</li>
<li>事务id在最小-最大之间，判断是否在事务开启时存活的事务ids内，否的话证明当前事务开启前已提交，可见</li>
</ul>
<p>4，msyql默认读已提交和可重复读两个隔离级别都是使用MVCC，区别在于</p>
<ul>
<li>读已提交时，事务内每次查询都生成readview，因此，事务内别的事务提交的，下次查询就可以读取到</li>
<li>可重复读时，只在事务第一次查询时生成readview，事务内提交的事务，感知不到</li>
</ul>
<h2 id="Innodb的锁"><a href="#Innodb的锁" class="headerlink" title="Innodb的锁"></a>Innodb的锁</h2><p>1，表级锁</p>
<ul>
<li>表x，表级别排他所，需要表中任何记录都不存在s或x锁才能加，加上后阻塞表x，s，行x，s</li>
<li>表s，标记共享锁，表中不能有行x，该锁和行s兼容</li>
<li>ix锁，对行标记x时，会对表标记意向锁ix，标记表中有记录被加了x锁</li>
<li>is锁，同ix</li>
<li>表x锁，对ix，is，x，s全部不兼容</li>
<li>表s，对is，行s兼容</li>
<li>注意ix，is事务提交才释放，即使行锁全释放，也会继续存在，这时还是会有阻塞表x的功效</li>
<li>使用lock tables加表锁会隐式提交当前会话中所有未提交的事务</li>
</ul>
<p>2，行级锁</p>
<ul>
<li>s，共享锁，和x，s兼容：有s后可以获取x或s</li>
<li>x，排他锁，不兼容：有x后无法获取x或s：主要的目的就是让读读不阻塞，读写阻塞</li>
<li>gap间隙锁：阻塞当前记录和前一个空隙，防止插入，幻影读，被阻塞的事务会生成锁对象等待，锁释放时同时获取到可以插入</li>
<li>next—key临键锁：x锁和gap锁的合体</li>
<li>隐式锁：在ru(读未提交)级别，其他事务会读到暂未提交的事务，新插入的记录并不会有锁结构(设计，加效率)，这时其他事务因为没有锁结构阻塞，可以直接获取到锁来修改记录导致脏写，使用隐式锁避免</li>
<li>事务修改前判断插入记录的trx_id，判断是否存活，存活则代表未提交，会帮助生成锁机构并阻塞自己</li>
<li>对于二级索引，没有trx_id字段，优先判断页上记录的最后修改页的trx_id，如果小于当前id那这个页所有事务都已提交，否则就先去回表然后判断trx_id</li>
</ul>
<p>3，rr级别产生幻影的场景：事务中快照读和当前读混用</p>
<ul>
<li>在A事务中先用快照读，B此时未提交，读不到</li>
<li>B提交后，再在A事务快照读，也是读不到的，但是此时使用当前读就可以读到，产生幻影</li>
</ul>
<p>4，在RR级别下，进行锁定的非唯一等值查询，唯一索引范围查询时，会给记录加上临界锁next_key，其中就包含了gap锁</p>
<p>5，语句</p>
<ul>
<li>select * from t_xxx lock in share mode；为查询到的记录加行s锁</li>
<li>select * from t_xxx for update；为查询的记录加行s</li>
<li>lock tables t_xxx write&#x2F;read；加表s&#x2F;x</li>
<li>unlock tables；释放所有表锁</li>
</ul>
<h2 id="慢SQL优化"><a href="#慢SQL优化" class="headerlink" title="慢SQL优化"></a>慢SQL优化</h2><p>1，开启慢查询日志</p>
<p>2，使用explain获取执行计划</p>
<p>3，分析关键字段</p>
<ul>
<li>type：单表的访问方法<ul>
<li>const：唯一索引等值查询</li>
<li>ref：非唯一索引等值查询</li>
<li>range：范围查询，&lt;、&gt;、in、 between</li>
<li>index：索引全扫描，不需要回表的扫描</li>
<li>all：全表扫描</li>
</ul>
</li>
<li>key：使用的索引</li>
<li>Rows：扫描的总记录数</li>
<li>extra：Using temporary（分组未使用索引）, Using filesort(排序未使用索引)</li>
</ul>
<p>4，优化sql</p>
<ul>
<li><p>优先使用const和ref</p>
</li>
<li><p>范围查询or导致的，可以改成union</p>
</li>
<li><p>limit(10000,10)改成where xx &gt;10000 limit 10</p>
</li>
<li><p>检查隐式类型转换</p>
</li>
<li><p>为order by和group by加上联合索引</p>
</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>1，错误日志,默认开启<br>mysql服务器msqld的启动，运行，停止期间产生的严重错误都会记录在里面<br>文件的位置记录在log_error变量里面，默认的日志名是mysqld.log,</p>
<p>2，binlog，默认开启<br>二进制日志，记录dml和ddl语句，不包含查询相关的语句，用于主从复制，数据恢复<br>有三种格式，row记录的是每一行的改变，statement记录的是sql语句，mixed混合记录(默认使用statement，特殊时会转row)</p>
<p>3，查询日志，默认不开启<br>记录所有操作语句， 包括dml，ddl，dql，包含查询,</p>
<p>4，慢查询日志，默认不开启<br>记录执行时间超过指定时间的sql语句<br>slow_querry_log&#x3D;1参数为1代表开启慢查询<br>long_query_time&#x3D;2，记录执行时间超过两秒的日志，默认10秒</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>1，指的是主库把dml，ddl语句复制给从库，主库可以同时给多个从库复制，从库可以作为其他库的主库，形成链状复制<br>2，好处<br>    主库宕机可以快速切换从库使用<br>    实现读写分离，降低主库的压力<br>    可以使用从库备份，防止因为主库备份导致服务无法进行增删改操作<br>3，原理(流程)<br>    主库的dml和ddl语句都会存在binlog中<br>    从库使用iothread线程读取主库的binlog日志至自己的relaylog中<br>    使用sqlthread读取relaylog执行，完成数据同步<br>4，配置<br>    在主库conf文件中，设置server_id服务id，在集群中唯一；设置readonly(0代表读写，1代表只读)<br>    在从库conf文件中，同样设置id和是否只读<br>    在从库中指定主库的ip，端口，用户，密码，binlog位置，binlog文件名字，binlog需要复制的起始位置  change replication source to···<br>    start replica开启同步<br>    show replica status查看主从同步状态：查看io running：yes代表从库从主库binlog复制的线程正常，sql running：yes代表从relay日志中读取并执行的那条线程正常</p>
<p>5，注意<br>    主从复制是从主从关系开始的时刻开始，对应binlog中的一个position，从库需要主库之前的数据，可以先把主库的数据导出成一个sql文件在从库执行，然后再开始主从复制</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="1-好处"><a href="#1-好处" class="headerlink" title="1,好处"></a>1,好处</h3><p>​	将单一服务器的数据分散到多个服务器,防止由于大量请求导致的内存紧张导致的bufferpool不足从而导致每次查询都需要直接从磁盘上读	防止大量请求进行排序分组等耗尽服务器的cpu资源</p>
<h3 id="2，方式"><a href="#2，方式" class="headerlink" title="2，方式"></a>2，方式</h3><h4 id="垂直分库："><a href="#垂直分库：" class="headerlink" title="垂直分库："></a>垂直分库：</h4><ul>
<li>将不同的业务的表放到不同的库里</li>
<li>将数据库以表为依据，通过业务区分，分配给不同的库</li>
<li>比如用户相关给一个，订单相关给一个，所有库的并集是全量数据，每个库中表结构不一样</li>
</ul>
<h4 id="垂直分表："><a href="#垂直分表：" class="headerlink" title="垂直分表："></a>垂直分表：</h4><ul>
<li>以字段为依据，可以把访问量高的字段放在一张表，访问量低的放在一张，可以显著降低访问量低的字段被查询次数</li>
<li>将表以字段为依据，拆分为若干表，放在不同的服务器，表之间使用外键或主键来联系。表结构各不相同，并集是全量；库中表结构不一样</li>
</ul>
<h4 id="水平分库："><a href="#水平分库：" class="headerlink" title="水平分库："></a>水平分库：</h4><ul>
<li>将库以字段为依据，复制表结构到其他服务器，数据分开放在各服务器的表中，各服务器的表数据并集就是全量；表结构一样</li>
</ul>
<h4 id="水平分表："><a href="#水平分表：" class="headerlink" title="水平分表："></a>水平分表：</h4><ul>
<li>将表以字段为依据，复制表结构到其他服务器，各表的数据并集是全量；表结构一样</li>
</ul>
<h3 id="3，使用mycat进行分库分表"><a href="#3，使用mycat进行分库分表" class="headerlink" title="3，使用mycat进行分库分表"></a>3，使用mycat进行分库分表</h3><p>配置：配置逻辑库，逻辑表，逻辑表要分往的真实数据库，配置真实数据库的数据源<br>server.xml指定用户权限，能够访问的逻辑表，是否只读等</p>
<h3 id="4分片"><a href="#4分片" class="headerlink" title="4分片"></a>4分片</h3><p>4，分片规则<br>范围，定义0-500w:0,500w-1500w:1，定义指定字段为0-500w的字段存储在节点0中，500w-1500w之间的存在节点1中<br>取模，将指定字段与节点数量进行取模操作，结果为是几就存到几号节点<br>一致性hash，根据指定字段的hash值来分布到库，一致性 代表扩容不会影响已经确定的数据所在的位置<br>枚举分片，定义枚举值对应节点，例如春：0，夏：1 ，代表字段值为春就放入0号节点，需要指定没有落到任何枚举值时需要落在哪个节点<br>应用指定，截取指定字段的子串，作为节点的编号，需要配置截取的起始索引，截取长度，分片数量，子串没有落到节点或不是有效数字时默认落在哪个节点<br>固定hash算法，将指定字段的2进制值，&amp;上1111111111(10位)，其实就是取模；结果存放到节点中，需要配置每个节点的范围例如；2,1–256,512；代表前两个节点每个负责0-256，256-521，第三个节点负责512-1023，因为只有10位1，最大只能指代1024个位置(包含0)<br>字符串hash解析，将字符截取子串进行hash操作，得到的值再进行固定hash算法<br>按天分片：指定开始时间和结束时间，指定某分片的日子数，例如指定，1号到30号，每10天一片，也就是每10天放一个节点；配置的节点数*某片日子数&#x3D;指定的日期差，必须满足，否则报错；时间超过，从0号节点继续插入，10天后继续1号插入，循环<br>自然月分片：配置的月份数(结束月-开始月)必须和配置的节点数一样，否则报错，可以循环使用</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="1，死锁场景举例"><a href="#1，死锁场景举例" class="headerlink" title="1，死锁场景举例"></a>1，死锁场景举例</h3><ul>
<li>A事务获取a记录的锁，B事务获取b记录的锁</li>
<li>同时，A事务还想获取b记录的锁，B也想获取a记录的锁</li>
<li>AB事务同时卡住无法继续执行</li>
</ul>
<h3 id="2，形成死锁的条件"><a href="#2，形成死锁的条件" class="headerlink" title="2，形成死锁的条件"></a>2，形成死锁的条件</h3><ul>
<li>互斥：锁只能被一个线程占有</li>
<li>请求和保持：请求资源时保持已有资源</li>
<li>不可剥夺</li>
<li>循环等待：形成等待链</li>
</ul>
<h3 id="3，mysql死锁的成因"><a href="#3，mysql死锁的成因" class="headerlink" title="3，mysql死锁的成因"></a>3，mysql死锁的成因</h3><ul>
<li>交叉获取：两个事务获取资源顺序交叉，事务A先获取锁1，再获取锁2,；事务B先获取锁2，再获取锁1，就有可能死锁</li>
<li>间隙锁：两个事务获取了两个范围的间隙锁，同时想往对方的间隙插入，插入要等待对方间隙锁释放才能成功，对方间隙锁要插入自身间隙才能释放，形成死锁</li>
</ul>
<h3 id="3，查看死锁内容"><a href="#3，查看死锁内容" class="headerlink" title="3，查看死锁内容"></a>3，查看死锁内容</h3><ul>
<li>show engine innodb status 可以直接看到最近的死锁</li>
<li>设置 innodb_status_output 和 innodb_status_output_locks参数为 ON，在error日志中查deadlock就可以看到</li>
<li>SELECT * FROM performance_schema.data_locks WHERE lock_status &#x3D; ‘LOCK WAIT’</li>
</ul>
<h3 id="4，避免死锁"><a href="#4，避免死锁" class="headerlink" title="4，避免死锁"></a>4，避免死锁</h3><ul>
<li>服务端指定资源获取顺序</li>
<li>加索引，不加索引的锁定查询会锁住所有记录</li>
<li>使用读已提交可以解决间隙锁带来的死锁</li>
</ul>
<h3 id="5，解决方法"><a href="#5，解决方法" class="headerlink" title="5，解决方法"></a>5，解决方法</h3><ul>
<li>出现死锁mysql会自动回滚一个事务并返回1213错误码，在代码中补货SQLException异常后，判断码是否是1213，是的话可以进行适当重试</li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据结构详解"><a href="#数据结构详解" class="headerlink" title="数据结构详解"></a>数据结构详解</h2><p>1，string，全局id</p>
<p>2，hash，对象</p>
<p>3，set，求交集，共同好友</p>
<p>4，zset，做排行榜</p>
<p>5，list，先进先出，做队列</p>
<p>6，位图Bitmaps，签到，统计在线</p>
<p>7，HyperLogLog：UV统计</p>
<p>8，GEO：地理位置</p>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><p>1，穿透：redis没有，MySQL也没有，导致无法建立缓存，攻击全部打数据库</p>
<p>解决：</p>
<ul>
<li><p>使用布隆过滤器过滤，误判的再设null缓存</p>
</li>
<li><p>redis和mysql都没有的时候，手动在redis创建一个空缓存，设置较短ttl，防止mysql在空缓存存在期间添加了后导致的不一致时间过长</p>
</li>
</ul>
<p>2，击穿：热点key过期时，大量的请求打到数据库</p>
<p>解决：热点key不设置ttl，在java代码中设置逻辑过期时间，当过期后，先返回给旧值，同时创建一个线程去重建缓存</p>
<p>3，雪崩：大量的key同时过期</p>
<p>解决：同一时间上传的key应当设置不同时间的ttl，可以设置基准时间+随机时间</p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>1，惰性删除：过期key被再次访问的时候，检查是否过期，过期则删除</p>
<p>2，定期删除：在设置了ttl的key中定期挑一批检查是否过期，默认10s一次选20个key</p>
<p>3，内存淘汰策略</p>
<ul>
<li>allkeys-lfu</li>
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>noevication：默认，拒绝新请求，不删除之前的</li>
<li>volatile-lfu：频率最低</li>
<li>volatile-lru：最长时间没访问</li>
<li>volatile-random：随机</li>
<li>volatile-ttl：ttl剩余时间最少的</li>
</ul>
<p>4，过期策略由这三种机制配合完成</p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><h2 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h2><p>1，内存存储</p>
<p>2，单线程避免了上下文切换的开销</p>
<p>3，linux下使用epoll IO多路复用</p>
<p>4，epoll对比select和poll的优势</p>
<ul>
<li>使用事件驱动代替轮循，减少了cpu开销</li>
<li>使用红黑树存放需要监听的md，在内核态持久化存储，避免了频繁的在两态之间拷贝fd列表，新添md是O(logn)</li>
<li>只有就绪的fd会传到就绪列表返回用户态，因此无需遍历列表找就绪的fd</li>
<li>总结：作为单线程应用，io多路复用帮助了redis最大程度避免受网络io阻塞的影响</li>
</ul>
<h2 id="redis和mysql的缓存一致性"><a href="#redis和mysql的缓存一致性" class="headerlink" title="redis和mysql的缓存一致性"></a>redis和mysql的缓存一致性</h2><p>1，catch-aside+延时双删</p>
<ul>
<li>读操作逻辑，先去查缓存，没查到去查mysql并重建缓存</li>
<li>写操作逻辑，先更新数据库，再删除缓存</li>
<li>在catch-aside的基础上，延时双删，删除缓存之后隔一段时间(覆盖主从同步时间)再删除缓存</li>
<li>在主从的情况下，主数据库更新后，缓存删除，从数据库未同步还是旧值，这时读线程读从库重建了缓存，导致缓存和数据库长期的不一致</li>
<li>需要保证第二次删除缓存一定会执行，可以使用mq异步任务删除</li>
</ul>
<p>2，使用canal监听binlog的变动，解析事件，利用消息队列异步发送，redis消费者监听队列</p>
<ul>
<li>强一致性，用于秒杀的库存，订单等管理</li>
<li>无代码侵入，维护复杂</li>
</ul>
<h2 id="配置文件的配置项"><a href="#配置文件的配置项" class="headerlink" title="配置文件的配置项"></a>配置文件的配置项</h2><p>1，网络连接相关</p>
<ul>
<li>bind ip，指定可以连接的客户端ip</li>
<li>port 6379，服务器端口</li>
<li>protected-mode yes，安全模式，开启会禁止无密码的远程访问</li>
<li>timeout 300(s)，客户端空闲持续时间</li>
<li>requirepass zxr12345，设置访问密码</li>
</ul>
<p>2，内存淘汰</p>
<ul>
<li>maxmemory (bytes),最大内存</li>
<li>maxmemory-policy noeviction，内存淘汰策略</li>
</ul>
<p>3，持久化相关</p>
<ul>
<li>save a b：a秒内最少b次修改会触发rdb</li>
<li>appendonly yes：启用 AOF</li>
<li>appendfilename “appendonly.aof”  ：AOF 文件名</li>
<li>appendfsync everysec&#x2F;always&#x2F;no ：刷盘策略：每秒&#x2F;每次修改&#x2F;由操作系统决定</li>
<li>auto-aof-rewrite-percentage 100  ： AOF 文件增长100%触发重写</li>
<li>auto-aof-rewrite-min-size 64mb ：AOF 文件最小重写大小</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>1，加锁</p>
<ul>
<li>使用setnx，无法稳定预判过期时间，过期可能导致锁误删出现线程安全问题，虽然可以通过判断线程id解决误删，但是过期的锁会消失</li>
<li>redission，锁的结构是hash结构，大key是锁名称，小key是线程id，value是重入次数，通过lua脚本先判断小key是否存在，是否相同，判断能否加锁和可重入，lua脚本保证判断和加锁两步是原子的</li>
</ul>
<p>2，解锁</p>
<ul>
<li>删除setnx的key可能会误删</li>
<li>redission使用lua脚本，判断value是否为0，是就删除，不是就减1</li>
</ul>
<p>3，可重入性</p>
<ul>
<li>setnx无可重入性</li>
<li>redission使用value来记录可重入次数</li>
</ul>
<p>4，看门狗机制</p>
<ul>
<li>存储所有加了锁的uuid+线程id</li>
<li>定时任务每10秒通过这些id去redis查看锁还存不存在(锁是否释放了)</li>
<li>存在(没释放)就加长时间</li>
<li>jvm宕机后定时任务结束，因为没有java代码发lua让redis服务器执行了，30s自动过期</li>
<li>只有没设置ttl的时候才会自动启动看门狗机制，过期时间30s</li>
</ul>
<h2 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h2><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="1，nacos，注册中心，配置中心"><a href="#1，nacos，注册中心，配置中心" class="headerlink" title="1，nacos，注册中心，配置中心"></a>1，nacos，注册中心，配置中心</h2><h2 id="2，openfeign，远程调用"><a href="#2，openfeign，远程调用" class="headerlink" title="2，openfeign，远程调用"></a>2，openfeign，远程调用</h2><h2 id="3，gateway，网关"><a href="#3，gateway，网关" class="headerlink" title="3，gateway，网关"></a>3，gateway，网关</h2><h2 id="4，Sentinel，流量监控"><a href="#4，Sentinel，流量监控" class="headerlink" title="4，Sentinel，流量监控"></a>4，Sentinel，流量监控</h2><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="多个消费者消费同一个队列时，如何多劳多得？"><a href="#多个消费者消费同一个队列时，如何多劳多得？" class="headerlink" title="多个消费者消费同一个队列时，如何多劳多得？"></a>多个消费者消费同一个队列时，如何多劳多得？</h2><p>1，默认是轮循策略，每个消费者都会分配到相同数量的任务</p>
<p>2，更改prefetch:1 保证每次执行完只能获取一个，就可以让处理的快的多获取任务</p>
<h2 id="rabbitMQ的交换机类型？"><a href="#rabbitMQ的交换机类型？" class="headerlink" title="rabbitMQ的交换机类型？"></a>rabbitMQ的交换机类型？</h2><p>1，fanout</p>
<ul>
<li>广播，分发给所有绑定改交换机的队列</li>
<li>队列绑定交换机时使用””为key绑定</li>
</ul>
<p>2，direct</p>
<ul>
<li>订阅，交换机通过队列绑定的key，消息的key和绑定key相同就分发给该队列</li>
<li>绑定时需要指定key，生产者发送也要指定key</li>
</ul>
<p>3，topic</p>
<ul>
<li>通配符订阅，key可以使用通配符判断</li>
<li>#代表一层或多层，*代表一层；key层级之间使用.分隔：张三.18.男</li>
</ul>
<p>4，headers</p>
<ul>
<li>通过消息头的信息分发</li>
</ul>
<h2 id="怎么修改消息转换器？"><a href="#怎么修改消息转换器？" class="headerlink" title="怎么修改消息转换器？"></a>怎么修改消息转换器？</h2><p>1，默认jdk序列化的坏处：</p>
<ul>
<li>只能用于java</li>
<li>存储额外信息，内存大</li>
<li>字节流中间状态不可读</li>
</ul>
<p>2，使用JSON传输</p>
<ul>
<li>配置类中定义MessageConverter 类型的bean，返回值是Jackson2JsonMessageConverter类型，即可覆盖springboot默认的jdk序列化</li>
<li>可以在生产者序列化给broker(发送消息)时，在消息属性中设置message_id，可以用于幂等性判断：setCreateMessageIds(true)，</li>
</ul>
<h2 id="怎么保证消息可靠性？"><a href="#怎么保证消息可靠性？" class="headerlink" title="怎么保证消息可靠性？"></a>怎么保证消息可靠性？</h2><p>1，生产者可靠性</p>
<p>生产者重试机制：服务端连接失败重试，阻塞式重试，不建议用</p>
<p>生产者确认机制：</p>
<ul>
<li>Publisher Return：交换机无法路由到队列，返回异常信息</li>
<li>Publisher Confirm：nack需要设置重试，重试失败记录异常<ul>
<li>进入交换机，无法路由到任意队列，丢弃消息(未开启return时)返回ack</li>
<li>进入交换机，进入非持久化队列，直接返回ack</li>
<li>进入交换机，进入持久化队列，持久化成功ack，失败nack</li>
</ul>
</li>
</ul>
<p>2，消息可靠性</p>
<ul>
<li>交换机，消息，队列开启持久化</li>
<li>开启lazyqueue惰性队列，消息进入队列直接入磁盘，消费时从磁盘取<ul>
<li>仅仅使用内存，多了的话会统一刷盘，阻塞队列进程</li>
</ul>
</li>
</ul>
<p>3，消费者可靠性：回执，重试：</p>
<p>自动+3次重试+重试后重投递</p>
<ul>
<li>SpringAMPQ开启自动回执模式<ul>
<li>none：不处理，消费者一拿到，队列直接删除</li>
<li>manual：手动，自己调用api，觉定在什么时候返回ack，nack(重投递)，reject(拒绝，不重新投递给队列)</li>
<li>auto：自动，正常ack，业务异常自动返回nack，消息处理或校验异常自动返回reject</li>
</ul>
</li>
<li>nack的情况下设置重试次数，auto模式生效</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重试次数用完，失败处理策略<ul>
<li>RejectAndDontRequeueRecoverer： 重试耗尽后，直接 reject，丢弃消息。默认就是这种方式。</li>
<li>ImmediateRequeueMessageRecoverer： 重试耗尽后，返回nack，消息重新入队。</li>
<li>RepublishMessageRecoverer： 重试耗尽后，将失败消息投递到指定的交换机。</li>
</ul>
</li>
</ul>
<p>手动编码返回回执+手动编码重试+手动发布到队列&#x2F;进入自定义错误队列人工处理或告警</p>
<h2 id="怎么保证不重复消费？"><a href="#怎么保证不重复消费？" class="headerlink" title="怎么保证不重复消费？"></a>怎么保证不重复消费？</h2><p>1，生产者发送的时候生成一个唯一id，uuid，雪花，使用JSON消息转换器生成一个id</p>
<p>2，消息执行之前存redis，使用setnx判断是否已经存储了id，存了代表执行过；也可以使用mysql</p>
<p>3，使用JSON转换器时由于id存在消息头，要先从消息头取，建议用自己生成的id</p>
<p>4，存redis成功，消费失败：出异常在catch中删除此消息id对应的key</p>
<h2 id="怎么保证有序性？"><a href="#怎么保证有序性？" class="headerlink" title="怎么保证有序性？"></a>怎么保证有序性？</h2><p>1，根据业务把任务路由到不同的队列，每个队列只用一个消费者消费，每次只取一个消费</p>
<h2 id="消息积压怎么办？"><a href="#消息积压怎么办？" class="headerlink" title="消息积压怎么办？"></a>消息积压怎么办？</h2><p>1，扩容</p>
<ul>
<li>垂直扩容：增大单个消费者的cpu&#x2F;内存资源加快消费速度</li>
<li>水平扩容：增加队列的消费者实例个数或消费者多线程消费</li>
</ul>
<p>2，批量拉取消息</p>
<h2 id="怎么发延迟消息？"><a href="#怎么发延迟消息？" class="headerlink" title="怎么发延迟消息？"></a>怎么发延迟消息？</h2><p>1，使用插件</p>
<ul>
<li>下载插件rabbitmq-delayed-message-exchange放到插件目录</li>
<li>创建CustomExchange类的bean，构造函数需要传入”x-delayed-message”字符串指定为延迟交换机，还有参数map等</li>
<li>新建HashMap作为参数合集，args.put(“x-delayed-type”, “direct”)，指定底层的路由方式</li>
</ul>
<p>2，使用死信队列</p>
<ul>
<li>给正常消息设置过期时间</li>
<li>给队列绑定死信交换机</li>
<li>当正常队列中的消息过期，会发送到死信交换机，使用队列绑定死信交换机即可消费</li>
</ul>
<h1 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h1><p>1，ls -l(详情) -h(看得懂的形式文件大小) -a(显示隐藏) |grep hello(筛选hello)</p>
<p>2，pwd显示路径</p>
<p>3，ps -ef|grep xxx 查看与xxx相关的进程</p>
<p>4，vim编辑，set nu：在vim中显示行号</p>
<p>5，tail -f xxx|gep erro，实时观察xxx文件并过滤erro关键词</p>
<p>6，lsof -i：8080，查看8080端口占用情况</p>
<p>7，cat 查看文件，touch 新建文件(vi,vim,echo也可以)，mkdir 新建目录，rmdir 删除空目录，rm -r(递归)-f(强制)删除目录和文件</p>
<h1 id="git指令"><a href="#git指令" class="headerlink" title="git指令"></a>git指令</h1><p>1，git init，初始化本地仓库</p>
<p>2，git add，添加文件到暂存区</p>
<p>3，gitcommit，提交暂存区文件至仓库</p>
<p>4，gitclone，根据url克隆仓库</p>
<p>5，git remote add origin(仓库名) 远程仓库url，指定远程仓库</p>
<p>6，git pull拉取远程仓库的内容并merge到本地仓库</p>
<p>7，git push，推送到远程仓库</p>
<p>8，git merge，在主分支内执行，会把各分支的修改合并到主分支</p>
<h1 id="业务描述"><a href="#业务描述" class="headerlink" title="业务描述"></a>业务描述</h1><h2 id="对接第三方接口的流程"><a href="#对接第三方接口的流程" class="headerlink" title="对接第三方接口的流程"></a>对接第三方接口的流程</h2><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>1，获取token接口：</p>
<ul>
<li>参数为渠道(UC),子渠道(UC中的咨询类型，上文下图，视频，纯文字),秘钥(UC给的)</li>
<li>返回值为token</li>
<li>token会过期，定时任务4小时轮循获取新token</li>
<li>过期时访问拉取咨询接口会504，遇见504主动拉取一次token</li>
</ul>
<p>2，拉取咨询接口：</p>
<ul>
<li>渠道，子渠道，频道code(体育，娱乐，游戏)，token</li>
<li>返回值为咨询，带游标标记每个用户的咨询刷新位置，封装成通用模版返回给前端</li>
</ul>
<p>3，个性化咨询接口：每八小时拉取给运营，运营手动推送一两条热门咨询给不同的机型，版本</p>
<p>4，数据回传接口：将用户的曝光，点击行为发送给uc以供个性化推荐</p>
<p>5，频道校验接口：</p>
<ul>
<li>uc的频道有时会下架，我这边没有感知，写了一个5分钟间隔的定时任务轮循频道接口的状态，如果出现错误码就发邮件告警通知运营更换</li>
<li>请求咨询时如果频道下架，也会发邮件告警</li>
</ul>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>1，拉取咨询为什么要分两次请求：减少token被抓取的概率</p>
<p>2，咨询拉取怎么保证不重复：拉取咨询请求除了咨询还会返回游标，标记每个用户单独的刷新位置，并且返回给客户端，客户端的请求带游标</p>
<p>3，咨询是否是相同的：</p>
<ul>
<li>不是，每个用户有单独的id，对应单独的游标，虽然咨询池使用的是同一个，但是由于刷新频率的不同，游标的位置也不同，所以在同一时刻的用户手机上的咨询是不同的</li>
<li>每次下发15条咨询</li>
</ul>
<p>4，为什么要组装成公用模版：</p>
<ul>
<li>不管对接方返回的数据的格式怎么变化，用户那边都是无感知的</li>
<li>就算用户选择不升级app，保证公用模版不变，那用户就可以正常使用</li>
</ul>
<p>5，第三方接口返回的数据：资讯列表，资讯标题，副标题，缩略图，url，作者，发布时间，类型，标签，游标</p>
<p>6，传给第三方的参数：渠道，子渠道，频道code，token，用户唯一id，游标id，发送时间，手机唯一id，手机机型，机型版本</p>
<p>7，使用什么方法拉取的，状态码有哪些：</p>
<ul>
<li>使用okHttpClient发送http请求拉取</li>
<li>第三方状态码：200成功，203重定向；400传参错误，401权限不够，404资源不存在；500服务器错误，503token过期</li>
</ul>
<p>8，第三方接口超时：5000ms持续时间，手动编码重试3次</p>
<h2 id="banner展示"><a href="#banner展示" class="headerlink" title="banner展示"></a>banner展示</h2><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>1，配置固定时间段内展示banner，使用一个list，达到先进后出，每次都去最新放入的那个</p>
<p>2，一般一段时间内只会有一个banner展示，如果时间有重复，则优先使用新配置的banner</p>
<p>3，banner接口的执行契机是美篇app的初始化</p>
<h2 id="引入多线程优化拉取咨询接口"><a href="#引入多线程优化拉取咨询接口" class="headerlink" title="引入多线程优化拉取咨询接口"></a>引入多线程优化拉取咨询接口</h2><p>1，复现</p>
<ul>
<li>拉取热点频道的咨询的接口，响应时间为3-4s，使用postman复现</li>
<li>通过服务治理平台，通过时间，ip，服务名找到postman测试请求，看到了调用链路，拉取广告的时间过长，同步800ms一个，4个3.2秒</li>
</ul>
<p>2，解决：</p>
<ul>
<li>获取广告的接口使用submit执行，获取future，以广告id为key，futrue为value存入HashMap</li>
<li>后续需要使用futrue先获取结果，把广告插入咨询列表组装，然后返回</li>
<li>和产品方面讨论，优先保证响应，广告可以不完全加载；因此选择使用futrue.get(500)，等待500ms，广告没返回就舍弃；如果需要保证广告完整性，可以使用countdownlatch</li>
<li>由于异步执行，广告正常800ms，组装咨询和资源和广告共花1秒，接口总共正常花1秒，从3.2优化到了1</li>
</ul>
<p>3，为什么不能一次拉取多个广告：可能是广告部门方便统计数据</p>
<p>4，线程池参数设置：和三个参数相关，单秒任务量，任务执行时长，最大响应时间；假如单秒0-200，最高峰为1000，执行时长0.1s，时间单位为秒</p>
<ul>
<li>核心数&#x3D;200*0.1&#x3D;20个</li>
<li>队列长：核心线程1秒执行200个，最大响应为2秒，那么可以再放200个在队列</li>
<li>最大线程数：最高峰1000个，减去核心和队列的400，剩600任务，单位为秒，应当使用60个线程；因此，最大&#x3D;核心20加非核心60&#x3D;80个</li>
<li>工厂默认</li>
<li>拒绝策略：按照重要程度，重要的不拒绝</li>
<li>线程存活时间：看间隔周期，周期长则存活时间设短，防止一直耗费资源；周期短则时间设长比如5分钟，避免频繁创建线程</li>
</ul>
<p>4，公司参数：</p>
<ul>
<li>核心10；最大100；队列200；不拒绝使用用户线程执行；过期时间5分钟</li>
<li>两个线程池，一个用定时任务，一个用于接口</li>
</ul>
<p>5，广告有哪些，怎么配置，和资讯冲突咋办</p>
<ul>
<li>知盟，阿里妈妈，uc等平台，硬广，api发布(组装成资讯模版)</li>
<li>运营后台配置，广告位置，广告数量，控制在4个内</li>
<li>和咨询同一模版，直接让后续咨询和广告后移，通过list的add实现</li>
</ul>
<h2 id="引入设计模式优化和第三方对接"><a href="#引入设计模式优化和第三方对接" class="headerlink" title="引入设计模式优化和第三方对接"></a>引入设计模式优化和第三方对接</h2><p>1，之前的接口写死了和百度咨询对接</p>
<p>2，利用模版方法模式和简单工厂模式改进</p>
<p>3，定义一个抽象类，定义三个抽象模版方法，检验参数，拉取资讯，组装模版</p>
<p>4，由于每个平台的参数，拉取方法，拉取结果组装都不一样，所以每个平台都继承这个抽象类，并实现自己的逻辑，实际调用直接用抽象类多态调用就可以</p>
<p>5，将这些实现类加上@Component作为bean，使用applicationContext.getBeansOfType()可以获取这个抽象类的所有实现bean，返回一个map，K是类名小写，V是bean；这个map可以作为一个简单工厂，使用get(K)可以获取到bean，从而调用实现类的模版方法</p>
<p>6，由于前端传入的是数字，需要把数字和渠道实际的渠道参数对应，1代表uc，2代表baidu，3代表xinlang，使用枚举类，枚举中定义get方法，通过code可以返回枚举的渠道参数，逻辑中只要写枚举.get(前端参数)即可，前端参数改变，渠道参数改变，对应的简单工厂的参数改变，即可获取想要的实现类；如果要填加不同的渠道，只需要在枚举中定义code和对应的渠道参数，再加上一个抽象类的实现类即可</p>
<h2 id="优化黑名单匹配方案"><a href="#优化黑名单匹配方案" class="headerlink" title="优化黑名单匹配方案"></a>优化黑名单匹配方案</h2><p>1，背景：</p>
<ul>
<li>网信办下发黑名单，资讯url和黑名单一样禁止跳转</li>
<li>原本黑名单存客户端，用户投诉app内存大</li>
<li>客户端存储的实时性没法保证，必须重启app黑名单才会刷新</li>
</ul>
<p>2，优化：</p>
<ul>
<li>存放到客户端，每次跳转时都匹配黑名单，解决了实时性问题</li>
<li>存放到redis缓存，因为跳转资讯的接口访问量很大，缓存加快查询速度</li>
</ul>
<p>3，实现：</p>
<ul>
<li>使用set集合存储，可能会造成大key问题，拆分key为10个，利用hashcode对key的数量取模，也会有大key，而且重hash麻烦</li>
<li>使用布隆过滤，可能会误判非黑名单网址为黑名单<ul>
<li>在匹配上黑名单后，再去数据库确认(因为只有10w分之1的概率命中，所以不担心数据库压力)</li>
<li>去数据库确认时，如果数据库也没有，大量伪造请求进入会造成缓存穿透，缓存5分钟空值处理</li>
<li>黑名单更新时要先删掉缓存的值，然后再插入数据库和缓存</li>
</ul>
</li>
<li>布隆过滤没有办法删除<ul>
<li>将要删除的url存入redis set，黑名单命中后看是不是已删除</li>
</ul>
</li>
<li>布隆和mysql同步<ul>
<li>定时任务1小时全量同步</li>
</ul>
</li>
<li>6万黑名 单存入redis大概3M，但是存入布隆过滤器就只有2kb左右。</li>
</ul>
<p>4，你们布隆过滤器怎么设置的？</p>
<ul>
<li>初始化的时候两个参数分别1000万元素，误判率是千分之1</li>
</ul>
<p>5，redis和msyql的一致性怎么保证？</p>
<ul>
<li>使用双写，先写数据库，再删缓存，再写缓存</li>
</ul>
<p>6，mysql写入成功，redis写入失败怎么办？</p>
<ul>
<li>使用全量更新，如果写缓存失败，下次查询到达数据库自动重建缓存</li>
</ul>
<p>7，其他的缓存一致性方案？</p>
<ul>
<li>缓存延时双删：先删除缓存，再更新数据库，再进行延时删除；如果在更新数据库的途中，有读请求，会拿取旧数据并重建旧缓存，延时双删保证数据库更新完成后，删除旧数据</li>
<li>可以使用canal伪装成mysql的slave获取binlog日志，监听变动，通过消息队列异步发送给消费者，消费者在解析需要删除缓存的时候进行删除操作；需要控制消息顺序和幂等性处理</li>
<li>如果面试官还说无法保证，每隔5分钟定时任务进行全量同步</li>
</ul>
<h2 id="对拉取咨询接口的缓存击穿问题-热点key过期-进行处理"><a href="#对拉取咨询接口的缓存击穿问题-热点key过期-进行处理" class="headerlink" title="对拉取咨询接口的缓存击穿问题(热点key过期)进行处理"></a>对拉取咨询接口的缓存击穿问题(热点key过期)进行处理</h2><p>1，token过期的时候，大量的请求收到504，如果出现504，加分布式锁，锁住”toke”+旧token</p>
<p>2，进入锁之后判断自己先从缓存中拿的token和现在缓存中的token是否一样，这是为了查看是否已经有其他线程先进行了token的重新拉取并存放到缓存</p>
<p>3，如果相等，证明还没有线程拉取新token存储，那么去获取新的token，并休眠一秒，因为token的更新是一个回调接口，休眠保证uc那边已经调用完回调接口，如果不放心，可以用while循环，判断新的token是否已缓存，之后再释放锁，再用新的token查询一次，查询必须在锁外面，防止之前被阻塞的线程每个都获取释放一遍锁</p>
<p>4，如果不相等，说明已经有其他的线程完成了token更新，那么直接用新token拉取咨询然后返回即可</p>
<p>5，无需双重检验，因为只有504之后才会进入锁的逻辑，并不是每次请求都会进入504的逻辑</p>
<h2 id="对慢sql进行调优，参与客户操作记录分库分表"><a href="#对慢sql进行调优，参与客户操作记录分库分表" class="headerlink" title="对慢sql进行调优，参与客户操作记录分库分表"></a>对慢sql进行调优，参与客户操作记录分库分表</h2><p>1，场景：</p>
<h2 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>发布时指定一部分的用户，测试完之后再全量发布</li>
<li>有些广告，不适配老版本，不能再老版本中展示，有反馈广告位置白屏，对于老机型可以单独配置广告</li>
</ul>
<h3 id="方法一：加字段实现"><a href="#方法一：加字段实现" class="headerlink" title="方法一：加字段实现"></a>方法一：加字段实现</h3><h4 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h4><ul>
<li>在设置频道的时候指定频道可以展示的机型和版本，配置完后存redis，hash结构，K（机型）V(k版本，v能唯一标识一个频道的类)</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>资源很多，有资源，热词，宫格，导航，快应用等，每一个资源都要指定机型和版本，很麻烦</li>
<li>修改资源不再展示给某机型和版本，需要遍历该机型版本的所有资源找到，不好管理</li>
</ul>
<h3 id="方法二：配置运营组"><a href="#方法二：配置运营组" class="headerlink" title="方法二：配置运营组"></a>方法二：配置运营组</h3><p>设置运营组，每个运营组可以配置若干机型，每个机型可以配置若干版本，每个运营组下有若干资源</p>
<p>报表<br>不使用java代码,直接用的第三方大数据框架<br>登录大数据平台，写hive sql，通过自己指定的条件来清洗数据，最后为最后的数据生成统计图，指定横坐标和纵坐标就可以看到统计图</p>
<p>使用中间表可以降低每个sql复杂度</p>
<p>事件，刷新曝光，点击事件，不喜欢，收藏，点赞</p>
<p>服务端事件，收藏，不喜欢，点击，曝光，视频观看</p>
<p>事件上报数据，事件类型，咨询id，标题等；后端组装，发到大数据</p>
<p>曝光这种数量很多的事件，客户端保存，传给给后端处理上报，5分钟上报一次</p>
<p>点赞收藏这些，点击即上报即可</p>
<p>hive sql清洗，执行时间可以配置</p>
<p>机型A所有的咨询都拉去不到<br>1，使用postman模拟，发现百度渠道被拉黑，原因测试实习生跑monkey测试，没有切测试环境，直接跑了30w次拉取，百度的咨询本身有广告，可能有刷广告访问的嫌疑<br>2，每次拉取咨询时，将结果码，和message拼接上报大数据原始表，写个定时任务，使用大数据的SDK从大数据原始表(events)获取数据，查询事件类型为拉取咨询的，count code为200的数量，拉取成功数量小于95%就发告警</p>
<p>拉取时使用token进行身份验证，token会不定时过期；<br>流程是，先取出缓存中的token，再拿取到的token去请求uc接口；<br>请求返回504代表token过期，过期重新重新请求一次token后用户直接返回报错，uc收到请求调用我提供的回调接口将token写入到redis，下一次调用即可获取到咨询咨询；<br>并发高的情况下，token过期，拉取token的接口可能会缓存击穿，外层，拉取时返回504进入catch块，catch块中加reddission锁，锁的粒度为业务+当前从redis中查的旧token，块中请求一次token，死循环中，取一次当前redistoken，判断和旧token是否一样，不一样表示更新完成，锁释放，使用当前token查询一次咨询并返回即可，一定要把查询写在锁外面，防止前面被阻塞的线程每一个都要进入同步块</p>
<p>资源包括，banner，快应用，导航，资源是一张表，通过资源类型区分<br>创建banner资源，包括名称，图片，跳转链接，跳转类型，快应用<br>创建计划，计划中可以下拉框选择资源，用于配置banner的展示时间段</p>
<p>重大新闻咨询会推送，定时任务每四小时调用uc的个性化推荐接口，插入到数据库，部分插入到es，后台配置推送计划，通过es搜索可以选择咨询，并且选择咨询要推送的手机id，机型，版本，城市，点击确定往表中插入推送计划，推送部分取推送计划表中的计划执行，并非我们咨询部门执行</p>
<p>个性化推送，创建推送计划无需设置版本机型这些，直接插入个性化推送表，并且每5分钟调大数据平台sdk上报到大数据平台上，大数据根据咨询分类，标题内容等判断具体推送给什么用户；推送完成的计划改成已推送</p>
<h1 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h1><p>1，使用git add .可以所有本地文件提交到本地暂存区</p>
<p>2，git commit -am””可以提交到本地仓库并注释</p>
<p>3，git push可以提交到远程仓库</p>
<p>4，git pull可以从远程仓库拉取</p>
<p>5，git checkout -b zxr 可以创建并切换到zxr分支</p>
<p>6，git checkout master可以直接切换到master分支</p>
<ul>
<li>写代码之前，先创建自己的分支</li>
<li>完成后提交，测试后没问题才会merge合并到master分支</li>
<li>自己分支功能开发完，并且已经合并到master后，可以考虑从master新建一个分支开发或者是把新的master的内容merge到自己的分支上，都可以获取到最新的master的所有内容</li>
</ul>
<p>7，git merge zxr 把zxr分支代码合并到当前分支</p>
<p>8，每次提交都会生成一个版本，如果已经提交的功能有问题，要回到某个版本：</p>
<ul>
<li>git log命令，显示版本号，修改人，修改时间，提交时的注释</li>
<li>通过查看自己提交的注释找到要回到的版本，拿到版本号</li>
<li>通过git reset –hard 版本号前几位，就可以回到某个版本继续开发</li>
</ul>
<p>9，和github等仓库进行远程连接的方式有两种，主要的目的就是要验证身份，让git可以访问到指定账户</p>
<ul>
<li>直接使用github账户的用户名密码，能证明github账户是自己的，可以被访问</li>
<li>在本地上生成公钥和私钥，把公钥配置到自己的github账户中，git访问时服务端下发随机字符串，客户端用私钥加签，上传，服务端用公钥解签，解完后字符串正确代表git可以访问这个github账户，需要把远程连接方式改成ssh而非密码pat</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> ed25519 <span class="literal">-C</span> <span class="string">&quot;your_email@example.com&quot;</span>  <span class="comment"># 更安全的Ed25519算法</span></span><br></pre></td></tr></table></figure>

<h1 id="SpringcloudAlibaba的使用"><a href="#SpringcloudAlibaba的使用" class="headerlink" title="SpringcloudAlibaba的使用"></a>SpringcloudAlibaba的使用</h1><p>1，nacos，服务注册，配置管理</p>
<ul>
<li>在需要注册成服务的模块的yaml问价中指定nacos的服务器ip和进程端口号</li>
<li>在需要注册的模块的启动类上加@EnableDiscoveryClient注解</li>
<li>服务注册到nacos上，名字和yaml文件中配置的服务名相同，注意名字不要包含下划线，需要分级可以用减号(横杠)</li>
</ul>
<p>2，openFeign，远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个接口，指定要调用的方法所属的服务，服务名和yaml中服务名相同</span></span><br><span class="line"> <span class="meta">@FeignClient(&quot;service-vod&quot;)</span></span><br><span class="line"> <span class="meta">@Component</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VodClient</span> &#123;</span><br><span class="line"><span class="comment">//直接使用springmvc的注解即可，注意路径完整性，除了方法上的@Deletemapping参数，路径还要包含类上的@Requestmapping里的路径</span></span><br><span class="line"> <span class="meta">@DeleteMapping(value = &quot;/eduvod/vod/video/&#123;videoId&#125;&quot;)</span></span><br><span class="line"><span class="comment">// 直接复制目标服务中的方法的签名即可</span></span><br><span class="line"> <span class="keyword">public</span> R <span class="title function_">removeVideo</span><span class="params">(<span class="meta">@PathVariable(&quot;videoId&quot;)</span> String videoId)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>注意在远程调用时，@PathVariable的参数不可以省略，需要和路径大括号里的一样</li>
<li>一般可以把所有的远程调用接口集中到一个interface模块中，这个模块里面的接口代码都可以复用</li>
<li>基本就是通过接口中配置的服务名和方法路径，去目标服务找到实际的接口然后调用</li>
</ul>
<p>3，histrix，熔断器，判断远程调用请求是否需要熔断，否放行给ribbon，是报异常或者返回熔断结果</p>
<ul>
<li>在feign接口所在的yaml中设置feign.histix.enable&#x3D;true开启熔断，默认是false</li>
<li>在feign接口所在的yaml中设置默认的熔断时间，超过此时间没响应的请求会触发熔断<ul>
<li>是否是feign接口模块还是调用方加存疑？？？</li>
</ul>
</li>
<li>调用流程：在被调用方宕机或者调用时间超时会执行熔断方法<ul>
<li>写一个实现类实现feign接口，重写方法，这个方法在远程调用失败时会触发，一般方法内手动响应错误类型回去即可；</li>
<li>在feign接口上的@feignClient注解上，除了指定远程调用服务名(name参数)，还需要知道熔断器的类型(自己创建的实现类的类型，注解参数名为fallback)</li>
</ul>
</li>
</ul>
<p>4，ribbon负载均衡，在没有触发熔断时，根据服务名和负载均衡策略指定集群中的某个机器</p>
<p>5，使用httpclent进行实际的http调用</p>
<p>6，顺序，写feign接口-调用feign接口-是否熔断-负载均衡-http请求</p>
<p>7，gateway网关，作用，请求转发，权限管理，跨域配置;请求直接访问网关的ip和端口，由网关转发给服务</p>
<ul>
<li><p>使用：新建单独模块作为nacos的服务，导入依赖，在yaml中配置网关的规则</p>
<ul>
<li>路由：可以配置若干路由规则，每个规则有自己的id，规则指定客户端发来的请求路径(通配符匹配) 应该 路由转发到哪个服务名，在服务名之前加上lb:&#x2F;&#x2F;可以进行该服务集群的负载均衡</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.gateway.routes[0].id</span></span><br><span class="line"><span class="attr">spring.cloud.gateway.routes[0].uri</span></span><br><span class="line"><span class="attr">spring.cloud.gateway.routes[0].predicates</span></span><br><span class="line"><span class="comment">#[0]代表第一个路由规则，想加规则可以用后面的数字</span></span><br><span class="line"><span class="comment">#id是规则名，随意取</span></span><br><span class="line"><span class="comment">#uri可以指定被拦截路径要转发向哪个服务，lb://server1，转发给server1并对server1的集群做负载均衡</span></span><br><span class="line"><span class="comment">#predicates是断言，是前端的请求路径，Path=...,可以使用通配符匹配若干路径</span></span><br></pre></td></tr></table></figure>

<ul>
<li>断言</li>
<li>过滤器</li>
</ul>
</li>
<li><p>网关的转发依赖nacos的服务注册，注册了才能发现服务才能做负载均衡和转发</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>面试八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>spring原理</title>
    <url>/2025/07/14/spring%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="1，核心接口"><a href="#1，核心接口" class="headerlink" title="1，核心接口"></a>1，核心接口</h1><p>beanFactory：负责getbean</p>
<p>applicationcontext：</p>
<p>1，继承了beanFactory，同时成员变量注入了beanFactory(组合关系)以调用其他beanFactory实现类的方法；</p>
<p>2，继承了四个功能的抽象类</p>
<ul>
<li>国际化：给某个key指定不同国际下对应的词，需要给每个语言写一个文件，把词一一对应，前端传入国家；context.getMassage(xx,xx,contry)</li>
<li>资源管理：获取文件，context.getResources；通过classpath*:METE-INFO&#x2F;spring.factories可以获取jar包中的配置类文件信息</li>
<li>配置信息：context.getEnviroment().getProperty(key)可以直接获取环境变量或者是application.yaml中的某个key的信息</li>
<li>事件驱动：<ul>
<li>context.publishEvent(new Applicationevent(事件源头)),可以直接发送事件</li>
<li>给方法加上@EventListiner注解，并在方法参数中指定事件类型，即可监听到事件</li>
</ul>
</li>
</ul>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>1，实例化：实例化前后可以增强</p>
<p>2，依赖注入：依赖注入时可以增强</p>
<p>3，初始化：初始化前后可以增强</p>
<p>4，销毁：销毁之前可以增强</p>
<ul>
<li>使用模版方法抽象，可以完成在增强时动态的选择增强的内容</li>
<li>例如：</li>
<li>在依赖注入时调用inject()方法增强；<ul>
<li>1，定义抽象接口，包含inject方法</li>
<li>2，不同的实现类有不同的inject方法</li>
<li>3，将需要执行的inject方法的对象放入一个list</li>
<li>4，依赖注入时，遍历增强接口类型的list，调用每一个元素的inject的方法；也就是执行了所有需要增强的方法</li>
</ul>
</li>
</ul>
<h1 id="常见的后置bean处理器"><a href="#常见的后置bean处理器" class="headerlink" title="常见的后置bean处理器"></a>常见的后置bean处理器</h1><p>1，autowired-Bean-PostProcessor：负责解析@Autowired注解和@value注解</p>
<ul>
<li>1，获取所有加上了@Autowired注解的属性或者方法，封装成metadata，里面含有一个集合存储</li>
<li>2，元素的reject方法，把自身(成员变量或者方法)封装成一个dependencyDescriptor</li>
<li>3，通过beanFactory的doresolveDependency方法解析封装好的dd，成员直接拿类型匹配；方法先指定哪一个参数，再根据类型匹配</li>
<li>4，通过反射赋值</li>
</ul>
<p>2，common-Bean-PostProcessor：负责解析@Resource，@PostConstruct(初始化前调用)，@PreDestroy(销毁前)</p>
<p>3，configuration-PropertiesBinding-postProcessor：在对类使用@ConfigurationProperties时，指定prefix&#x3D;”pre”和文件，即可直接以pre.成员变量为key去文件中匹配值，直接注入</p>
<h1 id="常见的工厂后处理器"><a href="#常见的工厂后处理器" class="headerlink" title="常见的工厂后处理器"></a>常见的工厂后处理器</h1><p>1，configurationClass-PostProcessor：用于处理@ComponentScan，@Import，@Bean，@ImporResource</p>
<ul>
<li>注入流程</li>
<li>1，获取@ComponentScan(basePackage&#x3D;)的参数,转换成路径</li>
<li>2，在路径下面获取所有的类，遍历类，通过反射检查类上是否有@Component注解以及衍生注解，有的话创建BeanDefinition</li>
</ul>
<p>2，mapperScannerConfigurer：用于处理@MapperScan，需要指定扫描的包</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>最终汇总</title>
    <url>/2025/03/12/%E6%9C%80%E7%BB%88%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="语言的三大特性"><a href="#语言的三大特性" class="headerlink" title="语言的三大特性"></a>语言的三大特性</h2><p>1，封装：将属性和方法封装到类中，隐藏实现细节，通过公共接口和外界交互；可以防止外界直接修改敏感数据；安全性高</p>
<p>2，继承：子类继承父类的属性和方法；实现代码复用</p>
<p>3，多态：同一个操作作用不同对象，产生不同行为；分为编译时多态(重载)和运行时多态(重写)；提高了拓展度，降低了耦合，提高了灵活性</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>1，重载：只与参数相关，参数数量，返回类型，参数顺序；主要用于同一个类中横向拓展</p>
<p>2，重写：参数要相同，返回类型只能是被重写的同类或子类，修饰符只能大于等于被重写的；用于父类子类纵向拓展</p>
<h2 id="包装类型相对基本类型的好处"><a href="#包装类型相对基本类型的好处" class="headerlink" title="包装类型相对基本类型的好处"></a>包装类型相对基本类型的好处</h2><p>1，可以用与数组，集合，泛型</p>
<p>2，提供了操作数据的一系列方法</p>
<p>3，有null可以代表是否查到，基本类型只有0无法区分结果和没查到</p>
<h2 id="static关键字修饰变量，方法"><a href="#static关键字修饰变量，方法" class="headerlink" title="static关键字修饰变量，方法"></a>static关键字修饰变量，方法</h2><p>1，static只能修饰成员变量，不可以修饰局部变量</p>
<p>2，static方法内在只能用static变量，只能调static方法</p>
<p>3，普通方法可以调static变量和方法</p>
<h2 id="抽象类和接口异同"><a href="#抽象类和接口异同" class="headerlink" title="抽象类和接口异同"></a>抽象类和接口异同</h2><p>1，同：</p>
<ul>
<li>都不能实例化</li>
<li>都可以有抽象方法</li>
</ul>
<p>2，异：</p>
<ul>
<li>抽象类可以有成员变量和常量，接口只能有public的常量</li>
<li>抽象类可以有完整的非抽象方法，接口1.8后才有default方法</li>
<li>抽象类只能单继承，接口可以实现多个</li>
<li>接口强调单个功能实现，抽象类强调类之间所属关系</li>
</ul>
<h2 id="如何自定义一个异常"><a href="#如何自定义一个异常" class="headerlink" title="如何自定义一个异常"></a>如何自定义一个异常</h2><p>1，实现Exception或者RuntimeException</p>
<p>2，创建有参和无参构造</p>
<p>3，构造中用super调用父类的构造</p>
<p>4，使用的时候直接throw，利用构造方法创建对象</p>
<h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p>1，浅拷贝指的是调用Object的clone方法，拷贝时基本类型变量会复制一份，引用类型只会复制引用，前后的对象的变量都存储同一个对象的地址</p>
<p>2，深拷贝指的在浅拷贝的基础上，手动新建对象赋值或者递归调用浅拷贝方法，来完成引用类型的复制</p>
<p>3，需要实现cloneable接口才可以使用clone方法，否则会报异常</p>
<p>4，层级过多可以选择序列化反序列化来深拷贝</p>
<h2 id="comparator和comparable的区别"><a href="#comparator和comparable的区别" class="headerlink" title="comparator和comparable的区别"></a>comparator和comparable的区别</h2><p>1，类实现comparable接口，可以给当前类制定一个排序规则，写在compare方法里，这个类的对象互相之间被排序时将会使用这个规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//students实现的是comparable接口，直接排序即可</span></span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2，comparator接口是规则接口，指定泛型为规则适用的类，每一个comparator接口的实例都是一个排序规则，可以通过多个接口写上同一泛型类，达到给这个类多种可选的规则的目的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过传入多个comparator实例来指定排序规则</span></span><br><span class="line"><span class="comment">//按照姓名排序</span></span><br><span class="line">Collections.sort(students, <span class="keyword">new</span> <span class="title class_">NameComparator</span>());</span><br><span class="line">     </span><br><span class="line"><span class="comment">// 按年龄排序</span></span><br><span class="line">Collections.sort(students, <span class="keyword">new</span> <span class="title class_">AgeComparator</span>());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型用于指定规则适用的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.getName().compareTo(s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>1，序列化指的是从java对象转成字节序列，反序列化相反</p>
<p>2，通常在网络传输，文件持久化等地方需要序列化成字节序列</p>
<p>3，使用ObjectInputStream .readObject可以完成反序列化；ObjectOutputStream .writeObject可以完成序列化</p>
<p>4，序列化需要实现Serializable接口，需要重写版本号用于正确的反序列化；对象中不需要序列化的成员变量可以加上transient关键字</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="ArrayList和Linkedlist的区别"><a href="#ArrayList和Linkedlist的区别" class="headerlink" title="ArrayList和Linkedlist的区别"></a>ArrayList和Linkedlist的区别</h2><p>1，arraylist底层是动态数组，适合随机读取；linkedlist的底层是双链表，适合头尾的增删</p>
<p>2，linkedlist由于要存储额外的前后指针，所以占用内存较多</p>
<h2 id="list如何在遍历中删除元素"><a href="#list如何在遍历中删除元素" class="headerlink" title="list如何在遍历中删除元素"></a>list如何在遍历中删除元素</h2><p>1，获取迭代器，遍历的时候调用迭代器的remove</p>
<p>2，for i遍历的时候，使用后序遍历，删除时不会影响被删除元素之前的部分</p>
<p>3，不可以使用for i前序遍历，因为删除元素之后，后面元素会补到当前的位置，这个位置已经访问过，补上来的元素就会被略过</p>
<h2 id="HashMap容量，负载因子，扩容"><a href="#HashMap容量，负载因子，扩容" class="headerlink" title="HashMap容量，负载因子，扩容"></a>HashMap容量，负载因子，扩容</h2><p>1，初始容量16，负载因子0.75；当 元素数量&gt;容量*负载因子 时，触发扩容；扩容倍数为2</p>
<p>2，hash冲突的链表长度达到8，并且元素总数&gt;64时，触发链表转红黑树，如果没有超过64，只会扩容</p>
<h2 id="为什么hash容量设计成2的倍数"><a href="#为什么hash容量设计成2的倍数" class="headerlink" title="为什么hash容量设计成2的倍数"></a>为什么hash容量设计成2的倍数</h2><p>1，方便桶的计算：hashmap的桶，是通过调用key的hashcode方法取得32位hashcode，再hashcode与本身高16位进行异或操作，结果再与上容量-1(table长)，结果即为数组下标，用于存放value</p>
<ul>
<li>由于数组长度通常不会超过16位，因此高16位hash不起作用；通过高16和低16进行异或操作，发挥作用，增加散列程度</li>
<li>异或操作相比与和或，结果是1：1，更加均匀</li>
<li>由于数组长(容量)设计成2的倍数，那么使用&amp;操作即可达到取模的结果，位运算的速度快于取模，提高了效率</li>
</ul>
<p>2，方便扩容后的重hash：hashcode()&#x3D;&#x3D;h；r&#x3D;(h^h&gt;&gt;16)&amp;tableLen-1</p>
<ul>
<li>扩容时&amp;之前的式子不变，tableLen变成两倍也就是最高位写上1</li>
<li>只要判断r在新增的tableLen那个最高位上，是1还是0，是1代表结果总体*2，那么桶位置变化到两倍下标；如果是0，那一位&amp;的结果也是0，代表桶的位置不变</li>
<li>因此，重hash时仅需判断，高一位的r是1还是0即可完成任务，省去了从0开始重hash繁多的步骤，提高的效率</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><p>1，直接new</p>
<p>2，反射调用构造函数创建</p>
<p>3，通过对象拷贝</p>
<p>4，通过对象序列化和反序列化</p>
<h2 id="反射定义"><a href="#反射定义" class="headerlink" title="反射定义"></a>反射定义</h2><p>1，在程序运行状态中能动态的获取类信息并调用其方法的功能叫反射</p>
<h2 id="获取class对象的方式"><a href="#获取class对象的方式" class="headerlink" title="获取class对象的方式"></a>获取class对象的方式</h2><p>1，类.class</p>
<p>2，Class.forName</p>
<p>3，对象.getClass</p>
<h2 id="反射的优点和缺点"><a href="#反射的优点和缺点" class="headerlink" title="反射的优点和缺点"></a>反射的优点和缺点</h2><p>1，优点：</p>
<ul>
<li>动态操作，适用于框架</li>
<li>突破访问限制，可以访问和修改私有成员</li>
</ul>
<p>2，缺点：</p>
<ul>
<li>效率低，jvm不会对反射代码进行优化</li>
<li>安全性低，绕过访问控制，破坏封装</li>
</ul>
<h2 id="通过反射创建对象，属性赋值，调用方法举例"><a href="#通过反射创建对象，属性赋值，调用方法举例" class="headerlink" title="通过反射创建对象，属性赋值，调用方法举例"></a>通过反射创建对象，属性赋值，调用方法举例</h2><p>1，创建对象，先获取构造方法，之后直接传参调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class); <span class="comment">// 获取指定构造方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>2，对私有字段赋值时候要开启强制访问，需要指定是哪个对象的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获取私有字段</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);                   <span class="comment">// 强制访问私有属性</span></span><br><span class="line">nameField.set(user, <span class="string">&quot;Bob&quot;</span>);                      <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure>

<p>3，调用私有方法必须开启强制访问，需要指定调用的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">secretMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;secretMethod&quot;</span>);</span><br><span class="line">secretMethod.setAccessible(<span class="literal">true</span>);  <span class="comment">// 强制访问私有方法</span></span><br><span class="line">secretMethod.invoke(user);   </span><br></pre></td></tr></table></figure>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h2><p>1，直接丢弃</p>
<p>2，丢弃报异常</p>
<p>3，丢弃最老的任务</p>
<p>4，不丢弃，用户线程执行</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>1，使用：</p>
<ul>
<li>代码块中，锁指定的对象</li>
<li>静态方法中，锁类对象</li>
<li>普通方法中，锁this</li>
</ul>
<p>2，分类，原理：</p>
<ul>
<li>偏向锁：<ul>
<li>mark word存线程id，原mark word保存在该线程的栈帧的lock record中</li>
<li>获取锁只需要判断线程id和mark word中存的id是不是一样就可以</li>
<li>适合同步块大概率只由一个线程执行的场景</li>
</ul>
</li>
<li>轻量级锁：<ul>
<li>在栈中创建一片锁空间，markword指向该空间，空间内存markword原始值</li>
<li>加锁的时候尝试cas把markword指向自己的锁空间，失败会自旋一段时间</li>
<li>适合同步块执行时间很短的任务，短时间自旋消耗的cpu资源远小于直接阻塞导致的线程上下文切换</li>
</ul>
</li>
<li>重量级锁：<ul>
<li>加锁时，为对象创建一个monitor，对象头的markword指向monitor，monitor对象中的字段暂存markword原本的值</li>
<li>monitor中存储获取锁成功的线程，计数器计算重入次数</li>
<li>monitor拥有一个阻塞队列和一个等待队列，获取锁失败会进入阻塞队列，获取锁成功的线程调用wait会进入等待队列并释放锁；只有当线程被notify唤醒后重新获取时间片wait方法才会结束</li>
</ul>
</li>
</ul>
<p>3，升级：</p>
<p>4，性质：</p>
<ul>
<li>原子性，Synchronized包裹的代码对于其他线程来说是原子的，同时成功其他线程才可见，出现异常会失败且释放锁</li>
<li>可见性，Synchronized结束时会强行把代码块的变量刷新到主存，进入Synchronized时会直接去主存重读一个值，刷新进主存保证了对其他线程可见</li>
<li>有序性，Synchronized会保证同步块内外的指令不会重排序</li>
</ul>
<h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h1><h2 id="spring使用到的设计模式"><a href="#spring使用到的设计模式" class="headerlink" title="spring使用到的设计模式"></a>spring使用到的设计模式</h2><p>1，简单工厂模式</p>
<p>beanfactory通过传入bean的类型或者名字就可以获取不同的bean</p>
<p>2，工厂方法模式</p>
<p>FactoryBean是工厂方法模式的体现，通过实现FactoryBean接口实现不同的工厂，工厂里面写不同类的实现逻辑，好处是新增新的工厂时只需要新增类实现FactoryBean就好，不需要像简单工厂那样调整if-else if逻辑</p>
<p>3，单例模式</p>
<p>singleton的bean使用了单例模式</p>
<p>懒汉式 ，双重检验所，第一次判断可以让有bean之后不用每次都枷锁；volatile修饰禁止指令重排，保证没有被初始化的对象不会被使用</p>
<p>4，代理模式</p>
<p>aop使用了动态代理，分为jdk和cglib</p>
<p>5，模板方法模式</p>
<p>jdbctemplate，transactiontemplate</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>1，初始化创建对象放在static final的变量中，类初始化即创建唯一对象</p>
<ul>
<li>初始化由jvm控制，线程安全</li>
<li>每次都提前创建可能会浪费资源</li>
</ul>
<p>2，枚举类：需要的对象定义为枚举类的一个变量，枚举类初始化，该变量也完成创建</p>
<ul>
<li>jvm保证枚举变量唯一性，初始化时创建，线程安全</li>
<li>枚举类是构造私有的，且jvm禁止使用反射获取私有构造来创建枚举对象，天然防反射</li>
</ul>
<h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><p>1，双重检查锁</p>
<ul>
<li>外层的Synchronized是避免有对象后还要每次都进入同步块</li>
<li>volatile是为了防止指令重排曝光出还未初始化完成的对象</li>
<li>线程安全，延迟加载</li>
</ul>
<p>3，静态内部类：在静态内部类的static final变量中创建对象，只有当该变量被初次使用时，静态内部类才会初始化</p>
<ul>
<li>通过外部类延迟调用静态内部类的变量来实现延迟加载</li>
<li>通过静态内部类的初始化阶段创建对象来保证线程安全</li>
<li>线程安全，延迟加载</li>
</ul>
<h2 id="ioc和aop"><a href="#ioc和aop" class="headerlink" title="ioc和aop"></a>ioc和aop</h2><p>枚举类和管理对象的权力交给容器，好处是解耦合，增强了可测性</p>
<p>2，aop指的是切面编程，通过把横切逻辑从业务中分离形成切面；好处是可以在不修改原代码的基础上对方法进行功能增强，降低耦合，复用代码</p>
<p>3，使用注解实现aop</p>
<ul>
<li>@AspectJ标记类为切面</li>
<li>@pointcut在空方法上指定方法要切的包，类，方法等可以使用方法名复用代码</li>
<li>@Before @Around @After 在方法上指定方法要在目标的哪个位置切入；注解参数可以是@Pointcut，也可以是方法名</li>
</ul>
<p>4，spring默认有接口的情况下优先使用jdk代理，只有在没有接口的情况下才会使用cglib</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>1，实例化</p>
<p>2，属性注入</p>
<p>3，aware处理，如果bean实现了接口，spring会调用接口方法，参数包含bean想要的东西，bean可以在接口中把参数赋值给自身的成员变量</p>
<p>4，beanpostprocessor前</p>
<p>5，初始化</p>
<p>6，beanpostprocessor后；进行aop的地点</p>
<p>7，销毁</p>
<h2 id="注解-Autowired，-Resource，-Bean，-Component"><a href="#注解-Autowired，-Resource，-Bean，-Component" class="headerlink" title="注解@Autowired，@Resource，@Bean，@Component"></a>注解@Autowired，@Resource，@Bean，@Component</h2><p>1，Autowired默认使用类型注入，存在多个相同类型的bean会报错，配合qualify可以使用名字注入</p>
<p>2，Resource默认优先使用名字注入，名字不匹配再类型注入</p>
<p>3，Component用于标记类作为spring组件，对象作为bean</p>
<p>4，Bean作用于配置类中的方法，将方法的返回值作为bean放到容器中，适用于手动创建复杂对象</p>
<h2 id="Transactional的参数"><a href="#Transactional的参数" class="headerlink" title="@Transactional的参数"></a>@Transactional的参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">  propagation = Propagation.REQUIRED,  // 事务传播行为</span></span><br><span class="line"><span class="meta">  isolation = Isolation.DEFAULT,        // 隔离级别</span></span><br><span class="line"><span class="meta">  timeout = 30,                        // 超时时间（秒）</span></span><br><span class="line"><span class="meta">  readOnly = false,                    // 是否只读</span></span><br><span class="line"><span class="meta">  rollbackFor = Exception.class        // 触发回滚的异常类型</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<p>1，隔离级别</p>
<ul>
<li>读未提交</li>
<li>读已提交</li>
<li>可重复读</li>
<li>串行</li>
</ul>
<p>2，传播行为：事务方法之间调用时事务如何传播</p>
<ul>
<li><h3 id="MANDATORY-强制，调用方没有则报异常"><a href="#MANDATORY-强制，调用方没有则报异常" class="headerlink" title="MANDATORY:强制，调用方没有则报异常"></a>MANDATORY:强制，调用方没有则报异常</h3></li>
<li><h3 id="REQUIRES-NEW：新事务，被调用方总是创建新事务"><a href="#REQUIRES-NEW：新事务，被调用方总是创建新事务" class="headerlink" title="REQUIRES_NEW：新事务，被调用方总是创建新事务"></a>REQUIRES_NEW：新事务，被调用方总是创建新事务</h3></li>
<li><h3 id="REQUIRED：需要，调用方有，被调用方则使用，无则新建"><a href="#REQUIRED：需要，调用方有，被调用方则使用，无则新建" class="headerlink" title="REQUIRED：需要，调用方有，被调用方则使用，无则新建"></a>REQUIRED：需要，调用方有，被调用方则使用，无则新建</h3></li>
<li><h3 id="SUPPORTS：支持，调用方有则使用，无则不用"><a href="#SUPPORTS：支持，调用方有则使用，无则不用" class="headerlink" title="SUPPORTS：支持，调用方有则使用，无则不用"></a>SUPPORTS：支持，调用方有则使用，无则不用</h3></li>
<li><h3 id="NESTED：嵌套"><a href="#NESTED：嵌套" class="headerlink" title="NESTED：嵌套"></a>NESTED：嵌套</h3></li>
<li><h3 id="NOT-SUPPORTED：不支持，调用方有则挂起"><a href="#NOT-SUPPORTED：不支持，调用方有则挂起" class="headerlink" title="NOT_SUPPORTED：不支持，调用方有则挂起"></a>NOT_SUPPORTED：不支持，调用方有则挂起</h3></li>
<li><h3 id="NEVER：不支持，调用方有则异常"><a href="#NEVER：不支持，调用方有则异常" class="headerlink" title="NEVER：不支持，调用方有则异常"></a>NEVER：不支持，调用方有则异常</h3></li>
</ul>
<p>3，触发回滚的异常类型</p>
<p>4，是否只读</p>
<h2 id="spring的单例bean是否会出现线程安全问题"><a href="#spring的单例bean是否会出现线程安全问题" class="headerlink" title="spring的单例bean是否会出现线程安全问题"></a>spring的单例bean是否会出现线程安全问题</h2><p>1，主要是看bean是否有状态，也就是bean的成员变量是否可能被修改，如果可以被修改就会出现线程安全问题</p>
<p>2，如果有是状态的bean，那么可以使用prototype修饰，或者将用来修改的值不要放在成员变量里，可以放在ThreadLocal中</p>
<h2 id="三级缓存解决循环依赖"><a href="#三级缓存解决循环依赖" class="headerlink" title="三级缓存解决循环依赖"></a>三级缓存解决循环依赖</h2><p>1，三个缓存：</p>
<ul>
<li>一级缓存存在的是初始化完成的对象</li>
<li>二级缓存存的是早期实例，早期由三级缓存控制有需要时才会暴露</li>
<li>三级缓存存的ObjectFactory，由bean实例化时放入，控制暴露早期实例，提前进行AOP</li>
</ul>
<p>2，bean寻找过程：</p>
<ul>
<li>先在一级缓存找</li>
<li>再在二级缓存找</li>
<li>三级缓存找，找到则暴露早期实例并存入二级缓存</li>
<li>三级缓存没有证明还未实例化，先实例化</li>
</ul>
<p>3，三级缓存解决循环依赖：</p>
<ul>
<li>暴露bean的早期实例给正在初始化的bean，完成初始化</li>
<li>ObjectFactory动态判断bean是否需要aop，需要的的话先进行aop操作，暴露的就是代理对象的实例的引用</li>
</ul>
<p>4，二级缓存的作用：</p>
<ul>
<li>存储早期实例，当多个bean初始化都依赖此实例时，能保证获取的是同一个实例的引用，保持单例</li>
<li>起一个缓存作用，不用每一次依赖都去执行ObjectFactory获取早期实例的方法</li>
</ul>
<p>5，注意事项：</p>
<ul>
<li>只有单例模式可以解决循环依赖</li>
<li>互相依赖的bean如果都是构造注入的话，spring没有办法解决；可以是字段注入(Autowired,Resource)或者setter注入</li>
<li>最好不要写有循环依赖的代码</li>
</ul>
<h2 id="springmvc的请求流程"><a href="#springmvc的请求流程" class="headerlink" title="springmvc的请求流程"></a>springmvc的请求流程</h2><p>1，请求进入dispatcherServlet</p>
<p>2，分发给handlermapping：负责找合适的controller方法</p>
<p>3，分发给handlerAdopter:</p>
<ul>
<li>负责适配不同方式配置的controller，注解，接口等方式</li>
<li>调用Controller方法</li>
<li>负责处理返回值，以ModelAndView，String(解析为视图)</li>
</ul>
<p>4，handle执行</p>
<p>5，视图解析器modeView</p>
<p>6，dispatcherServlet返回给前端</p>
<h2 id="过滤器拦截器的顺序"><a href="#过滤器拦截器的顺序" class="headerlink" title="过滤器拦截器的顺序"></a>过滤器拦截器的顺序</h2><p>1，大致的顺序：过滤器-&gt;dispatcherservlet-&gt;拦截器</p>
<p>2，详细的顺序</p>
<ul>
<li>过滤器dofilter方法，chain.dofilter()之前的代码</li>
<li>进入dispatcherServlet</li>
<li>进入拦截器prehandle方法</li>
<li>调用controller方法执行</li>
<li>拦截器posthandle方法，可以修改modeandView</li>
<li>视图解析器</li>
<li>拦截器afterhandle方法</li>
<li>过滤器dofilter方法的chain.dofilter()之后的代码</li>
</ul>
<h2 id="和-的区别，-的使用场景"><a href="#和-的区别，-的使用场景" class="headerlink" title="${}和#{}的区别，${}的使用场景"></a>${}和#{}的区别，${}的使用场景</h2><p>1，#{}是预编译占位，会在变量两边自动加上单引号，可以防止sql注入，原理是预编译的会当作一个参数处理而非sql</p>
<p>2，${}是sql拼接，不会在变量两边加单引号，可能会造成sql注入，比如where name &#x3D;’Tom’ or 1&#x3D;1这个条件永远都是true、</p>
<p>3，${}的使用场景</p>
<ul>
<li>语法上不能加引号的：动态获取表名，列名，排序方式</li>
<li>在使用的时候保证${}里面的变量都来自于后端，而不是直接把前端url中的变量取出来用，前端的可能会拼接好的语句作为变量；要保证前端用户不可控</li>
</ul>
<h2 id="Mybatis的分页原理"><a href="#Mybatis的分页原理" class="headerlink" title="Mybatis的分页原理"></a>Mybatis的分页原理</h2><p>1，可以使用RowBounds进行逻辑分页，逻辑分页是把所有的数据查出来在内存里进行分页</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RowBounds</span> <span class="variable">rowBounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowBounds</span>(offset, limit);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectAllUsers(rowBounds);</span><br></pre></td></tr></table></figure>

<p>2，可以使用分页插件进行物理分页，指的是拦截负责sql语句的类，进行sql拼接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">List&lt;User&gt; users = userMapper.getAllUsers();</span><br></pre></td></tr></table></figure>

<p>3，区别及其使用场景</p>
<ul>
<li>逻辑分页使用简单，不需要更改sql语句，适合少量数据</li>
<li>物理分页性能好，不会造成内存溢出，适合大量数据查询</li>
</ul>
<h2 id="实体类属性名和表的字段名不一样"><a href="#实体类属性名和表的字段名不一样" class="headerlink" title="实体类属性名和表的字段名不一样"></a>实体类属性名和表的字段名不一样</h2><p>1，配置mapUnderscoreToCamelCase属性会true来开启自动驼峰和下划线转换</p>
<p>2，在写SQL语句的时候给字段取别名</p>
<p>3，使用resultmap来手动一一对应</p>
<h2 id="Mybatis的一级缓存和二级缓存"><a href="#Mybatis的一级缓存和二级缓存" class="headerlink" title="Mybatis的一级缓存和二级缓存"></a>Mybatis的一级缓存和二级缓存</h2><p>1，一级缓存：默认开启，作用域为同一个sqlSession，在进行增删改或者手动执行sqlsession对象的flush方法时会清除一级缓存</p>
<p>2，二级缓存：</p>
<ul>
<li>需要手动开启：配置中设置cacheEnabled为true，在需要开启的mapper文件中写上&lt; &#x2F;catched &gt;</li>
<li>二级缓存的作用域为namespace，进行增删改操作或者执行sqlsession的clearCache方法时会清除二级缓存</li>
</ul>
<h2 id="Mybatis-Mapper-接口支持重载吗？"><a href="#Mybatis-Mapper-接口支持重载吗？" class="headerlink" title="Mybatis Mapper 接口支持重载吗？"></a>Mybatis Mapper 接口支持重载吗？</h2><p>1，不支持重载，包+类(接口)+方法签名共同来确定一条mapper中的sql，重载会出现一个方法有多条sql待选</p>
<h2 id="springboot自动装配原理"><a href="#springboot自动装配原理" class="headerlink" title="springboot自动装配原理"></a>springboot自动装配原理</h2><p>1，@EnableAutoConfiguration 注解，上使用@Import导入了AutoConfigurationImportSelector类，并且可以使用exclude排除；也可以在@SpringBootApplication上排除</p>
<p>2，AutoConfigurationImportSelector对象的selectImports方法被执行</p>
<p>3，springboot启动时，加载META - INF&#x2F;spring.factories文件，文件中写的是配置类的全限定名</p>
<p>4，配置类上有@Conditional系列注解判断配置类是否生效</p>
<p>5，生效的配置类在它的方法上加@Bean和@Conditional系列注解来控制需要被spring容器创建的bean</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>1，程序计数器</p>
<p>2，虚拟机栈</p>
<p>3，本地方法栈</p>
<p>4，堆</p>
<p>5，方法区</p>
<h2 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h2><p>1，加载</p>
<ul>
<li>通过全限定名获取类的class文件二进制流</li>
<li>将字节流转化成方法区的运行时数据结构</li>
<li>堆中生成Class对象作为该类信息的入口</li>
</ul>
<p>2，链接</p>
<ul>
<li>验证：文件格式，元数据，字节码，符号引用</li>
<li>准备：赋初值，static final赋完整值</li>
<li>解析：符号引用转直接引用</li>
</ul>
<p>3，初始化</p>
<ul>
<li><clinit>方法，执行静态代码块，和成员变量赋值语句</li>
</ul>
<h2 id="初始化契机"><a href="#初始化契机" class="headerlink" title="初始化契机"></a>初始化契机</h2><p>1，类被new</p>
<p>2，子类发生初始化</p>
<p>3，访问静态方法或者非final的静态变量</p>
<p>4，class.forName</p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>1，低层收到加载请求，先委派高层加载器到最高，不在高层扫描范围内则返回给上一层加载</p>
<p>2，类加载器</p>
<ul>
<li>Bootstrap ClassLoader启动类加载器</li>
<li>Extension Class Loader拓展类加载器</li>
<li>System ClassLoader启动类加载器，负责classpath</li>
</ul>
<p>4，破坏双亲委派场景</p>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>1，G1和CMS都使用并发的可达性分析算法</p>
<p>2，并发的可达性分析：</p>
<ul>
<li>三色标记：黑色代表分析完毕可达，灰色代表正在分析，白色代表不可达</li>
</ul>
<p>3，问题：</p>
<ul>
<li>一个白色断开了所有的灰色同时连上了黑色，由于黑色不会再被分析，白色最终还是白色会被误回收</li>
</ul>
<p>4，解决：</p>
<ul>
<li>增量更新法：黑色新连上一个后，黑色转变为灰色，CMS使用</li>
<li>原始快照法：使用白色脱离灰色前的快照</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>1，复制算法：多用于新生代，不会产生碎片，但是需要两倍内存</p>
<p>2，标记清除算法：cms使用，标记内存可以使用，会产生碎片</p>
<p>3，整理算法：老年代使用，不会产生碎片，但是会改变对象地址，需要stw</p>
<p>4，分代收集算法：</p>
<ul>
<li>将堆分为新生代和老年代，新生代分为Eden：s0：s1 &#x3D; 8:1:1，新生代多使用复制算法，老年代收集器多使用标记整理算法</li>
<li>新生代复制算法：新对象优先放入Eden，进行minalGC时，将Eden存活的和某s区存活的，一起复制入另一个s区，其他的清除</li>
</ul>
<h2 id="垃圾回收器G1-CMS"><a href="#垃圾回收器G1-CMS" class="headerlink" title="垃圾回收器G1,CMS"></a>垃圾回收器G1,CMS</h2><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>1，流程：</p>
<ul>
<li>初始标记，并发标记，最终标记(stw使用原始快照)，筛选回收(选择最有价值的回收)</li>
</ul>
<p>2，优点：</p>
<ul>
<li>可以自己设置预期的回收时间</li>
<li>不会产生内存碎片</li>
</ul>
<p>3，缺点：</p>
<ul>
<li>需要额外的数据结构来管理region</li>
</ul>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>1，流程：</p>
<ul>
<li>初始标记，并发标记，重新标记，并发清除</li>
</ul>
<p>2，优点：</p>
<ul>
<li>响应快速，垃圾回收时间很短</li>
</ul>
<p>3，缺点：</p>
<ul>
<li>会产生大量的内存碎片</li>
<li>作为老年代，没有内存可以担保，在并发标记阶段新产生的浮动垃圾可能会沾满空间导致无法继续回收，这次回收可能失败</li>
</ul>
<h1 id="堆分析工具"><a href="#堆分析工具" class="headerlink" title="堆分析工具"></a>堆分析工具</h1><p>1，eclipse MAT，主要用于分析dum下的hprof文件</p>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>1，指定堆内存大小 -Xms设置初始大小，-Xmx设置最大大小，-Xmm设置新生代大小，-Xss设置线程栈大小</p>
<p>2，设置使用G1垃圾回收器-XX:+UseG1GC，-XX:MaxGCPauseMillis可以设置g1垃圾收集最大的停顿时间，-XX:G1HeapRegionSize设置region大小</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h2><p>1，char的长度固定，指定0-255个字符</p>
<p>2，varchar的长度可变，可以指定0-65535个字节，字符数受编码最大长度影响，还受页的大小影响，因为要保证每一页至少要存储两条记录，所以实际不一定能够分到65535个字节</p>
<p>3，这两个括号里面的数字表示的都是字符数量，varchar只有使用ASCII编码时才有机会在里面填65535</p>
<h2 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h2><p>1，对条件列使用函数或者计算：索引是按照条件列排序的，破坏条件列就无法使用索引</p>
<p>2，联合索引，排序，分组中，没有使用最左原则</p>
<p>3，发生了隐式类型转换：如果变量是数字类型，字段是字符串类型，那么mysql要先把字段转成数字才可以和变量比较，等同于对字段使用了函数</p>
<p>4，like的最左有通配符</p>
<p>5，非等值的范围查询，后面的列无法使用索引</p>
<h2 id="索引结构B-树"><a href="#索引结构B-树" class="headerlink" title="索引结构B+树"></a>索引结构B+树</h2><p>1，叶子结点存放所有数据组合成单链表，通过页目录，把记录分组，每组组成一个槽，用二分法来达成快速查找</p>
<p>2，非叶子结点只存放记录项，每一项对应一页，由指向的页的最小记录的字段值和页号等组成，该页也有页目录，同样可以快速查找</p>
<p>3，索引必须按索引列排序的</p>
<h2 id="B树，hash，B-树结构的优劣"><a href="#B树，hash，B-树结构的优劣" class="headerlink" title="B树，hash，B+树结构的优劣"></a>B树，hash，B+树结构的优劣</h2><p>1，B树：</p>
<ul>
<li>由于非叶子节点也存数据，导致树高比b+树高，每次查询都需要多io</li>
<li>范围查询需要跨越层级</li>
</ul>
<p>2，Hash表：</p>
<ul>
<li>查找迅速，O(1)级别</li>
<li>但是不能范围查询</li>
<li>不能排序</li>
<li>不好删除</li>
</ul>
<p>3，B+树：</p>
<ul>
<li>树高低</li>
<li>叶子结点单链表，适合范围查询和全表扫描</li>
<li>可以排序，可以分组</li>
</ul>
<h2 id="索引适用的场景"><a href="#索引适用的场景" class="headerlink" title="索引适用的场景"></a>索引适用的场景</h2><p>1，高频率查询列</p>
<ul>
<li>记录数量多</li>
<li>高基数列，区分度高</li>
<li>更新不频繁</li>
<li>非大列</li>
</ul>
<p>2，排序列</p>
<p>3，分组列</p>
<p>4，被连接表的连接列</p>
<h2 id="索引相关术语定义"><a href="#索引相关术语定义" class="headerlink" title="索引相关术语定义"></a>索引相关术语定义</h2><p>1，回表：通过二级索引查询时，二级索引没有包含的列需要再去聚簇索引里查</p>
<p>2，覆盖索引：级联索引已经包括了所有需要的列，这时候不需要回表</p>
<p>3，索引下推：索引中包含了where的条件字段，会直接在存储引擎级别判断，而不用再次回表去查询条件字段，再进行判断</p>
<p>4，最左匹配原则：联合索引的使用应该满足从左到右的原则，否则右侧无法使用索引</p>
<p>5，索引合并</p>
<h2 id="事务的四大特性以及实现方式"><a href="#事务的四大特性以及实现方式" class="headerlink" title="事务的四大特性以及实现方式"></a>事务的四大特性以及实现方式</h2><p>1，原子性：undo日志，出错回滚</p>
<p>2，隔离性：事务之间相互隔离，使用锁和MVCC实现不同的隔离级别</p>
<p>3，一致性：使用约束，隔离级别等手段保证数据符合预期</p>
<p>4，持久性：redo日志，宕机重新执行</p>
<h2 id="事务隔离级别以及会产生的问题以及解决"><a href="#事务隔离级别以及会产生的问题以及解决" class="headerlink" title="事务隔离级别以及会产生的问题以及解决"></a>事务隔离级别以及会产生的问题以及解决</h2><p>1，读未提交：可能脏读</p>
<ul>
<li>解决：mvcc,事务内每次查询都生成readview</li>
</ul>
<p>2，读已提交：可能不可重复读</p>
<ul>
<li>解决：mvcc，每次事务内第一次查询生成readview</li>
</ul>
<p>3，可重复读：可能幻影读</p>
<ul>
<li>解决：mvcc已经解决了大部分情况下的幻影读，要想全部解决要手动添加互斥锁，select ···· for update</li>
</ul>
<p>4，序列化</p>
<h2 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h2><p>1，每条记录都有roll_ptr和trx_id两个隐藏列，roll_ptr连接着各个版本，trx_id记录最后修改这条记录的事务id</p>
<p>2，查询的时候生成read view，包含</p>
<ul>
<li>当前事务id</li>
<li>事务开启时存活的事务ids</li>
<li>存活的最小事务id</li>
<li>下一个事务将被分配的id</li>
</ul>
<p>3，从每条记录的最新版本开始，沿着版本链判断该版本是否可见</p>
<ul>
<li>判断记录trx_id是否是当前事务id，是的话可见</li>
<li>是否&lt;存活的最小事务id,是的话证明该版本记录的事务已提交，可见</li>
<li>是否&gt;下一个事务将被分配的id，是的话表示是当前事务后开启的事务，不可见</li>
<li>事务id在最小-最大之间，判断是否在事务开启时存活的事务ids内，否的话证明当前事务开启前已提交，可见</li>
</ul>
<p>4，msyql默认读已提交和可重复读两个隔离级别都是使用MVCC，区别在于</p>
<ul>
<li>读已提交时，事务内每次查询都生成readview，因此，事务内别的事务提交的，下次查询就可以读取到</li>
<li>可重复读时，只在事务第一次查询时生成readview，事务内提交的事务，感知不到</li>
</ul>
<h2 id="Innodb的锁"><a href="#Innodb的锁" class="headerlink" title="Innodb的锁"></a>Innodb的锁</h2><p>1，表级锁</p>
<ul>
<li>表x，表级别排他所，需要表中任何记录都不存在s或x锁才能加，加上后阻塞表x，s，行x，s</li>
<li>表s，标记共享锁，表中不能有行x，该锁和行s兼容</li>
<li>ix锁，对行标记x时，会对表标记意向锁ix，标记表中有记录被加了x锁</li>
<li>is锁，同ix</li>
<li>表x锁，对ix，is，x，s全部不兼容</li>
<li>表s，对is，行s兼容</li>
<li>注意ix，is事务提交才释放，即使行锁全释放，也会继续存在，这时还是会有阻塞表x的功效</li>
<li>使用lock tables加表锁会隐式提交当前会话中所有未提交的事务</li>
<li>元数据锁</li>
</ul>
<p>2，行级锁</p>
<ul>
<li>s，共享锁，和x，s兼容：有s后可以获取x或s</li>
<li>x，排他锁，不兼容：有x后无法获取x或s：主要的目的就是让读读不阻塞，读写阻塞</li>
<li>gap间隙锁：阻塞当前记录和前一个空隙，防止插入，幻影读，被阻塞的事务会生成锁对象等待，锁释放时同时获取到可以插入</li>
<li>next—key临键锁：x锁和gap锁的合体</li>
<li>隐式锁：在ru(读未提交)级别，其他事务会读到暂未提交的事务，新插入的记录并不会有锁结构(设计，加效率)，这时其他事务因为没有锁结构阻塞，可以直接获取到锁来修改记录导致脏写，使用隐式锁避免</li>
<li>事务修改前判断插入记录的trx_id，判断是否存活，存活则代表未提交，会帮助生成锁机构并阻塞自己</li>
<li>对于二级索引，没有trx_id字段，优先判断页上记录的最后修改页的trx_id，如果小于当前id那这个页所有事务都已提交，否则就先去回表然后判断trx_id</li>
</ul>
<p>3，rr级别产生幻影的场景：事务中快照读和当前读混用</p>
<ul>
<li>在A事务中先用快照读，B此时未提交，读不到</li>
<li>B提交后，再在A事务快照读，也是读不到的，但是此时使用当前读就可以读到，产生幻影</li>
</ul>
<p>4，在RR级别下，进行锁定的非唯一等值查询，唯一索引范围查询时，会给记录加上临界锁next_key，其中就包含了gap锁</p>
<p>5，语句</p>
<ul>
<li>select * from t_xxx lock in share mode；为查询到的记录加行s锁</li>
<li>select * from t_xxx for update；为查询的记录加行s</li>
<li>lock tables t_xxx write&#x2F;read；加表s&#x2F;x</li>
<li>unlock tables；释放所有表锁</li>
</ul>
<h2 id="慢SQL优化"><a href="#慢SQL优化" class="headerlink" title="慢SQL优化"></a>慢SQL优化</h2><p>1，开启慢查询日志</p>
<p>2，使用explain获取执行计划</p>
<p>3，分析关键字段</p>
<ul>
<li>type：单表的访问方法<ul>
<li>const：唯一索引等值查询</li>
<li>ref：非唯一索引等值查询</li>
<li>range：范围查询，&lt;、&gt;、in、 between</li>
<li>index：索引全扫描，不需要回表的扫描</li>
<li>all：全表扫描</li>
</ul>
</li>
<li>key：使用的索引</li>
<li>Rows：扫描的总记录数</li>
<li>extra：Using temporary（分组未使用索引）, Using filesort(排序未使用索引)</li>
</ul>
<p>4，优化sql</p>
<ul>
<li><p>优先使用const和ref</p>
</li>
<li><p>范围查询or导致的，可以改成union</p>
</li>
<li><p>limit(10000,10)改成where xx &gt;10000 limit 10</p>
</li>
<li><p>检查隐式类型转换</p>
</li>
<li><p>为order by和group by加上联合索引</p>
</li>
</ul>
<h1 id="TODO-日志，分库分表，死锁未整理"><a href="#TODO-日志，分库分表，死锁未整理" class="headerlink" title="TODO 日志，分库分表，死锁未整理"></a>TODO 日志，分库分表，死锁未整理</h1><p>日志<br>错误日志,默认开启<br>mysql服务器msqld的启动，运行，停止期间产生的严重错误都会记录在里面<br>文件的位置记录在log_error变量里面，默认的日志名是mysqld.log</p>
<p>binlog，默认开启<br>二进制日志，记录dml和ddl语句，不包含查询相关的语句，用于主从复制，数据恢复<br>有三种格式，row记录的是每一行的改变，statement记录的是sql语句，mixed混合记录(默认使用statement，特殊时会转row)</p>
<p>查询日志，默认不开启<br>记录所有操作语句， 包括dml，ddl，dql，包含查询</p>
<p>慢查询日志，默认不开启<br>记录执行时间超过指定时间的sql语句<br>slow_querry_log&#x3D;1参数为1代表开启慢查询<br>long_query_time&#x3D;2，记录执行时间超过两秒的日志，默认10秒</p>
<p>主从复制<br>1，指的是主库把dml，ddl语句复制给从库，主库可以同时给多个从库复制，从库可以作为其他库的主库，形成链状复制<br>2，好处<br>    主库宕机可以快速切换从库使用<br>    实现读写分离，降低主库的压力<br>    可以使用从库备份，防止因为主库备份导致服务无法进行增删改操作<br>3，原理(流程)<br>    主库的dml和ddl语句都会存在binlog中<br>    从库使用iothread线程读取主库的binlog日志至自己的relaylog中<br>    使用sqlthread读取relaylog执行，完成数据同步<br>4，配置<br>    在主库conf文件中，设置server_id服务id，在集群中唯一；设置readonly(0代表读写，1代表只读)<br>    在从库conf文件中，同样设置id和是否只读<br>    在从库中指定主库的ip，端口，用户，密码，binlog位置，binlog文件名字，binlog需要复制的起始位置  change replication source to···<br>    start replica开启同步<br>    show replica status查看主从同步状态：查看io running：yes代表从库从主库binlog复制的线程正常，sql running：yes代表从relay日志中读取并执行的那条线程正常<br>5，注意<br>    主从复制是从主从关系开始的时刻开始，对应binlog中的一个position，从库需要主库之前的数据，可以先把主库的数据导出成一个sql文件在从库执行，然后再开始主从复制</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据结构详解"><a href="#数据结构详解" class="headerlink" title="数据结构详解"></a>数据结构详解</h2><p>1，string，全局id</p>
<p>2，hash，对象</p>
<p>3，set，求交集，共同好友</p>
<p>4，zset，做排行榜</p>
<p>5，list，先进先出，做队列</p>
<p>6，位图Bitmaps，签到，统计在线</p>
<p>7，HyperLogLog：UV统计</p>
<p>8，GEO：地理位置</p>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><p>1，穿透：redis没有，MySQL也没有，导致无法建立缓存，攻击全部打数据库</p>
<p>解决：</p>
<ul>
<li><p>使用布隆过滤器过滤，误判的再设null缓存</p>
</li>
<li><p>redis和mysql都没有的时候，手动在redis创建一个空缓存，设置较短ttl，防止mysql在空缓存存在期间添加了后导致的不一致时间过长</p>
</li>
</ul>
<p>2，击穿：热点key过期时，大量的请求打到数据库</p>
<p>解决：热点key不设置ttl，在java代码中设置逻辑过期时间，当过期后，先返回给旧值，同时创建一个线程去重建缓存</p>
<p>3，雪崩：大量的key同时过期</p>
<p>解决：同一时间上传的key应当设置不同时间的ttl，可以设置基准时间+随机时间</p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>1，惰性删除：过期key被再次访问的时候，检查是否过期，过期则删除</p>
<p>2，定期删除：在设置了ttl的key中定期挑一批检查是否过期，默认10s一次选20个key</p>
<p>3，内存淘汰策略</p>
<ul>
<li>allkeys-lfu</li>
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>noevication：默认，拒绝新请求，不删除之前的</li>
<li>volatile-lfu：频率最低</li>
<li>volatile-lru：最长时间没访问</li>
<li>volatile-random：随机</li>
<li>volatile-ttl：ttl剩余时间最少的</li>
</ul>
<p>4，过期策略由这三种机制配合完成</p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><h2 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h2><p>1，内存存储</p>
<p>2，单线程避免了上下文切换的开销</p>
<p>3，linux下使用epoll IO多路复用</p>
<p>4，epoll对比select和poll的优势</p>
<ul>
<li>使用事件驱动代替轮循，减少了cpu开销</li>
<li>使用红黑树存放需要监听的md，在内核态持久化存储，避免了频繁的在两态之间拷贝fd列表，新添md是O(logn)</li>
<li>只有就绪的fd会传到就绪列表返回用户态，因此无需遍历列表找就绪的fd</li>
<li>总结：作为单线程应用，io多路复用帮助了redis最大程度避免受网络io阻塞的影响</li>
</ul>
<h1 id="TODO和数据库的一致性"><a href="#TODO和数据库的一致性" class="headerlink" title="TODO和数据库的一致性"></a>TODO和数据库的一致性</h1><h2 id="配置文件的配置项"><a href="#配置文件的配置项" class="headerlink" title="配置文件的配置项"></a>配置文件的配置项</h2><p>1，网络连接相关</p>
<ul>
<li>bind ip，指定可以连接的客户端ip</li>
<li>port 6379，服务器端口</li>
<li>protected-mode yes，安全模式，开启会禁止无密码的远程访问</li>
<li>timeout 300(s)，客户端空闲持续时间</li>
<li>requirepass zxr12345，设置访问密码</li>
</ul>
<p>2，内存淘汰</p>
<ul>
<li>maxmemory (bytes),最大内存</li>
<li>maxmemory-policy noeviction，内存淘汰策略</li>
</ul>
<p>3，持久化相关</p>
<ul>
<li>save a b：a秒内最少b次修改会触发rdb</li>
<li>appendonly yes：启用 AOF</li>
<li>appendfilename “appendonly.aof”  ：AOF 文件名</li>
<li>appendfsync everysec&#x2F;always&#x2F;no ：刷盘策略：每秒&#x2F;每次修改&#x2F;由操作系统决定</li>
<li>auto-aof-rewrite-percentage 100  ： AOF 文件增长100%触发重写</li>
<li>auto-aof-rewrite-min-size 64mb ：AOF 文件最小重写大小</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id="看门狗机制"><a href="#看门狗机制" class="headerlink" title="看门狗机制"></a>看门狗机制</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>1，生产者</p>
<p>2，tcp长连接：生产者和broker之间使用tcp长连接的虚拟信道(channel)发送消息</p>
<p>3，broker：Rabbitmq可以当做是一个broker，可以包含多个virtualhost</p>
<p>4，virtualhost：每个virtualhost之间互相隔离，其中包含若干交换机和队列</p>
<p>5，交换机：消息经过信道传输给交换机，由交换机分发给队列</p>
<p>6，队列：存储消息</p>
<p>7，tcp长连接：用tcp长连接的虚拟信道(channel)接收消息到消费者</p>
<p>8，消费者</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>1，生产者发送消息经tcp长连接的channel传递给交换机</p>
<p>2，交换机分发消息至不同的队列</p>
<p>3，消费者绑定队列，有消息之后自动消费</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>面试最终汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/2025/01/26/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1，nacos"><a href="#1，nacos" class="headerlink" title="1，nacos"></a>1，nacos</h1><p>1，使用nacos进行服务注册，服务发现，配置管理</p>
<p>2，下载nacos并启动</p>
<ul>
<li>直接在官网下载nacos，解压</li>
<li>在bin目录cmd执行startup.cmd -m(mode，模式) standalone(单节点)</li>
<li>在 <a href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a> 地址，管理nacos，nacos默认端口为8848</li>
</ul>
<p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250126214515794.png" alt="image-20250126214515794"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Hexo</title>
    <url>/2025/01/24/%E6%90%AD%E5%BB%BAHexo/</url>
    <content><![CDATA[<h1 id="Hexo博客的搭建以及主题选取"><a href="#Hexo博客的搭建以及主题选取" class="headerlink" title="Hexo博客的搭建以及主题选取"></a>Hexo博客的搭建以及主题选取</h1><h2 id="hexo搭建"><a href="#hexo搭建" class="headerlink" title="hexo搭建"></a>hexo搭建</h2><h3 id="1，购买低价vpn翻墙"><a href="#1，购买低价vpn翻墙" class="headerlink" title="1，购买低价vpn翻墙"></a>1，购买低价vpn翻墙</h3><p>1，推荐卷王机场，20元一年，每月提供100g流量</p>
<p>2，步骤</p>
<ul>
<li>地址栏输入卷王机场官网(卷王.xyz),选择国内入口</li>
</ul>
<p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250124095008769.png" alt="image-20250124095008769"></p>
<p>3，注册账号</p>
<p>4，进入主页面，点击左侧使用文档，查看widows使用方式</p>
<p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250124095215919.png" alt="image-20250124095215919"></p>
<h3 id="2，创建github账号"><a href="#2，创建github账号" class="headerlink" title="2，创建github账号"></a>2，创建github账号</h3><p>1，github是外国网站，需要开启翻墙才可以稳定访问</p>
<p>2，目的是把本地电脑硬盘上的笔记，放到网络(github仓库)上，经过hexo展示</p>
<p>3，<a href="https://github.com/">GitHub · Build and ship software on a single, collaborative platform · GitHub</a> –github官网</p>
<p>4，步骤</p>
<ul>
<li>打开官网，点击sign in，再点击创建新用户</li>
</ul>
<p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250124104822511.png" alt="image-20250124104822511"></p>
<p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20250124104842827.png" alt="image-20250124104842827"></p>
]]></content>
      <categories>
        <category>搭建hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2024/12/30/redis/</url>
    <content><![CDATA[<h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><span id="more"></span>

<p>1，rdb模式：生成一个内存快照，默认开启</p>
<p>2，rdb的触发机制</p>
<ul>
<li>redis服务正常停止前同步保存</li>
<li>使用save，bgsave命令的时候保存rdb文件</li>
<li>启动文件(redis.conf)中配置rdb触发的时机</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在A秒内，有B个key被修改，则执行bgsave</span></span><br><span class="line"><span class="comment">#save “”代表关闭rdb机制</span></span><br><span class="line"><span class="attr">save</span> <span class="string">A B</span></span><br><span class="line"><span class="comment">#rdb相关配置</span></span><br><span class="line"><span class="comment">#文件名称，默认dunmp.rdb</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">XXX</span></span><br><span class="line"><span class="comment">#文件路径，默认./(安装路径)</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">xxx</span></span><br><span class="line"><span class="comment">#是否开启压缩，建议不开启，压缩要耗费cpu资源</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes/no</span></span><br></pre></td></tr></table></figure>

<p>3，异步rdb的原理，使用copyonwrite思想保证对redis数据的遍历复制(bgsave)和修改(主进程修改数据)不会产生线程安全问题</p>
<ul>
<li>问题，子进程进行rdb文件保存的途中，如果主进程有修改数据的请求，就产生了变修改，边遍历复制的线程安全问题</li>
<li>解决，对rdb文件使用copyonwrite操作，修改请求进来，对需要修改的key在的内存页做备份并在备份中修改，不影响原数据，bgsave执行完再同步回去</li>
<li>优点<ul>
<li>解决了线程安全问题</li>
<li>并不是备份全部数据，而是备份要修改的数据，相当于是优化版的COW(copyonwrite)</li>
</ul>
</li>
</ul>
<p>4，缺点：</p>
<ul>
<li>间隔时间长，间隔时间内的数据在意外宕机的时候会丢失</li>
<li>需要fork子进程，压缩消耗cpu资源，写入磁盘时间长</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>1，AOF指的是记录每一次对数据进行增删改操作的命令，并在 一定时候给命令文件刷新到磁盘，宕机后直接执行命令文件中的命令即可恢复数据，因为记录的只是没保存的命令，比较小，因此相比rdb可以更高频率的把文件刷新到磁盘，更加安全</p>
<p>2，AOF开启：在conf文件中，设置</p>
<ul>
<li>appendonly  true 时开启,默认关闭</li>
<li>appendfilename XXX 指定文件名</li>
</ul>
<p>3，文件刷新到磁盘的频率控制</p>
<ul>
<li>appendfsync always，每次修改key，文件中记录的同时，刷新到磁盘</li>
<li>appendfsync  everysec，每一秒将文件中的记录刷新到磁盘</li>
<li>appendfsync  no，不控制，由操作系统自动控制刷新，一般频率比较低</li>
<li>默认everysec</li>
</ul>
<p>4，AOF的文件过大问题</p>
<ul>
<li><p>aof相比rdb，除了记录key和value，还记录了指令，因此aof比rdb会大很多</p>
</li>
<li><p>执行bgrewriteaof命令，用子进程去重写aof文件，比如set name “name1”,set name “name2”，只需要记录后面的就行了，第一次被覆盖掉了</p>
</li>
<li><p>可配置bgrewriteaof命令自动执行的时机，使用默认就好</p>
</li>
<li><pre><code class="properties">#aof文件体积超过固定值会执行，默认64
auto-aof-rewrite-min-size 64mb
#aof文件相比上一次刷新时增长了多少会执行，默认100%，即这次是上次的两倍大小时执行
auto-aof-rewrite-percentage 100
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### RDB和AOF的优缺点对比</span><br><span class="line"></span><br><span class="line">1，数据完整性，aof高，因为刷新的频率快</span><br><span class="line"></span><br><span class="line">2，宕机恢复速度，rdb快，因为rdb只需要把数据读取到内存，而aof需要执行所有的命令</span><br><span class="line"></span><br><span class="line">3，文件大小，rdb小，aof除了数据还要存指令</span><br><span class="line"></span><br><span class="line">4，使用场景，对于安全性要求很高，使用aof，不高直接用rdb；可以两个都开启，会优先使用aof的方法恢复，因为aof数据完整，但是rdb文件可以作为一个备份使用，放到其他机器或者什么地方</span><br><span class="line"></span><br><span class="line">## rdis主从</span><br><span class="line"></span><br><span class="line">### 主从建立</span><br><span class="line"></span><br><span class="line">1，配置多个redis节点可以增加redis的吞吐量，请求过来时，分发到不同的节点即可，一般来说，各个从节点负责执行读请求，主节点用于执行写请求，原因是redis的绝大多数请求都是读请求，因此多分一些节点</span><br><span class="line"></span><br><span class="line">2，如何配置主从节点</span><br><span class="line"></span><br><span class="line">+ 在从节点的conf文件中，指定</span><br><span class="line"></span><br><span class="line">+ ~~~properties</span><br><span class="line">   slaveof &lt;主节点ip&gt; &lt;主节点端口&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>3，在从节点指定了主节点之后，对于主节点的写会同步到从节点上，从节点只负责读，自动实现了读写分离</p>
<p>4，主从要开启rdb，因为要使用快照给同步给从节点</p>
<h3 id="数据同步原理"><a href="#数据同步原理" class="headerlink" title="数据同步原理"></a>数据同步原理</h3><h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p>1，先判断是否是增量同步，如果不是，增量同步拒绝，进行全量同步，主节点把数据全量同步到从节点</p>
<p>2，问题：</p>
<ul>
<li>如何判断是否使用增量同步？<ul>
<li>每个节点初始都是主节点，只有使用slaveof命令指定之后，才变为从节点，每个节点都有replicationid，从节点的replicationid在同步的时候会修改为主节点的，因此只需要判断replicationid是否和主节点相同就可以了</li>
</ul>
</li>
<li>如何进行同步？<ul>
<li>判断为全量同步之后，使用bgsave命令，在创建rdb文件开始时，记录主节点repl_backlog的offset，之后把rdb文件和offset值发送给从节点;从节点先清空自己，再加载rdb文件中的内容，同时设置自己的offset和发送过来的offset相等，主节点之后会根据从节点的offset，去repl_backlog中把指令发给从节点执行，以达到动态同步的效果</li>
</ul>
</li>
<li>bgsave期间，增量如何处理？<ul>
<li>与单纯的持久化不同，持久化中bgsave的文件并不会被用户读取，因此不用担心bgsave期间的增量导致的磁盘文件和redis内存文件不一致问题，但是从节点是专门用来读取，要尽量保证和主节点内容一致</li>
<li>主节点所有的增删改的指令都会存到repl_backlog里面，根据从节点的offset来持续将log中的命令发给从节点执行</li>
</ul>
</li>
</ul>
<p>3，repl_backlog：</p>
<ul>
<li>主节点维护的一个循环自覆盖数组，主节点的所有增删改指令都会写进repl_backlog里面，维护主节点的offset表示下一条指令插入的位置</li>
<li>从节点维护了一个offset，表示从节点同步到了repl_backlog中的哪个位置</li>
<li>主节点的offset和从节点的offset之间，就是从节点还未同步的指令</li>
</ul>
<h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p>1，增量同步发生在从节点重连，短暂失联的重连往往可以使用增量同步，长时间的失联只能用全量同步</p>
<p>2，在重连时，主节点判断replicationid是一样的，判断为增量同步，根据从节点的offset发送指令即可</p>
<p>3，如果从节点断连太久，从节点offset就会一直不变，而主节点的offset一直前移，如果他们到同一位置了，说明从节点落后的数据已经沾满了整个循环数组，主节点offset再前移，就会覆盖掉从节点还没有执行的指令，这时候，再重连只能进行全量同步</p>
<h4 id="减少全量同步，加快全量同步"><a href="#减少全量同步，加快全量同步" class="headerlink" title="减少全量同步，加快全量同步"></a>减少全量同步，加快全量同步</h4><ul>
<li>加快全量同步<ul>
<li>全量同步会产生rdb存到磁盘，再由网络发送到从节点，主节点配置repl-diskless-sync yes，可以放弃把rdb存入磁盘，而是直接网络发送给从节点</li>
<li>减小单节点的内存，可以减少rdb文件的大小，自然就减少了全量更新的时间</li>
</ul>
</li>
<li>减少全量同步<ul>
<li>选择加大repl_baklog的大小，可以忍受更长时间的断连，减少全量更新次数</li>
<li>从节点宕机要尽快解决，防止未同步的命令占满repl_baklog</li>
</ul>
</li>
<li>优化：限制主节点的从节点数量，防止同步给主机点带来过大的压力，可以选择链式结构，主节点-&gt;从节点-&gt;从节点，第三层从节点以第二层从节点为主节点</li>
</ul>
<h3 id="Redis哨兵Sentinal"><a href="#Redis哨兵Sentinal" class="headerlink" title="Redis哨兵Sentinal"></a>Redis哨兵Sentinal</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>1，作用</p>
<ul>
<li>监控主从节点是否宕机</li>
<li>故障转移，master节点宕机后应当重新选一个master</li>
<li>通知，旧的slave要绑定在新的master上</li>
</ul>
<p>2，如何判断宕机(实例是否健康)</p>
<ul>
<li>Sentinal哨兵也是集群，每一秒会给各节点发送ping，如果超过指定quorum的哨兵都没有收到来自某个节点的pong，则认为它已经宕机</li>
</ul>
<p>3，故障转移步骤</p>
<ul>
<li>挑选一个从节点作为新的主节点，主要依据是offset的大小，offset越大代表数据越完整</li>
<li>将挑出的从节点执行slaveof no one，取消绑定</li>
<li>其他的节点执行slaveof，绑定新主节点</li>
<li>宕机的旧主节点，会被修改配置文件，加上slaveof，因为它宕机了没办法直接执行slaveof命令</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>1，redis-sentinal 配置文件，是redis里面自带的，只需要写配置文件执行指令即可</p>
<p>2，文件内容</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sentinel自身端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">xxx </span></span><br><span class="line"><span class="comment">#声明sentinel自身的ip地址</span></span><br><span class="line"><span class="attr">sentinael</span> <span class="string">announce-ip xxxx</span></span><br><span class="line"><span class="comment">#声明seantinel监控的redis主从集群,并配置quorum值</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor mymaster ip port &lt;2&gt;</span></span><br><span class="line"><span class="comment">#工作目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3，使用java的redistemplate客户端</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">redis:</span> </span><br><span class="line">		<span class="attr">sentinel:</span></span><br><span class="line">		  <span class="attr">master:</span> <span class="string">指定主节点的名称，与redis-sentinel配置文件中指定的master相同</span></span><br><span class="line">		  <span class="attr">nodes:</span> <span class="string">指定sentinel集群信息</span></span><br><span class="line">		  	<span class="string">-ip：port</span></span><br><span class="line">		  	<span class="string">-ip：port</span></span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<ul>
<li>配置集群读写操作<ul>
<li>master:从主节点读</li>
<li>master_preferred：优先主节点，次选从节点</li>
<li>replica：从节点读</li>
<li>replica_prferred:优先从节点，从不可用才去主读</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitMQ</title>
    <url>/2024/12/25/rabbitMQ/</url>
    <content><![CDATA[<h2 id="1，RabbitMQ架构"><a href="#1，RabbitMQ架构" class="headerlink" title="1，RabbitMQ架构"></a>1，RabbitMQ架构</h2><p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20241225222848029.png" alt="image-20241225222848029"></p>
<ul>
<li>1，整体架构：<ul>
<li>发布者-&gt;交换机-&gt;消息队列-&gt;消费者</li>
<li>可以用virtualHost隔离，每一个由若干交换机和消息队列组成</li>
</ul>
</li>
<li>2，组件功能<ul>
<li>交换机：负责路由和转发消息</li>
<li>消息队列：负责存储消息</li>
</ul>
</li>
<li>3，数据隔离<ul>
<li>每个项目可以创建多个用户，有不同的权限，每个用户可以有多个virtualHost</li>
</ul>
</li>
</ul>
<h2 id="2，使用Java代码"><a href="#2，使用Java代码" class="headerlink" title="2，使用Java代码"></a>2，使用Java代码</h2><ul>
<li>1，引入依赖starter，在yaml文件配置<ul>
<li>host：rabbitMQ运行的主机地址</li>
<li>port：rabbitMQ端口号</li>
<li>username：用户名</li>
<li>password：密码</li>
<li>virtualHost：数据隔离空间</li>
</ul>
</li>
</ul>
<h2 id="3，rabbitMQ的组成"><a href="#3，rabbitMQ的组成" class="headerlink" title="3，rabbitMQ的组成"></a>3，rabbitMQ的组成</h2><ul>
<li>1，生产者</li>
<li>2，交换机</li>
<li>3，消息队列</li>
<li>4，消费者</li>
<li>5，数据隔离virtualhost，每个virtualhost可以有若干交换机和队列组成，virtualhost之间互相隔离</li>
<li>6，用户管理，每个用户可以有多个virtualhost</li>
</ul>
<h2 id="4，rabbitMQ原理"><a href="#4，rabbitMQ原理" class="headerlink" title="4，rabbitMQ原理"></a>4，rabbitMQ原理</h2><ul>
<li>1，生产者发消息给交换机</li>
<li>2，交换机把消息转发给队列，不负责存储</li>
<li>3，队列存储和管理消息，队列绑定交换机</li>
<li>4，消费者绑定队列消费</li>
</ul>
<h2 id="5，work-queues模型"><a href="#5，work-queues模型" class="headerlink" title="5，work queues模型"></a>5，work queues模型</h2><ul>
<li><p>1，定义</p>
<ul>
<li>当生产者信息多时可以使用多个消费者，绑定同一个队列，一起消费同一个队列</li>
</ul>
</li>
<li><p>2，问题</p>
<ul>
<li>消费者的能力不同，但是队列消息是平均分配给消费者的，导致能力强的消费者没有任务可执行</li>
</ul>
</li>
<li><p>3，解决</p>
<ul>
<li>配置每次只取一条消息，只有处理完了之后再去取</li>
</ul>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">    <span class="attr">rabbitmq:</span> </span><br><span class="line">        <span class="attr">listener:</span> </span><br><span class="line">            <span class="attr">simple:</span> </span><br><span class="line">                <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="6，rabbitMQ交换机类型"><a href="#6，rabbitMQ交换机类型" class="headerlink" title="6，rabbitMQ交换机类型"></a>6，rabbitMQ交换机类型</h2><ul>
<li>1，fanout：广播交换机，队列绑定交换机只需要提供空key(“”)即可，每次对交换机发消息都会广播到所有绑定了交换机的队列</li>
<li>2，direct：订阅交换机，队列绑定交换机的时候要提供一个key，只有交换机会根据消息中的key来路由到不同的队列</li>
<li>3，topic：通配符订阅交换机，队列绑定的时候可以用通配符，消息中的key如果满足通配符，就会路由到该队列里面<ul>
<li>key一般使用word1.word2.word3····的形式</li>
<li>#代表0或任意多层单词，*代表任意一层单词</li>
</ul>
</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">张三.18.男</span><br><span class="line">可以使用：</span><br><span class="line">张三.#</span><br><span class="line">张三.*.*</span><br><span class="line">张三.18.*</span><br><span class="line">#(全部key都接收到队列)</span><br></pre></td></tr></table></figure>

<ul>
<li>4，headers：基于mq的消息头匹配(少用)</li>
</ul>
<h2 id="7，springAMPQ分别使用java配置类和注解来配置"><a href="#7，springAMPQ分别使用java配置类和注解来配置" class="headerlink" title="7，springAMPQ分别使用java配置类和注解来配置"></a>7，springAMPQ分别使用java配置类和注解来配置</h2><ul>
<li>1，原理：springAMPQ为创建交换机，创建队列，交换机和队列的绑定都定义了专门的类以供使用</li>
<li>2，具体类：<ul>
<li>交换机：<ul>
<li>FanoutExchange </li>
<li>directExchange</li>
<li>topicExchange</li>
</ul>
</li>
<li>队列：<ul>
<li>Queue</li>
</ul>
</li>
<li>绑定：<ul>
<li>Binding</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>3，使用spring配置类示例：<ul>
<li>在配置类中创建三个对象，生产者发消息指定交换机和key，消费者绑定队列即可：</li>
</ul>
</li>
</ul>
<p><em><strong>对象创建以及绑定key</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，对象名是方法名，指定的参数是交换机名</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;directExchange&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Direct队列，注意，对象名是方法名，指定的参数是队列名</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">directQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;directQueue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Direct绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">directBinding</span><span class="params">(Queue directQueue, DirectExchange directExchange)</span> &#123;</span><br><span class="line">    <span class="comment">//将队列绑定在交换机上，并且指定绑定的key</span></span><br><span class="line">    <span class="keyword">return</span> BindingBuilder</span><br><span class="line">        .bind(directQueue)</span><br><span class="line">        .to(directExchange)</span><br><span class="line">        .with(<span class="string">&quot;directRoutingKey&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><em><strong>生产者发送消息</strong></em>:需要注入RabbitTemplate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送Direct消息,需要交换器名，队列绑的key，消息内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDirectMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;directExchangeName&quot;</span>, <span class="string">&quot;user.name&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送Fanout消息，key用空字符串表示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendFanoutMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;fanoutExchangename&quot;</span>, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>消费者</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收Direct消息，自动接收，消息由spring放在参数中，需要指定消费的队列</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;directQueueName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDirectMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received Direct Message: &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>4，使用注解配置队列和绑定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以在配置类使用注解创建三个对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Exchange(name = &quot;directExchange&quot;, type = ExchangeTypes.DIRECT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">declareDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注解会自动声明交换机，这里不需要实现具体的方法体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个队列</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Queue(name = &quot;myQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">declareQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注解会自动声明队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用@QueueBinding注解来声明队列和绑定</span></span><br><span class="line"><span class="meta">@QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;myQueue&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;directExchange&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;myRoutingKey&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">declareBinding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注解会自动声明绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也可以在消费者直接声明交换机，队列，绑定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;myQueue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;auto.exch&quot;, ignoreDeclarationExceptions = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;orderRoutingKey&quot;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8，消息转换器"><a href="#8，消息转换器" class="headerlink" title="8，消息转换器"></a>8，消息转换器</h2><ul>
<li>1，springAMQP默认使用的是jdk序列化<ul>
<li>对象序列化成立字节流，中途不可读</li>
<li>只能在java程序之间传输，依赖readObject和writeObject方法</li>
<li>jdk对象序列化会记录一些类的信息，导致传输的文件比原始的要大</li>
<li>字节流传输有安全风险，是可变的，变化之后无法进行反序列化</li>
</ul>
</li>
<li>2，配置json消息转换器，得益于springboot自动装配，只需要配置Jackson的bean就可以覆盖原来的转换器、</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意需要同时在生产者和消费者模块都引入Jackson，生产者用于序列化，消费者用于反序列化</li>
<li>setCreateMessageIds可以在序列化的时候为消息加上一个id，用于幂等性判断</li>
</ul>
<h2 id="9，生产者可靠性"><a href="#9，生产者可靠性" class="headerlink" title="9，生产者可靠性"></a>9，生产者可靠性</h2><ul>
<li><p>1，mq的客户端连接不上mq：失败重试机制</p>
<ul>
<li>spring.rabbitmq.connection-time: 1s，指定了一秒没连上服务器为超时</li>
<li>spring.rabbitmq.template.retry<ul>
<li>.enable&#x3D;true，开启重试</li>
<li>.initial-interval: 1000ms,每次重试的初始等待时间</li>
<li>multiplier&#x3D;1，下次重试的等待时间是这次的多少倍，下次时间&#x3D;初始时间+上次时间*倍数</li>
<li>max-attempts，最大重试次数</li>
</ul>
</li>
<li>注意：这个重试是阻塞式，会阻塞线程，要么禁用要么短一点，200ms左右</li>
</ul>
</li>
<li><p>2，生产者确认机制</p>
<ul>
<li><p>publisher return：消息进入交换机，但是没有正确路由到队列，会返回异常信息</p>
</li>
<li><p>publisher confirm：</p>
<ul>
<li>消息进入交换机，进入非持久化队列，直接返回ack</li>
<li>进入交换机，进入持久化队列，持久化完成后返回ack</li>
<li>进入交换机，路由失败(无法路由到任何队列)，返回ack</li>
<li>进入持久化队列，未成功持久化，返回nack</li>
<li>未能进入任何交换机，返回nack</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>只有nack的情况，需要设置重发代码，路由失败一般都是代码问题</li>
<li>由于路由失败是代码问题，因此不要开启publisher return，无法靠这个解决代码逻辑问题</li>
<li>对于nack的处理，做有限次的重试，重试失败记录异常信息即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="10，消息的可靠性"><a href="#10，消息的可靠性" class="headerlink" title="10，消息的可靠性"></a>10，消息的可靠性</h2><ul>
<li>1，为了防止rabbitmq宕机导致的数据丢失，要对交换机，队列，队列中的消息都做持久化，设置他们的durable属性为true即可</li>
<li>2，队列中的消息，之前是全部存到内存中<ul>
<li>问题：<ul>
<li>宕机或者重启，全部消息都会消失</li>
<li>消息占满内存只能往磁盘写，会阻塞生产者线程直到所有持久化完毕</li>
</ul>
</li>
<li>解决：3.6.0开始默认使用lazyQueue<ul>
<li>队列接收到消息直接存在磁盘中</li>
<li>消费者需要消费时再去取<ul>
<li>好处是可存储的消息数量增加，不会长时间阻塞生产者线程</li>
<li>得益于io优化，实际上这种方案比内存操作然后阻塞刷新到磁盘会快得多</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="11，消费者的可靠性"><a href="#11，消费者的可靠性" class="headerlink" title="11，消费者的可靠性"></a>11，消费者的可靠性</h2><ul>
<li>1，消费者确认机制，在消费者方法执行后，要给消息队列返回一个结果，展示是否消费成功以及后续操作<ul>
<li>ack：消费成功，rabbitmq应该将此消息直接从队列删除</li>
<li>nack：消费处理失败，应当重发</li>
<li>reject：处理失败且拒绝，但是从队列中删除，不再重发</li>
</ul>
</li>
<li>2，使用springamqp的消费者确认机制</li>
</ul>
<p>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 不做处理</span></span><br></pre></td></tr></table></figure>



<ul>
<li>none：失败了不做处理，不返回，会直接从队列中删除消息</li>
<li>manual：手动处理，自己在逻辑中调用api决定什么时候返回ack和nack</li>
<li>auto(推荐):自动模式，使用了aop环绕，在代理对象调用消费方法时出现运行时异常会返回nack，出现比如消息转化异常等消息处理和校验异常，会返回reject</li>
<li>3，失败重试机制：消费者返回nack时，会重新给消费者，再次调用消费者方法，一直不成功就会一直往复，可以配置重试机制，防止无限制重新入队</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置重试次数，重试时间</li>
<li>4，失败处理策略：当重试次数用完后重试还是失败，会调用失败处理策略<ul>
<li>RejectAndDontRequeueRecoverer：springamqp默认机制，重试后还是失败会直接拒绝，返回reject</li>
<li>ImmediateRequeueMessageRecoverer：本地重试失败后返回reject，重新入队列</li>
<li>RepublishMessageRecoverer：设置一个专门的交换机，配置一个队列，消费者监听队列消息，有消息可以发送邮件，人工来处理</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//只有开启了消费者重试机制，才需要对重试后还是失败的消息进行处理</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个MessageRecoverer对象，实现类为RepublishMessageRecoverer，也就是重试次数用完后，发送到指定交换机，需要指定客户端，交换机，以及发送消息时的key</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-幂等性保证"><a href="#12-幂等性保证" class="headerlink" title="12,幂等性保证"></a>12,幂等性保证</h2><ul>
<li>1，在消息放一个id，可以使用JacksonMessageConvertor生成，也可以使用自己生成的id在发送的时候带上<ul>
<li>当消费者拿到消息，判断redis或者mysql里面是不是有这个id，有的话代表执行过，没有的话这次才能执行</li>
</ul>
</li>
</ul>
<h2 id="13-延迟消息的实现"><a href="#13-延迟消息的实现" class="headerlink" title="13,延迟消息的实现"></a>13,延迟消息的实现</h2><ul>
<li>1，使用插件，下载插件放在rabbitmq的插件目录，在创建交换机的时候设置delay属性为true，发送的时候使用setdelay方法设置时间(ms)，就会自动在交换机里等时间到了才会放到队列</li>
<li>2，使用死信队列，可以为一个队列设置死信交换机<ul>
<li>死信：<ul>
<li>队列中过期的消息</li>
<li>队列超过设置的最大值，待得最久的消息</li>
<li>rejecte或者nack的，并且设置不能重入队的消息</li>
</ul>
</li>
<li>某个队列的死信消息会直接发往死信交换机，只需要设置一个死信交换机，给它榜一个队列就可以操作死信</li>
</ul>
</li>
<li>3，利用两个交换机和两个队列<ul>
<li>第一组交换机和队列，队列不设置消费者，给消息设置定时时间，让它在队列里过期成为死信</li>
<li>第二组设置为死信交换机，以及用队列绑定该交换机，在设置的时间过了之后消息会被送到死信交换机，达到延迟消息的效果</li>
</ul>
</li>
</ul>
<h2 id="12-消息丢失"><a href="#12-消息丢失" class="headerlink" title="12,消息丢失"></a>12,消息丢失</h2><ul>
<li>1，三个可靠性</li>
</ul>
<h2 id="13，重复消费幂等性"><a href="#13，重复消费幂等性" class="headerlink" title="13，重复消费幂等性"></a>13，重复消费幂等性</h2><ul>
<li>1，使用uuid或者Jackson转换器生成id，利用redis或mysql暂存，执行前判断，已经有id存进去了表示执行过了</li>
</ul>
<h2 id="14，顺序发送"><a href="#14，顺序发送" class="headerlink" title="14，顺序发送"></a>14，顺序发送</h2><ul>
<li>1，把需要按顺序的放在一个额外的队列里面</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2024/12/09/MySQL/</url>
    <content><![CDATA[<h2 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h2><h3 id="1，页存在的意义"><a href="#1，页存在的意义" class="headerlink" title="1，页存在的意义"></a>1，页存在的意义</h3><ul>
<li>页作为内存和磁盘交互的单位，如果每读一条记录，就从磁盘io到内存一条，会很慢</li>
</ul>
<h3 id="2，MyISAM的默认行格式compact"><a href="#2，MyISAM的默认行格式compact" class="headerlink" title="2，MyISAM的默认行格式compact"></a>2，MyISAM的默认行格式compact</h3><ul>
<li>行格式内容<ul>
<li>变长字段列表</li>
<li>null值列表</li>
<li>记录头信息<ul>
<li>记录的类型：0是普通记录，1是数据项记录，2是最小记录，3是最大记录</li>
<li>是否被删除：1代表被标记了删除，等待进入删除列表</li>
<li>拥有的记录数:作为组的最后一条记录，这个值就是那一组的记录数量</li>
<li>记录在本页的位置：？</li>
<li>是否是某层非叶子节点的最小索引列值所在的记录</li>
</ul>
</li>
<li>用户记录</li>
<li>隐藏列记录：roll_point,transaction_id,row_id(如果没定义主键和唯一键，会生成row_id作为主键)</li>
</ul>
</li>
</ul>
<h3 id="3，char-M-是否是变长字段-看字符集"><a href="#3，char-M-是否是变长字段-看字符集" class="headerlink" title="3，char(M)是否是变长字段(看字符集)"></a>3，char(M)是否是变长字段(看字符集)</h3><ul>
<li>M代表字符数，字符不够会用空格填充</li>
<li>如果字符集中，每个字符都是一样的字节数，那么总的字节数是不会变的，就不是变长字段</li>
<li>如果字符集中，存在不同的字节数的字符，例如utf8-mb4,那么无法确定最后的字节数，就是变长字段</li>
<li>char使用空格占位，实际是用少量的空间，减小了产生内存碎片的概率：当char字段的值，在M个字符内变化时，复用原本的内存空间就可以，假如没有占位，char字段的每次增加</li>
</ul>
<h3 id="4，varchar-M-中的M可以无限大吗-不行"><a href="#4，varchar-M-中的M可以无限大吗-不行" class="headerlink" title="4，varchar(M)中的M可以无限大吗(不行)"></a>4，varchar(M)中的M可以无限大吗(不行)</h3><ul>
<li>M指的字符数</li>
<li>mysql规定每条记录，除隐藏列外，其余所有字段值加起来的大小不能超过65535字节</li>
<li>M的最大值除了和该varchar列值的大小有关，还和字符集最大字符所需的字节数有关，规定65535-其他字段长度，再除字符集最大字符长度，可以获得M允许的最大值，超过这个值在定义表结构会报错</li>
</ul>
<h3 id="5，列溢出"><a href="#5，列溢出" class="headerlink" title="5，列溢出"></a>5，列溢出</h3><ul>
<li>指的是变长字段长度过大，无法保证MySQL规定的每页至少存下两条记录的规定，就会把该字段值的一部分存到其他页中，并记录指针</li>
<li>compact格式会在原字段值的位置，存768字节的数据+存到其它页的数据的指针</li>
<li>dynamic格式，只会在原字段值的位置存指针，所有数据放到其它页中</li>
</ul>
<h3 id="6，引擎的默认行格式"><a href="#6，引擎的默认行格式" class="headerlink" title="6，引擎的默认行格式"></a>6，引擎的默认行格式</h3><ul>
<li>MyISAM使用的compact</li>
<li>innodb使用的dynamic</li>
<li>区别就是compact列溢出时会保留768字节到原字段值的位置</li>
</ul>
<h2 id="页格式"><a href="#页格式" class="headerlink" title="页格式"></a>页格式</h2><h3 id="1，页的组成"><a href="#1，页的组成" class="headerlink" title="1，页的组成"></a>1，页的组成</h3><ul>
<li>文件头：存放的是每个类型的页的通用的东西<ul>
<li>页号</li>
<li>上下页指针：双向链表连接同层级每一页</li>
<li>页所属表空间</li>
<li>页类型：索引用的是索引页，也叫数据页</li>
<li>检验和：用于和文件尾的检验和配合，判断是否是完整的页</li>
</ul>
</li>
<li>页头：记录页的状态<ul>
<li>当前页的页目录的槽的数量</li>
<li>未分配的空间最小地址，是下次分配的起始点</li>
<li>当前记录数量，包括最大最小和已删除的</li>
<li>页中第一个被删除的记录的地址，作为删除链表的头节点</li>
<li>暂未使用的，待更新(TODO)</li>
</ul>
</li>
<li>用户记录：页内单链表连接</li>
<li>空闲空间</li>
<li>页目录：存的是分组后的存放着最大索引列的记录的偏移地址，根据该记录的偏移地址可以获取记录的索引列的值，来完成2分法操作判断要查找的数据在哪个组</li>
<li>文件尾：检验和，配合文件头<ul>
<li>假如检验和前后不相同，说明页是错的，可能只刷新了一般就被打断了</li>
</ul>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="1，innodb的聚簇索引"><a href="#1，innodb的聚簇索引" class="headerlink" title="1，innodb的聚簇索引"></a>1，innodb的聚簇索引</h3><ul>
<li>聚簇索引，是b+树结构，叶子节点是有完整数据的数据页</li>
<li>同一层级，页中的数据按照主键大小排，页中的记录会被分组，最小记录单独一组，中间记录4-8条一组，含有最大记录可以1-8条一组；每组最后一条的偏移地址存在数组中，供查找的时候二分法找到组，然后遍历组中的记录即可</li>
<li>非叶子节点存的是数据项记录，每一条数记录指向一个页，记录的内容是主键+下一层级页号+下一级页中记录的最小主键值；因为在叶子节点非常多的时候，先找到页才能进入页使用二分法，找页只能双向链表遍历，因此，使用页中的数据项记录指向叶子节点，可以利用数据项页中使用2分法找到记录，然后去找记录对应的页号，这样就使用2分法替换了链表遍历</li>
</ul>
<h3 id="2，二级索引"><a href="#2，二级索引" class="headerlink" title="2，二级索引"></a>2，二级索引</h3><ul>
<li>二级索引的叶子节点中的记录内容是索引列+主键，先查出主键再利用主键回表去聚簇索引获取完整数据</li>
<li>二级索引的非叶子节点记录内容是索引列+主键+下一层级页号+下一级页的记录的最小值，如果索引列相同，将会用主键来决定顺序</li>
<li>每一层级整体都是按照索引列来排的，相同时才会使用主键</li>
</ul>
<h3 id="3，联合索引"><a href="#3，联合索引" class="headerlink" title="3，联合索引"></a>3，联合索引</h3><ul>
<li>使用多个列联合成一个索引</li>
<li>叶子节点记录内容是所有的索引列+主键</li>
<li>非叶子节点记录的内容是所有的索引列+主键+下一级页号对应的页的最小索引列值；这里的索引列规则是，从左到右判断</li>
</ul>
<h3 id="4，MyISAM的索引"><a href="#4，MyISAM的索引" class="headerlink" title="4，MyISAM的索引"></a>4，MyISAM的索引</h3><ul>
<li>每条记录挨个存到一个文件中，记录中存储在文件中的偏移值</li>
<li>b+树记录中叶子节点存的是索引列加索引列对应的偏移地址，相当于全部都是innodb的二级索引，查到后根据偏移地址来进行查询，查询是随机存取的，这一步很快</li>
</ul>
<h3 id="5，添加和删除索引"><a href="#5，添加和删除索引" class="headerlink" title="5，添加和删除索引"></a>5，添加和删除索引</h3><ul>
<li>添加<ul>
<li>在创建表结构时，index idx_xxx(列)</li>
<li>创建完表后，alter table 表名 add index idx_xxx(列)</li>
</ul>
</li>
<li>删除<ul>
<li>alter table 表名 drop index 索引名</li>
</ul>
</li>
</ul>
<h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><h3 id="1，什么情况可以用到索引"><a href="#1，什么情况可以用到索引" class="headerlink" title="1，什么情况可以用到索引"></a>1，什么情况可以用到索引</h3><ul>
<li>索引里的数据是有序的，主要是通过多个2分查找快速获取想要的记录集：</li>
<li>全值匹配时：查询的条件一一对应索引列，&#x3D;号连接<ul>
<li>先用第一个条件2分查到满足第一个条件的所有记录</li>
<li>在满足第一个条件的记录中，2分查找满足第二个条件的记录</li>
<li>由于查每个条件的时候，对于这个条件的列来说，数据都是有序的，所以每次查询都是用2分法，也就是使用了索引</li>
</ul>
</li>
<li>匹配左边的列：对于联合索引来说，索引是按照左到右的索引顺序排序的，左同按右排，因此在查询是，遵循从左到右查即可保证每次查之前的数据都是有序的<ul>
<li>不能跳过中间列，跳过后，后面的列不能用索引，因为要保证左边列相同右边才会有序</li>
</ul>
</li>
<li>匹配字符串列的前缀：字符串类型的每一个字符都满足左边先排序，左边相等右边再排序，因此在模糊查询的时候，使用xx%才可以使用索引快速查找</li>
<li>匹配范围值：只有第一个条件用到索引，因为第一个条件查询结果是一个范围，只有在值一样时第二个条件才有序，范围里的值不一样</li>
<li>排序：和联合索引的使用一样，符合联合索引的排序，结果就是联合索引本身，不需要计算，注意联合索引的列的值都是升序的，排序要么全升序，要么全降序(把从链表顺序读到的值反着放就好)</li>
<li>分组：也是利用联合索引，每个相同的条件为一组，如果分组条件满足联合索引，那么分组后的每一个组在索引中都是相邻的，直接拿就可以</li>
</ul>
<p>总结：</p>
<ul>
<li>在每一步查询之前，如果查询的目标(数据集)是按查询条件排序的，那就可以用索引，例如，用name作为条件查之前，先看数据是否是按name排好序的，是的话就可以用2分法，也就是用索引</li>
<li>索引的列只能是原始列，不可以是表达式和函数式，否则失效，会拿着表达式或者函数式整体去作条件，而不是索引列</li>
<li>回表的代价很高，通过主键回表，但是主键在二级索引中是无序的，也就是说通过主键在聚簇索引查，分布不均在很多页中，页是内存io基本单位，就会发生多次io；因此，mysql优化器会判断回表数量对效率的影响来使用全表查询还是二级索引加回表的方案；排序用的是联合索引，最好使用limit减少数据结果集来降低回表次数</li>
</ul>
<h3 id="2，建立索引的规范"><a href="#2，建立索引的规范" class="headerlink" title="2，建立索引的规范"></a>2，建立索引的规范</h3><ul>
<li>经常作为查询条件的列</li>
<li>用于排序和分组的列</li>
<li>列基数大的列(相同的值少)</li>
<li>建立索引的列尽量小</li>
<li>字符串作索引列时，如果值很长，使用前几位建立索引就好，索引查询到一个范围后遍历</li>
<li>使用自增主键可以明显减少页分裂</li>
<li>使用覆盖索引可以不用回表操作</li>
<li>联合索引经常会和其他建的索引冗余，为主键建立其他索引会导致重复</li>
</ul>
<h2 id="3，索引的代价"><a href="#3，索引的代价" class="headerlink" title="3，索引的代价"></a>3，索引的代价</h2><ul>
<li>更大的磁盘空间占用</li>
<li>每次增删改都会更新索引，增删可能还会导致页分裂，效率降低</li>
</ul>
<h2 id="单表访问"><a href="#单表访问" class="headerlink" title="单表访问"></a>单表访问</h2><h3 id="1，访问方法"><a href="#1，访问方法" class="headerlink" title="1，访问方法"></a>1，访问方法</h3><ul>
<li>const<ul>
<li>指的是使用聚簇索引和唯一二级索引做等值查询，(唯一的联合索引需要每一个列都等值)，不包括唯一索引使用null作条件的查询，因为唯一索引的null可能会有多个</li>
<li>总之就要保证查询的结果是一行数据</li>
</ul>
</li>
<li>ref<ul>
<li>使用二级索引进行等值查询的时候，但是必须保证在使用联合索引时，左边列是等值</li>
<li>const使用null作查询，实际上会使用ref方式</li>
</ul>
</li>
<li>ref or null<ul>
<li>在使用二级索引等值查询之外，还顺带查出所有的值为null的记录</li>
<li>例如，name&#x3D;’张三’ or name IS NULL</li>
</ul>
</li>
<li>range<ul>
<li>可以把ref获得的结果叫做单点范围，因为范围的值都是一样的；如果有多个单点范围，或者有连续范围(范围内有不相同的值)，使用的查询方法将会是range</li>
</ul>
</li>
<li>index<ul>
<li>不满足索引使用条件时可能使用</li>
<li>如果需要的结果列，查询条件列都包含在某个二级索引里，可以遍历二级索引的叶子结点，判断是否满足条件，满足则取出结果列，不需要会标</li>
<li>对比直接聚簇索引全表扫描，二级索每条记录的内容更少，遍历成本低</li>
</ul>
</li>
<li>all<ul>
<li>聚簇索引全表扫描</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2024/12/07/mybatis/</url>
    <content><![CDATA[<p>mybatis配置文件</p>
<ul>
<li><p>配置环境，数据源：environments&lt;environment标签</p>
</li>
<li><p>配置mapper文件的位置 ：mappers&lt;mapper标签</p>
<ul>
<li>按包扫描mapper文件时mappers&lt;package name&#x3D;，xml的名字还起着和mapper接口对应的作用，所以在使用时要注意：<ul>
<li>1，mapper文件放的层级和mapper接口的层级一样,也就是包一致</li>
<li>2，mapper文件的名字和接口名一致</li>
</ul>
</li>
</ul>
</li>
<li><p>配置properties文件的位置，引用使用${}：properties标签</p>
</li>
<li><p>设置类型别名typeAlias&lt;typeAlia type&#x3D;;alias&#x3D;;可以有效避免由于resultType需要的全限定名过长难写的问题，别名不区分大小写</p>
<ul>
<li>除了上面为单个类设置别名的方式，还可以指定某个包所有类以类名为别名，不区分大小写typealais&lt;package name&#x3D;；</li>
</ul>
</li>
</ul>
<p>mybatis mapper文件和接口的对应</p>
<ul>
<li>一张表，对应一个mapper接口，对应一个mapper文件，对应一个实体类</li>
<li>mapper接口对应mapper文件的命名空间</li>
<li>mapper接口的方法，对应mapper文件的sql id</li>
</ul>
<p>接口中的参数如何传递到sql语句？</p>
<ul>
<li>${},#{}</li>
<li>单个字面量的传递，大括号随便填就可以</li>
<li>多个字面量，mybatis会存到一个map中，默认的键是arg0，arg1····，或者param0，param1···；值就是参数顺序的参数值<ul>
<li>获取的时候，直接大括号里写arg0或param0这种就可以获取到值了</li>
</ul>
</li>
<li>多个字面量，为避免使用默认的arg0这种键，可以先在service把参数手动打包成map，再直接传入map类型的参数<ul>
<li>这样获取的时候，就可以通过大括号中写自己定义的键获取自己定义的值</li>
</ul>
</li>
<li>多个字面量，可以使用@Param注解，给每个参数指定mybatis存储的键<ul>
<li>大括号里填注解指定的键可以获取值</li>
</ul>
</li>
<li>对象类性，mybatis自动使用属性的名字为键，属性值为值，创建map<ul>
<li>大括号填属性名即可</li>
</ul>
</li>
</ul>
<p>结论：参数的获取实际上和接口方法声明的参数名没有关系</p>
<p>结果集如何指定返回格式？</p>
<ul>
<li>单条数据用对象接收，或者用map(接口和resultType都是)，key是属性名，v是值</li>
<li>多条在接口用List接收，resulttype是list元素类型</li>
<li>多条也可以用map接收，必须接口@MapKey()指定map的key，每一条记录的json作为v；或者直接使用map列表，返回多个map</li>
</ul>
<p>默认使用#{}，什么时候只能用${}？</p>
<ul>
<li><p>主要是有没有单引号的关系</p>
</li>
<li><p>模糊查询，使用like ‘%${}%’;like “%”#{}”%”;like concat(‘%’,#{},’%’)</p>
</li>
<li><p>批量删除使用了in，in ${ids},#{}会为每个id加单引号，执行没结果</p>
</li>
<li><p>动态表名使用参数作为表名，表名是不可以有单引号的</p>
</li>
</ul>
<p>如何同时修改有关联的两张表？</p>
<p>例子：往班级表插入一个班级，分配一些学生(把学生的班级改为插入的班级)</p>
<p>步骤：</p>
<ul>
<li>插入班级</li>
<li>查询该班级的自增id(插入之前这个值是空，自动生成的)，所以必须查</li>
<li>根据条件获取一部分学生，更改他们的班级id</li>
</ul>
<p>优化：在插入后自动回调将id返回给对象</p>
<ul>
<li>设置insert标签参数，useGeneratedKeys&#x3D;”true”,keyProperty&#x3D;”id”(对象的自增主键属性名)</li>
<li>在执行insert之后，再去看传入的班级对象参数，已经把id属性设置成了插入了的班级的id</li>
<li>直接用这个id修改学生班级id</li>
</ul>
<p>字段名和属性名不同咋办？</p>
<ul>
<li>设置underScoreToCamelCase完成下划线和驼峰转换</li>
<li>在sql语句查询的时候为字段设置别名</li>
<li>@TableField(“user_name”)注解在实体类属性上，和表字段对应</li>
<li>使用resultmap</li>
</ul>
<p>1对多咋办？</p>
<p>例子，一个班级对应多个学生，在班级类应当有一个list<student>属性，难以对此属性赋值，因为要通过班级id关联查询</p>
<ul>
<li>使用collection标签，记忆：集合属性用collection标签</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;classAndStudentResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Class&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;className&quot;</span> <span class="attr">column</span>=<span class="string">&quot;class_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    再封装学生列表，指定list属性名，指定list元素类型</span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;student_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用分步操作+懒加载</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag">		</span></span><br><span class="line"><span class="tag">      <span class="attr">指定第二步对应的接口</span>          <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">指定第二步接口需要的参数</span></span></span><br><span class="line"><span class="tag">				<span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line">第二步</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>多对一呢？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分步</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结，多对一和一对多都是通过级联查询，第一次只查出了某个属性的一部分，必须把手动第二部分的东西封装到属性里</p>
<p>动态sql标签</p>
<ul>
<li>使用if来判断条件是否满足</li>
<li>使用where来自动生成where，并且自动清除sql前部分的and和or，注意后部分不能去除</li>
</ul>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><ul>
<li>1，作用范围：<ul>
<li>一级缓存是SQL session级别的，默认开启，同一个SQL session内相同的sql语句将会使用缓存而不是查询数据库</li>
</ul>
</li>
<li>2,如何开启：<ul>
<li>自动开启</li>
</ul>
</li>
<li>3，缓存有效使用的条件：<ul>
<li>同一个SQL session下操作</li>
<li>一模一样的sql语句</li>
<li>查询之间没有经历过增删改操作，增删改操作会导致数据库的内容和缓存的内容不一样，mybatis会直接删除缓存</li>
<li>查询之间没有手动调用清理方Sqlsession.clearCatch()</li>
</ul>
</li>
</ul>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><ul>
<li><p>1，作用范围</p>
<ul>
<li>二级缓存是namespace级别的，一般一个mapper接口对应一个mapper文件对应一个namespace</li>
</ul>
</li>
<li><p>2，开启过程</p>
<ul>
<li><p>全局设置中&lt;setting name&#x3D;”cacheEnabled” value&#x3D;”true”&#x2F;&gt;,默认就是true，可以不用手动设置该选项</p>
</li>
<li><p>在要开启的namespace中使用catche标签配置</p>
</li>
<li><pre><code class="xml">&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;
    &lt;!-- 配置二级缓存 --&gt;
    &lt;cache 
        eviction=&quot;LRU&quot; 
        flushInterval=&quot;60000&quot; 
        size=&quot;512&quot; 
        readOnly=&quot;true&quot;/&gt;
    &lt;!-- SQL语句 --&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li><p>表对应的java实例对象要实现序列化接口并设置版本号，因为可能有持久化到磁盘</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>优先准备</title>
    <url>/2024/11/29/%E4%BC%98%E5%85%88%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="1，get-和-post请求的区别"><a href="#1，get-和-post请求的区别" class="headerlink" title="1，get 和 post请求的区别"></a>1，get 和 post请求的区别</h3><h4 id="延申：弄清楚http种常用不同请求的区别"><a href="#延申：弄清楚http种常用不同请求的区别" class="headerlink" title="延申：弄清楚http种常用不同请求的区别"></a>延申：弄清楚http种常用不同请求的区别</h4><ul>
<li>get：<ul>
<li>参数显示在地址栏，不安全，参数有长度限制，常用于获取资源，幂等</li>
</ul>
</li>
<li>post：<ul>
<li>参数放在请求体，也需要对参数加密，长度无限制，常用于增删改资源，不幂等</li>
</ul>
</li>
<li>put：<ul>
<li>参数放请求体，用于更新</li>
</ul>
</li>
<li>delete：<ul>
<li>参数放请求头，用于删除指定位置的资源</li>
</ul>
</li>
<li>head</li>
</ul>
<h3 id="2，面向对象三个基本特征"><a href="#2，面向对象三个基本特征" class="headerlink" title="2，面向对象三个基本特征"></a>2，面向对象三个基本特征</h3><ul>
<li>封装：把类的属性私有，避免外部直接访问，提高程序安全性</li>
<li>继承：子类可以继承父类的变量和方法，复用代码的手段</li>
<li>多态：同一操作对于不同的对象有不同的解释，由重载和重写实现<ul>
<li>重载：同一个类中同名不同参数的方法</li>
<li>重写：子类重写父类方法提供子类的实现</li>
</ul>
</li>
</ul>
<h3 id="3，-和equals的区别"><a href="#3，-和equals的区别" class="headerlink" title="3，&#x3D;&#x3D;和equals的区别"></a>3，&#x3D;&#x3D;和equals的区别</h3><ul>
<li>&#x3D;&#x3D;可以作用与基本数据类型和引用类型<ul>
<li>基本数据类型，比较的是值是否相等</li>
<li>引用类型，比较的是对象的地址是否相等，无关对象内的内容</li>
</ul>
</li>
<li>equals只能作用于引用类型<ul>
<li>在不重写的情况下，方法内使用的是&#x3D;&#x3D;来判断</li>
</ul>
</li>
<li>注意：<ul>
<li>在使用对象当hashmap的key时：重写equals方法必须要重写hashcode方法，要保证对象相等的时候hashcode必须相同</li>
<li>原因：在hashmap中先根据hashcode计算桶，再根据equals判断是否是重复的key；假如equals成立(对象相同)，hashcode却不同，则hash冲突不会发生，equals方法不会被触发，造成相同的两个对象会被hash到不同的桶里，不符合hashmap key不重复的设计</li>
</ul>
</li>
</ul>
<h3 id="4，-和-，-和"><a href="#4，-和-，-和" class="headerlink" title="4，&amp;和&amp;&amp;，|和||"></a>4，&amp;和&amp;&amp;，|和||</h3><ul>
<li><p>A&amp;B：先判断A，再判断B是否true</p>
</li>
<li><p>A&amp;&amp;B：先判断A，如果A为false那么B直接不用判断，结果肯定为false，减少了一次判断</p>
</li>
<li><p>II和&amp;&amp;思路一样，短路系列前面能出结果那么后面的就不判断直接获得结果</p>
</li>
</ul>
<h3 id="5-stringbuilder-string-stringbuffer的区别"><a href="#5-stringbuilder-string-stringbuffer的区别" class="headerlink" title="5,stringbuilder,string,stringbuffer的区别"></a>5,stringbuilder,string,stringbuffer的区别</h3><ul>
<li>string：不可变，每一次操作都返回一个新的对象</li>
<li>stringbuilder：可变</li>
<li>stringbuffer：同步的stringbuilder</li>
</ul>
<h3 id="6，重载和重写的区别"><a href="#6，重载和重写的区别" class="headerlink" title="6，重载和重写的区别"></a>6，重载和重写的区别</h3><ul>
<li>重载：同名方法，返回类型不限制，参数不同，可以是数量，类型，顺序不同，访问修饰符大于等于父类</li>
<li>重写：同名方法，参数相同，返回值不限制，修饰符大于等于父类</li>
</ul>
<h3 id="7-用过哪些集合"><a href="#7-用过哪些集合" class="headerlink" title="7,用过哪些集合"></a>7,用过哪些集合</h3><ul>
<li>arraylist</li>
<li>hashset</li>
<li>hashmap</li>
</ul>
<h3 id="8，list，set，map的区别"><a href="#8，list，set，map的区别" class="headerlink" title="8，list，set，map的区别"></a>8，list，set，map的区别</h3><ul>
<li>list和set继承自collection接口，map是另外的接口</li>
<li>list是有序线性的，set是无序线性的，map是无序kv结构</li>
</ul>
<h3 id="9，了解过的线程安全的集合"><a href="#9，了解过的线程安全的集合" class="headerlink" title="9，了解过的线程安全的集合"></a>9，了解过的线程安全的集合</h3><ul>
<li>hashtable，concurrenthashmap</li>
<li>copyonwritearraylist</li>
</ul>
<h3 id="10-hashmap的put原理？为什么hashmap容量设计成2的n次方"><a href="#10-hashmap的put原理？为什么hashmap容量设计成2的n次方" class="headerlink" title="10.hashmap的put原理？为什么hashmap容量设计成2的n次方"></a>10.hashmap的put原理？为什么hashmap容量设计成2的n次方</h3><ul>
<li>计算桶：(h^(h&gt;&gt;16))&amp;(table.length-1)</li>
<li>hash冲突了则去冲突的链表或者红黑树使用equals比较，不重复就插入到链表或者红黑树</li>
<li>容量设置2的n次方主要用于扩容减少计算量，table的长度*2，只需要判断多出来的那一位高位对应的(h^(h&gt;&gt;16))的值的那一位是1还是0，是1，&amp;后的结果就是1，就需要把桶的结果乘2得到新的桶，是0，&amp;的结果是0，桶的位置不变，；</li>
</ul>
<h3 id="11，arraylist和linkedlist的区别"><a href="#11，arraylist和linkedlist的区别" class="headerlink" title="11，arraylist和linkedlist的区别"></a>11，arraylist和linkedlist的区别</h3><ul>
<li>arraylist底层是数组，适合查询多，增删少的场景，查询可以根据下标</li>
<li>linkedlist底层使用的是双向链表，适合增删多的场景，查询只能遍历</li>
</ul>
<h3 id="12，throw和throws的区别"><a href="#12，throw和throws的区别" class="headerlink" title="12，throw和throws的区别"></a>12，throw和throws的区别</h3><ul>
<li>throws作用与方法，往外抛出异常</li>
<li>throw 是抛出异常</li>
</ul>
<h3 id="13，接口和抽象类的区别"><a href="#13，接口和抽象类的区别" class="headerlink" title="13，接口和抽象类的区别"></a>13，接口和抽象类的区别</h3><ul>
<li>一个类可以实现多个接口，但是只能继承一个父类</li>
<li>接口中只有方法声明，没有具体实现；抽象类可以有抽象方法，也可以有实现的犯法</li>
</ul>
<h3 id="14，去阿里巴巴手册看几个代码规范"><a href="#14，去阿里巴巴手册看几个代码规范" class="headerlink" title="14，去阿里巴巴手册看几个代码规范"></a>14，去阿里巴巴手册看几个代码规范</h3><ul>
<li>类名使用大驼峰命名，方法名和变量统一使用小驼峰</li>
<li>在关键的类，方法，参数等地方写注释</li>
<li>在捕获异常的时候，细分异常类型</li>
<li>创建线程池的时候，不要使用Executors工具类，使用threadpoolexecutor的构造方法</li>
</ul>
<h3 id="15，创建对象的三种方式"><a href="#15，创建对象的三种方式" class="headerlink" title="15，创建对象的三种方式"></a>15，创建对象的三种方式</h3><ul>
<li>new对象</li>
<li>使用反射创建</li>
<li>通过反序列化创建</li>
</ul>
<h3 id="16，如何通过反射创建对象"><a href="#16，如何通过反射创建对象" class="headerlink" title="16，如何通过反射创建对象"></a>16，如何通过反射创建对象</h3><ul>
<li>先获取类的入口class类：class.forName(全限定名)</li>
<li>再获取类的构造方法</li>
<li>执行构造方法即可</li>
</ul>
<h3 id="17，反射的使用场景是什么"><a href="#17，反射的使用场景是什么" class="headerlink" title="17，反射的使用场景是什么"></a>17，反射的使用场景是什么</h3><ul>
<li>spring中使用</li>
</ul>
<h3 id="18，反射的优缺点是什么"><a href="#18，反射的优缺点是什么" class="headerlink" title="18，反射的优缺点是什么"></a>18，反射的优缺点是什么</h3><ul>
<li>优点：在程序运行的时候可以动态的创建对象</li>
<li>缺点：性能比较低</li>
</ul>
<h3 id="19，掌握几个IO的常用类"><a href="#19，掌握几个IO的常用类" class="headerlink" title="19，掌握几个IO的常用类"></a>19，掌握几个IO的常用类</h3><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1，线程和进程的区别"><a href="#1，线程和进程的区别" class="headerlink" title="1，线程和进程的区别"></a>1，线程和进程的区别</h3><ul>
<li>进程是计算机进行资源分配的基本单位，线程是计算机调度的基本单位</li>
<li>进程拥有独立的内存空间，io资源；线程共享同进程的内存空间和io资源</li>
<li>进程的上下文切换开销大，且进程之间的通信很麻烦；线程的上下文切换开销小，只需要记录寄存器和线程私有的东西，操作数栈，局部变量表</li>
</ul>
<h3 id="2，线程有几种创建方式，区别是什么"><a href="#2，线程有几种创建方式，区别是什么" class="headerlink" title="2，线程有几种创建方式，区别是什么"></a>2，线程有几种创建方式，区别是什么</h3><ul>
<li>3种：<ul>
<li>继承Thread类，重写run方法，调用对象的start方法即可创建一个线程</li>
<li>实现runnable接口，重写run方法，把runnable作为Thread类的构造参数,调用对象的start方法即可创建一个线程</li>
<li>实现callable接口，重写call方法，交给线程池的submit方法执行，返回一个futrue对象，调用futrue.get即可阻塞当前直到获取该callable的返回值</li>
</ul>
</li>
<li>区别：<ul>
<li>继承thread比较方便，但是java只能单继承，不灵活；run方法不支持返回值</li>
<li>实现runnable解决了继承不灵活的问题，但是也不支持返回值</li>
<li>callable配合线程池可以获取返回值，callable是接口也比较灵活</li>
</ul>
</li>
</ul>
<h3 id="3，线程的几种状态"><a href="#3，线程的几种状态" class="headerlink" title="3，线程的几种状态"></a>3，线程的几种状态</h3><ul>
<li>ready：还没有调用start方法之前</li>
<li>runnable：运行</li>
<li>waiting：等待，object.wait，</li>
<li>timedwaiting：超时等待</li>
<li>blocked：阻塞</li>
<li>terminal：终止</li>
</ul>
<h3 id="4，线程池的7大参数"><a href="#4，线程池的7大参数" class="headerlink" title="4，线程池的7大参数"></a>4，线程池的7大参数</h3><ul>
<li>核心线程数</li>
<li>最大线程数</li>
<li>非核心线程过期时间</li>
<li>时间单位</li>
<li>阻塞队列</li>
<li>拒绝策略</li>
<li>线程工厂</li>
</ul>
<h3 id="5，线程池工作原理"><a href="#5，线程池工作原理" class="headerlink" title="5，线程池工作原理"></a>5，线程池工作原理</h3><ul>
<li>先加入核心线程数</li>
<li>核心线程不够在看最大线程</li>
<li>最大线程不够在看阻塞队列够不够</li>
<li>阻塞队列不够看拒绝策略</li>
</ul>
<h3 id="6，阻塞队列有哪些，拒绝策略有哪些"><a href="#6，阻塞队列有哪些，拒绝策略有哪些" class="headerlink" title="6，阻塞队列有哪些，拒绝策略有哪些"></a>6，阻塞队列有哪些，拒绝策略有哪些</h3><ul>
<li>阻塞队列：</li>
<li>拒绝策略：<ul>
<li>丢弃</li>
<li>报错</li>
<li>丢弃最老任务</li>
<li>用户线程执行</li>
</ul>
</li>
</ul>
<h3 id="7，线程池submit和execute方法的区别"><a href="#7，线程池submit和execute方法的区别" class="headerlink" title="7，线程池submit和execute方法的区别"></a>7，线程池submit和execute方法的区别</h3><ul>
<li>execute没有返回值，只能接受一个个runnable参数，创建的线程内部出现异常，在线程内处理，不会返回到创建线程的线程</li>
<li>submit返回一个futrue，可以接受runnable和callable，接收runnable时返回null，线程出现异常会由future.get抛出，放到try catch可以捕获异常</li>
</ul>
<h3 id="8，公司使用的线程池，参数怎么设置，设置的依据"><a href="#8，公司使用的线程池，参数怎么设置，设置的依据" class="headerlink" title="8，公司使用的线程池，参数怎么设置，设置的依据"></a>8，公司使用的线程池，参数怎么设置，设置的依据</h3><h3 id="9，为什么不能使用Executors自带的线程池"><a href="#9，为什么不能使用Executors自带的线程池" class="headerlink" title="9，为什么不能使用Executors自带的线程池"></a>9，为什么不能使用Executors自带的线程池</h3><ul>
<li>参数写死，不能配置</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="1，事务的特性"><a href="#1，事务的特性" class="headerlink" title="1，事务的特性"></a>1，事务的特性</h3><ul>
<li>原子性</li>
<li>隔离性</li>
<li>持久性</li>
<li>一致性</li>
</ul>
<h3 id="2，事务的隔离级别，Mysql默认的隔离级别"><a href="#2，事务的隔离级别，Mysql默认的隔离级别" class="headerlink" title="2，事务的隔离级别，Mysql默认的隔离级别"></a>2，事务的隔离级别，Mysql默认的隔离级别</h3><ul>
<li>隔离级别<ul>
<li>读未提交</li>
<li>读已提交</li>
<li>可重复读</li>
<li>序列化运行</li>
</ul>
</li>
<li>mysql默认可重复读，通过mvcc实现，极端情况会出现幻影读问题</li>
</ul>
<h3 id="3，事务的传播行为"><a href="#3，事务的传播行为" class="headerlink" title="3，事务的传播行为"></a>3，事务的传播行为</h3><ul>
<li>require new</li>
<li>require</li>
</ul>
<h3 id="4-不同的隔离级别在两个事务中会出现什么问题"><a href="#4-不同的隔离级别在两个事务中会出现什么问题" class="headerlink" title="4,不同的隔离级别在两个事务中会出现什么问题"></a>4,不同的隔离级别在两个事务中会出现什么问题</h3><ul>
<li>脏读 读未提交，读到还没有提交的事务写入的值</li>
<li>不可重复读 读已提交，同一个事务中，同一条sql读取出的结果不一样(修改)</li>
<li>幻影读 同一个事务中，同一个读取范围，读取出的条数不一样，(插入，删除)</li>
</ul>
<h3 id="5，sql调优流程举例，explain关键字的使用"><a href="#5，sql调优流程举例，explain关键字的使用" class="headerlink" title="5，sql调优流程举例，explain关键字的使用"></a>5，sql调优流程举例，explain关键字的使用</h3><p>+ </p>
<h3 id="6，b树和b-树的区别，为什么用b-树而不是b树"><a href="#6，b树和b-树的区别，为什么用b-树而不是b树" class="headerlink" title="6，b树和b+树的区别，为什么用b+树而不是b树"></a>6，b树和b+树的区别，为什么用b+树而不是b树</h3><h3 id="7，索引失效的情况"><a href="#7，索引失效的情况" class="headerlink" title="7，索引失效的情况"></a>7，索引失效的情况</h3><ul>
<li>使用了聚合函数</li>
<li>没有按最左的标准查</li>
</ul>
<h3 id="8，建立索引的依据"><a href="#8，建立索引的依据" class="headerlink" title="8，建立索引的依据"></a>8，建立索引的依据</h3><ul>
<li>经常查找的列</li>
<li>不经常修改的列</li>
<li>经常用于排序，分组的列</li>
<li>经常用于连接的列</li>
</ul>
<h3 id="9，Mysql最多创建多少个索引"><a href="#9，Mysql最多创建多少个索引" class="headerlink" title="9，Mysql最多创建多少个索引"></a>9，Mysql最多创建多少个索引</h3><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><h3 id="1，什么是aop和ioc"><a href="#1，什么是aop和ioc" class="headerlink" title="1，什么是aop和ioc"></a>1，什么是aop和ioc</h3><h3 id="2，ioc的好处是什么"><a href="#2，ioc的好处是什么" class="headerlink" title="2，ioc的好处是什么"></a>2，ioc的好处是什么</h3><h3 id="3，aop有几种代理方式，有什么区别，默认哪种"><a href="#3，aop有几种代理方式，有什么区别，默认哪种" class="headerlink" title="3，aop有几种代理方式，有什么区别，默认哪种"></a>3，aop有几种代理方式，有什么区别，默认哪种</h3><ul>
<li>cglib：继承至原始类</li>
<li>jdk：实现原始类实现的接口，必须要原始类有接口</li>
<li>默认cglib</li>
</ul>
<h4 id="4，用到aop的地方"><a href="#4，用到aop的地方" class="headerlink" title="4，用到aop的地方"></a>4，用到aop的地方</h4><ul>
<li>日志，事务</li>
</ul>
<h3 id="5，-autowired和-resource的区别"><a href="#5，-autowired和-resource的区别" class="headerlink" title="5，@autowired和@resource的区别"></a>5，@autowired和@resource的区别</h3><h3 id="6，bean的作用域"><a href="#6，bean的作用域" class="headerlink" title="6，bean的作用域"></a>6，bean的作用域</h3><ul>
<li>singleton</li>
<li>prototype</li>
<li>request</li>
<li>session</li>
</ul>
<h3 id="7，spring自动装配有哪几种，有什么区别"><a href="#7，spring自动装配有哪几种，有什么区别" class="headerlink" title="7，spring自动装配有哪几种，有什么区别"></a>7，spring自动装配有哪几种，有什么区别</h3><ul>
<li>@Autowired，按类型装配</li>
<li>@Resource，先按名字装配，没有再按照类型装配</li>
</ul>
<h3 id="8，spring事务注解里面的参数设置，默认的隔离级别"><a href="#8，spring事务注解里面的参数设置，默认的隔离级别" class="headerlink" title="8，spring事务注解里面的参数设置，默认的隔离级别"></a>8，spring事务注解里面的参数设置，默认的隔离级别</h3><h3 id="9，springmvc的请求流程"><a href="#9，springmvc的请求流程" class="headerlink" title="9，springmvc的请求流程"></a>9，springmvc的请求流程</h3><ul>
<li>dispatchServelet获取请求，进行转发</li>
<li>转发至handlermapping，根据传入的url寻找匹配的handler，返回执行链给dispatchservelet</li>
<li>转发给handleradopter，适配可以执行的controller对象，执行handler，返回modeandview，返回给dispatchservelet</li>
<li>转发给视图解析器解析视图，返回给dispatchservelet</li>
<li>返回http请求</li>
</ul>
<h3 id="10，-和-的区别"><a href="#10，-和-的区别" class="headerlink" title="10，#{}和${}的区别"></a>10，#{}和${}的区别</h3><ul>
<li>#{}是使用占位符，里面的东西会被视为 一个参数，自动加单引号，可以避免sql注入</li>
<li>${}是sql拼接，不会加单引号，会被sql注入</li>
</ul>
<h3 id="11，mybatis实体类的字段和表字段不一样怎么办"><a href="#11，mybatis实体类的字段和表字段不一样怎么办" class="headerlink" title="11，mybatis实体类的字段和表字段不一样怎么办"></a>11，mybatis实体类的字段和表字段不一样怎么办</h3><ul>
<li>使用mybatis的resultmap</li>
<li>在实体类的上面加上小驼峰和下划线转换的注解</li>
<li>在实体类的字段上利用@Colum注解来对应数据库中的字段名</li>
</ul>
<h3 id="12，xml文件id是否能够重复"><a href="#12，xml文件id是否能够重复" class="headerlink" title="12，xml文件id是否能够重复"></a>12，xml文件id是否能够重复</h3><h3 id="13，什么是一级和二级缓存，区别是什么，怎么开启"><a href="#13，什么是一级和二级缓存，区别是什么，怎么开启" class="headerlink" title="13，什么是一级和二级缓存，区别是什么，怎么开启"></a>13，什么是一级和二级缓存，区别是什么，怎么开启</h3><h3 id="14，springboot自动装配的原理"><a href="#14，springboot自动装配的原理" class="headerlink" title="14，springboot自动装配的原理"></a>14，springboot自动装配的原理</h3><h3 id="15，如何解决前端和服务器端跨域问题"><a href="#15，如何解决前端和服务器端跨域问题" class="headerlink" title="15，如何解决前端和服务器端跨域问题"></a>15，如何解决前端和服务器端跨域问题</h3><ul>
<li>再后端http返回的时候带上允许跨域的源</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1，单例，工厂，责任链，代理，模板方法模式（理解）"><a href="#1，单例，工厂，责任链，代理，模板方法模式（理解）" class="headerlink" title="1，单例，工厂，责任链，代理，模板方法模式（理解）"></a>1，单例，工厂，责任链，代理，模板方法模式（理解）</h3><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1，redis中常用的数据结构和区别"><a href="#1，redis中常用的数据结构和区别" class="headerlink" title="1，redis中常用的数据结构和区别"></a>1，redis中常用的数据结构和区别</h3><h3 id="2，redis数据结构使用场景举例"><a href="#2，redis数据结构使用场景举例" class="headerlink" title="2，redis数据结构使用场景举例"></a>2，redis数据结构使用场景举例</h3><ul>
<li>string，全局id</li>
<li>hash，对象</li>
<li>set，求交集，共同好友</li>
<li>zset，做排行榜</li>
<li>list，先进先出，做队列</li>
</ul>
<h3 id="3，redis和数据库的数据一致性"><a href="#3，redis和数据库的数据一致性" class="headerlink" title="3，redis和数据库的数据一致性"></a>3，redis和数据库的数据一致性</h3><ul>
<li>当更新请求打到数据库时，先更新数据库，再删除缓存</li>
<li>更新数据库的时候，先使用旧的缓存，会带来一段时间的不一致，无伤大雅</li>
<li>更新数据库和删除缓存应当是原子性的，且只有一个线程能运行，使用同步锁</li>
</ul>
<h3 id="4，缓存穿透，击穿，雪崩怎么处理"><a href="#4，缓存穿透，击穿，雪崩怎么处理" class="headerlink" title="4，缓存穿透，击穿，雪崩怎么处理"></a>4，缓存穿透，击穿，雪崩怎么处理</h3><ul>
<li>穿透：redis没有，MySQL也没有，导致无法建立缓存，攻击全部打数据库<ul>
<li>解决，redis和mysql都没有的时候，手动在redis创建一个空缓存，设置较短ttl，防止mysql在空缓存存在期间添加了后导致的不一致时间过长</li>
</ul>
</li>
<li>击穿：热点key过期时，大量的请求打到数据库<ul>
<li>解决，热点key不设置ttl，在java代码中设置逻辑过期时间，当过期后，先返回给旧值，同时创建一个线程去重建缓存</li>
</ul>
</li>
<li>雪崩：大量的key同时过期<ul>
<li>解决，同一时间上传的key应当设置不同时间的ttl，可以设置基准时间+随机时间</li>
</ul>
</li>
</ul>
<h3 id="5，redis持久化方式和区别"><a href="#5，redis持久化方式和区别" class="headerlink" title="5，redis持久化方式和区别"></a>5，redis持久化方式和区别</h3><ul>
<li>rdb快照：内存小，恢复快，间隔内的会丢失<ul>
<li>设置一段时间内修改多少次触发</li>
<li>也可以save手动触发，bgsave后台触发</li>
</ul>
</li>
<li>aof：存的是已经执行过的指令，内存大，恢复慢，间隔小，保存到文件，频繁io</li>
</ul>
<h3 id="6，redis内存溢出策略"><a href="#6，redis内存溢出策略" class="headerlink" title="6，redis内存溢出策略"></a>6，redis内存溢出策略</h3><ul>
<li>noeviction 不淘汰，内存满了有添加就报错，查询和删除可以正常使用</li>
<li>allkeys lru 淘汰最长时间没有访问过的key</li>
<li>allkeys lfu 淘汰访问频率最低的key</li>
<li>allkeys random 随机淘汰</li>
<li>volatile lru 定时key淘汰最长时间没访问的</li>
<li>volatile lfu 定时key中淘汰访问频率低的</li>
<li>volatile random 定时key随机淘汰</li>
<li>默认是noeviction</li>
</ul>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="1，linux常见指令，查看进程，内存占用，cpu使用，搜索关键字"><a href="#1，linux常见指令，查看进程，内存占用，cpu使用，搜索关键字" class="headerlink" title="1，linux常见指令，查看进程，内存占用，cpu使用，搜索关键字"></a>1，linux常见指令，查看进程，内存占用，cpu使用，搜索关键字</h3>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>重要</title>
    <url>/2024/11/17/%E9%87%8D%E8%A6%81/</url>
    <content><![CDATA[<p>1，通过合作第三方获取资讯</p>
<p>新浪，百度，UC等</p>
<p>2，通过广告微服务，远程rpc获取要插入资讯的广告</p>
<ul>
<li>广告表：广告id，广告位置，广告名称，广告类型，广告状态</li>
<li>类型<ul>
<li>sdk广告：由客户端直接请求</li>
<li>api广告：由后端请求</li>
</ul>
</li>
</ul>
<p>3，获取第三方广告需要的时间长，可以和获取资讯两个任务并发执行，利用future，并把结果存到一个map里</p>
<p>4，插入自己公司想插入的信息流，一般增删改查</p>
<p>5，在最后需要广告的时候，可以使用future.get等待500ms，之后把map的广告插进信息流，不管map里是否有四个</p>
<p>6，话术：</p>
<ul>
<li>用户反馈切换页面时相应时间长</li>
<li>组长分配需求</li>
<li>公司的运维开发的链路追踪工具，可以一层一层看出接口的耗时</li>
<li>同步请求uc资讯和4个广告，耗时3秒左右</li>
<li>引入多线程，异步并行获取广告，放进map里</li>
<li>最后需要广告时判断map是否有，没有的话使用futrue的get方法多等待500ms，还是没有直接放弃广告</li>
<li>优化后结果，获取资讯0.6秒，广告并发0.5秒，总共1秒左右</li>
</ul>
<p>7，项目书写</p>
<ul>
<li>负责日常需求的开发和迭代(新的第三方资讯引入，banner菜单开发，快应用菜单开发)<ul>
<li>就是写banner表单&#x2F;快应用表单，提交后载入到管理系统</li>
<li>快应用就是点击直达的应用推荐</li>
<li>第三方返回的资讯字段：标题，副标题，资讯url，资讯分类，作者，图片，图片类型，创建时间</li>
<li>使用工厂和模板方法，优化第三方资讯拉取的方法<ul>
<li>之前是写死uc的资讯</li>
<li>改为工厂模式通过渠道(入参)获取不同实例，不同实例实现统一接口也就是模板方法模式</li>
<li>模板方法用于封装资讯，因为不同渠道讯息关键字不同，要统一封装一层返回给前端<ul>
<li>注意要把工厂的实例注入到spring，之后在工厂里直接get，否则会导致aop失效</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>和uc对接：<ul>
<li>带着密钥和频道id访问uc的验证接口，获取到token（为什么要给一个方法给他们调用才能获取token，那边直接http返回不行吗），存到redis，token和此频道id一一对应</li>
<li>访问时从redis根据频道id取token，然后拿着频道id和token访问uc接口拿资讯</li>
<li>设置定时任务10分钟访问一次验证接口获取token(?，必要性？直接token过期后再请求不好吗)，当访问资讯接口显示token过期时，手动调用验证接口获取token，并刷新redis的频道id+token</li>
</ul>
</li>
<li>导入黑名单，从在用户手机上匹配，到在redis中匹配，减少了用户的内存压力(?资讯app中的黑名单作用是什么，是否是浏览器话术遗留)</li>
</ul>
<h3 id="问点解析"><a href="#问点解析" class="headerlink" title="问点解析"></a>问点解析</h3><h4 id="咨询获取"><a href="#咨询获取" class="headerlink" title="咨询获取"></a>咨询获取</h4><p>1，参数为渠道（区分），子渠道，密钥 请求uc的token；提供接口供uc调用，接口内容为把渠道，子渠道，子渠道对应的token，作为hash结构保存到redis；再通过渠道，子渠道，+token的方式去获取uc的资讯；</p>
<p>2，问题</p>
<ul>
<li>为什么要分两步？<ul>
<li>使用token对比直接使用密钥，提高了安全性</li>
</ul>
</li>
<li>token会变，变了怎么办<ul>
<li>token变了之后，用户访问时拉取资讯会504，当出现504时，重新访问请求token接口</li>
</ul>
</li>
<li>返回的参数？<ul>
<li>资讯标题，副标题，分类，标题，作者名称，发版时间，缩略图，图片类型，修改时间</li>
</ul>
</li>
<li>接口安全性保证<ul>
<li>约定算法，根据客户端的参数计算出一个sign值，前端带入参数+sign值；后端拿到参数计算sign值，一样就好</li>
<li>请求时间不超过5分钟</li>
<li>对参数进行数据加密，使用非堆成加密，客户端使用公钥对参数加密，服务端使用私钥对参数进行解密</li>
<li>使用https协议，了解https为什么安全</li>
<li>把大数据曝光前50的快应用，以及通过省份和分类区分前50的快应用，今年和去年减少量，这个月和上个月减少量；写进xml文件，打压缩包ftp发送到目录<ul>
<li>快应用是展示事件，展示给用户后存快应用包名，通过count能排序出前50</li>
</ul>
</li>
</ul>
</li>
<li>资讯拉取引入了什么设计模式？<ul>
<li>工厂模式+模板方法模式</li>
<li>之前同事对接时，写死了uc，现在改用模板方法模式，写一个抽象类，提供验证和获取资讯两个模板抽象方法</li>
<li>每个资讯方写一个类继承抽象类，实现方法，使用applicationcontext.getBeanOfType(抽象类.class);可以把抽象类的实现类全部按照类名驼峰加载到spring里面，还会返回一个map，k是名字，v是载入的bean，这样就形成一个工厂，传入参数这个map就可以根据k找到不同的实现类；</li>
<li>了解三个工厂的知识，还知道哪些设计模式？</li>
</ul>
</li>
</ul>
<h4 id="后台反馈内容显示刷新资讯耗时过长"><a href="#后台反馈内容显示刷新资讯耗时过长" class="headerlink" title="后台反馈内容显示刷新资讯耗时过长"></a>后台反馈内容显示刷新资讯耗时过长</h4><p>1，问题</p>
<ul>
<li>在哪里反馈？<ul>
<li>应用反馈，直接存到数据库，运营在后台可以看到</li>
</ul>
</li>
<li>拿到优化需求后，怎么定位问题？<ul>
<li>链路追踪工具：利用postman模拟刷新资讯的请求，通过公司的链路追踪工具可以看到具体接口的耗时，发现在资讯里面插入广告时耗时严重，rpc请求每一个广告的时间在0.8秒左右，请求15条资讯的接口只要0.6s</li>
</ul>
</li>
<li>怎么保证拉取的资讯不重复？<ul>
<li>uc在返回资讯的时候，资讯列表里加一个游标(可能是字符串)，后端收到后连带游标发给前端，前端再次发请求时也带上这个游标，作用是UC标记资讯返回到哪个位置，防止返回重复的资讯</li>
</ul>
</li>
<li>如何优化时间过长问题？<ul>
<li>背景：运营可能会配置0-4个广告不等，广告模块提供的接口是请求单个广告，当运营配置插入4条广告时，会请求0.8*4&#x3D;3.2秒左右，他和拉取资讯串行，0.6+3.2&#x3D;3.8秒</li>
<li>优化：利用多线程<ul>
<li>将拉取资讯和拉取广告并发执行，最多耗时3.2秒广告时间，拉取资讯在这3.2s已经完成</li>
<li>将每次请求广告接口并发执行，拉取广告最多仅耗时0.8s，总耗时也就0.8s</li>
<li>在资讯和广告组装时，也就是接口快结束时，利用future.get()获取广告结果，如果广告执行过长，get()只等400ms，超过了没有get到就丢弃广告</li>
</ul>
</li>
</ul>
</li>
<li>优化广告代码逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并行获取广告</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    Futrue&lt;String&gt; f = Executors.newfixedThreadPool(<span class="number">10</span>).submit((广告id)-&gt;&#123;</span><br><span class="line">        <span class="comment">//获取广告</span></span><br><span class="line">        <span class="comment">//返回广告，json格式</span></span><br><span class="line">        <span class="keyword">return</span> ···;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//将广告id对应的future加入map，future里面有执行结果</span></span><br><span class="line">    map.put(广告id,f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取资讯</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//资讯中插入自营内容，banner，卡片等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取广告</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//遍历map，map.get(广告id).get(400ms)</span></span><br><span class="line">    <span class="comment">//将广告插入资讯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化完成，时间=0.6s获取资讯，每个广告最多等待400ms，加起来最多2.2s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="负责bi报表的制作"><a href="#负责bi报表的制作" class="headerlink" title="负责bi报表的制作"></a>负责bi报表的制作</h4><p>事件：点击，曝光，不喜欢，阅读时长，视频播放时长</p>
<h4 id="配置黑名单"><a href="#配置黑名单" class="headerlink" title="配置黑名单"></a>配置黑名单</h4><ul>
<li><p>把运营给的黑名单网站存到redis里面，key会过大，拆封key，通过计算计算每个网站的hashcode，取模key的数量，计算出黑名单网站应该对应的key，会出现分布不均匀的问题，暂未找到更优解决；十万网址拆10个key，20w网址拆20个key;在点击资讯时，计算出hashcode取模拆分的key的个数，可以知道存在了那个key里面，之后在拿那个key对应的网址set进行ismembers操作。</p>
<ul>
<li>问题：扩容的时候重计算吗，不重计算出现扩容前后算法不一致问题，之前的数据无法读取到？</li>
</ul>
</li>
<li><p>使用的redis数据结构</p>
<p>string存储hash，渠道，子渠道，token</p>
<p>set 存黑名单网站，ismembers可以方便的查出是否在黑名单</p>
<p>zset 给广告点击量排名，在黄金时间7-9点放排名高的广告</p>
<ul>
<li>学习string，hash，zset的底层数据结构</li>
</ul>
</li>
<li><p>使用redis存储替代客户端存储的好处</p>
<ul>
<li>减少手机客户端大小</li>
<li>请求时在redis里面判断速度快</li>
<li>实时性问题，黑名单更新后需要重进客户端；使用redis则不需要用户重启软件</li>
</ul>
</li>
<li><p>逻辑升级：</p>
<ul>
<li>使用手机物理内存作黑名单时，在应用启动的时候去拉取黑名单保存在手机，等点击资讯时直接在手机内存中判断是否在黑名单网址集合中</li>
<li>使用redis作黑名单时：把黑名单存到redis的set集合，每一次点击资讯都判断资讯网址是否是在这个黑名单set里，是的话进行拦截</li>
</ul>
</li>
</ul>
<h4 id="定位redisoom问题"><a href="#定位redisoom问题" class="headerlink" title="定位redisoom问题"></a>定位redisoom问题</h4><p>问题：定位比较难的线上问题</p>
<h4 id="服务告警，防止异常无感知"><a href="#服务告警，防止异常无感知" class="headerlink" title="服务告警，防止异常无感知"></a>服务告警，防止异常无感知</h4><ul>
<li>公司的平台只能监控用户调用服务端的接口，服务端请求uc的接口没办法监控；</li>
<li>uc拉黑了公司的子渠道；导致线上资讯不展示</li>
<li>可以把每次服务端请求uc资讯的结果状态码通过大数据api存储到大数据平台（数据量过大不宜使用本地数据库），之后写一个定时任务，几分钟去计算下异常状态码的比率，大于5%的时候就发警告，通过短信，邮件，和电话</li>
</ul>
<h4 id="分布式锁的使用"><a href="#分布式锁的使用" class="headerlink" title="分布式锁的使用"></a>分布式锁的使用</h4><ul>
<li><p>浏览器模块和控制中台模块的同步问题</p>
</li>
<li><p>对某个用户推送资讯的时候，需要先去写申请，去审批中台审批，当审批提交时，中台正在处理，这时浏览器方面决定放弃推送，同时点击撤销，此时中台还在审批，过一会后审批成功；出现了浏览器端不推送，审批中台推送，的不一致的情况</p>
</li>
<li><p>解决，按照请求审批编号加分布式锁，保证撤销审批操作和中台审批操作串行执行；也就是撤销中途阻塞中台审批；中台审批的时候阻塞撤销操作</p>
</li>
</ul>
<h3 id="项目答疑"><a href="#项目答疑" class="headerlink" title="项目答疑"></a>项目答疑</h3>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>话术</tag>
      </tags>
  </entry>
  <entry>
    <title>商城支付</title>
    <url>/2024/11/12/%E5%95%86%E5%9F%8E%E6%94%AF%E4%BB%98/</url>
    <content><![CDATA[<h2 id="1，内网穿透-natapp"><a href="#1，内网穿透-natapp" class="headerlink" title="1，内网穿透 natapp"></a>1，内网穿透 natapp</h2><p>1，使用netapp，获取公网ip</p>
<p><a href="https://natapp.cn/">https://natapp.cn/</a></p>
<ul>
<li>购买</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JP大学习</title>
    <url>/2024/10/18/JP%E5%A4%A7%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="自身"><a href="#自身" class="headerlink" title="自身"></a>自身</h2><p>1，重拳接刺，接od，传送最速中脚+下重拳取消引爆，打拆</p>
<ul>
<li>下重拳要最速按</li>
<li>引爆后可以直接前重脚，也可以绿冲两个前重脚</li>
</ul>
<p>2，裂隙马上要爆了再去绿冲压</p>
<p>3，dj这种，开局绿冲尝试下轻拳截</p>
<p>4，重拳接刺接od裂隙，直接投，对面直跳接重拳接引爆，放帧前重脚继续&#x2F;前跳重拳接重风神</p>
<p>5,二气推板，tc开</p>
<ul>
<li>66，下重拳取消轻裂隙，66重拳中波，最速起跳放帧中脚，绿冲前重脚重风神，需要消耗一个裸绿冲</li>
</ul>
<p>6，双裂隙中脚&#x2F;下中拳打中乱动，中风神+下蹲卡双裂隙，重拳重波，跳，落地od波，地刺轻风神</p>
<ul>
<li>板边重拳确反双裂隙中脚中风神后也这样接</li>
</ul>
<p>7，板边中脚打乱动，目押中拳</p>
<ul>
<li>使用od风神+绿冲前重脚中风神+重拳od波地刺轻风神；代替双前重脚，斗气一样伤害更高</li>
</ul>
<p>8，晕连扫地机，3od</p>
<ul>
<li>od裂隙+中风神+下重脚+od裂隙+重拳重波+跳+od波地刺轻风神</li>
</ul>
<h2 id="加米"><a href="#加米" class="headerlink" title="加米"></a>加米</h2><p>1，空箭最多可以-4，尝试2lp确反</p>
<p>2，地箭摸奖，可以-3无确反，尝试投</p>
<p>3，加米绿冲2hp+5，延迟拆，拼精防一定要一下一下按</p>
<p>4，下重脚-10，测试用2hk，2mk，5mp，5mk确反</p>
<p>5，tc技2-3下之间有8帧空隙，2mp却反，可以接5hp+轻鬼(必须轻或od)，或者接6hk中刺</p>
<p>6，2hp打中+1，版中选择后走可以规避投，注意微后走拉蹲防2mk；压起身可以偷到＋3</p>
<p>7，加米前投后，轻地箭压制，后起身-1，原地起-3，前投选择原地起</p>
<p>8,5hp取消轻反遥(转圈打拳)，中间不可以抢招；只有重反遥拳可以加帧，有推开距离，延迟抢应对对面抢招和前走投；近距离的od反摇拳会逆向</p>
<p>9，灰了复读，5hp取消重反遥拳，在反摇拳后抢4帧；5lp+2mp+轻反摇，在5lp后抢4帧</p>
<p>10，空箭，打头才-，打腰部以下+，选择后后打落地差和，前前造成确反，直跳却反，延迟使用2hp，距离够对到空，不够可以打到落地；加米重脚打中-3，此时不要还2mk，会被空箭确反</p>
<p>11，流氓打击，派生下段+2，指令投无法打蹲</p>
<ul>
<li>tc技取消不蓄力流氓打击，原地起身可以规避中段则，出中段直接用轻拳确反浮空</li>
<li>tc取消蓄力流氓，直接凹</li>
</ul>
<p>12，下中脚取消轻拳联防，无法后走打拆，直接延迟拆，下中脚取消中攻击有缝，可以凹</p>
<p>13，喜欢远距离直跳重脚只能空对空或者空投，别凑过去挨打</p>
<p>14，进了跳逆的范围可以后后让出位置</p>
<p>15，tc接中地箭，选择后起身，加米两个66+2，无法后走打拆，选择延迟拆或者凹；重地箭收尾可能会偷帧2hp，起身拼第一帧精防，不要斗反会被防</p>
<p>16，版边升龙和地箭结尾都可以最速崩放压起身，注意，换边反遥拳也可以崩压，除了崩放还要叮贴脸od反摇打逆向</p>
<p>17，被压版多选择后后和前走投</p>
<p>18，版中后投进版，普通裂隙，截绿冲裂隙会被拉掉，可以od裂隙，截到引爆，5hp能确保不管几个裂隙炸到都能打到</p>
<h2 id="杰米"><a href="#杰米" class="headerlink" title="杰米"></a>杰米</h2><p>1，防住嘟嘟嘟后，推开距离只能按一下4帧，不然会挥空被下一个嘟嘟嘟打差和</p>
<ul>
<li>抢一下轻拳后，直接44，嘟嘟嘟打不中，直接差和</li>
<li>如果杰米第二下嘟嘟嘟改轻拳，44会被打，可以赌，回报大</li>
</ul>
<p>2，嘟嘟嘟第二段可以取消斗气泵放，半边在防住嘟嘟嘟是可以跳或投，没取消就不会动，取消了就会跳起来或者投到崩放</p>
<p>3，白了后杰米2lp接5hp循环推版，在2lp后44，或者直接投，都可以确反</p>
<p>4，绿冲踢小腿和嘟嘟嘟，尝试直跳，难拦截</p>
<p>5，流醉拳三段</p>
<ul>
<li>第一段-6推开远不要确反</li>
<li>第二段-11，但如果杰米出第三段会被打，尝试延迟却反？</li>
<li>被打中3段对面喝酒是-1，可以抢，当心od升；od流醉打完喝酒是+1，别抢</li>
</ul>
<p>6，4酒</p>
<ul>
<li>流醉拳第二段打中也不利，抢4帧防止投指令投</li>
</ul>
<p>7，杰米三气后按蓝防防偷鸡，只输投</p>
<p>8，绿冲嘟嘟嘟+1且推开，蹲下延迟抢轻拳防下中脚和前走投即可；绿冲踢小腿也一样，建议直跳</p>
<p>9，不要后起身，没作用</p>
<ul>
<li>重推掌，轻升龙，地上转圈结尾，都是42帧有利，两个66+2，原地起身避免了杰米可以后走打拆，选择延迟拆或者斗反</li>
</ul>
<p>10，版边前投派生喝酒7帧有利，可能站中脚压或者前走投，选择延迟抢轻拳覆盖</p>
<p>11，版边下重脚tc派升喝酒，4帧有利，不要抢</p>
<p>12，对面0酒时，多防凹</p>
<p>13，普通重爆回连防，防住推开，只能站重拳却反，联防可以一直按</p>
<h2 id="叛忍肯"><a href="#叛忍肯" class="headerlink" title="叛忍肯"></a>叛忍肯</h2><p>1，浮空kk旋风后，版边</p>
<ul>
<li>两个66+5：直接投&#x2F;44打拆</li>
<li>一个66：直接崩&#x2F;2lk+5mp，偷到5帧，直接2lp目押5lk大升龙</li>
<li>5lp+kk中段，不偷帧只+3，偷帧+4直接2lp目押5mp</li>
<li>5lpkk刹车投，刹车后是+3，可以择下段，偷帧中段</li>
</ul>
<p>2，版边重升或者kk升结尾，</p>
<ul>
<li>5lk+5mp打中+1，一些角色轻拳还不到，可以下中拳打轻拳差和，打的到的可以轻拳抢接站轻脚大升龙</li>
<li>5mp卡，+3，直接投</li>
</ul>
<p>3，版边tc接中迅雷派升重</p>
<ul>
<li>中升龙结尾，+33，kk中段偷？&#x2F;5lk+5hp打中+7</li>
<li>重升龙&#x2F;kk升结尾，+27，下中拳卡帧+5，可以直接投或后走&#x2F;最速kk中段44重拳打拆+下中脚取消kk升</li>
</ul>
<h2 id="叛忍拉希德"><a href="#叛忍拉希德" class="headerlink" title="叛忍拉希德"></a>叛忍拉希德</h2><p>版中：5mk目押5mp+214mk&#x2F;214kk+214lk\</p>
<p>崩墙：5hp+214mp+236hp</p>
<p>反崩靠墙：5mk目押5mp+214mp+5lk+236mp+236pp</p>
<p>确反：</p>
<ul>
<li>重拳+重反遥拳+重升龙</li>
</ul>
<p>板边斩杀：</p>
<ul>
<li>中拳od反遥拳+od正摇拳+重空箭派生拳，可以接一气和三气</li>
</ul>
<p>换边练</p>
<p>压起身：</p>
<p>版中，中老鹰踢结尾：</p>
<ul>
<li>66跑动+3压</li>
<li>66+216hp派生前腿，原地起或者后起都是+5</li>
<li>直接6kk派生4kk+mk，择逆向，被防+5，打中+7</li>
<li>直接蓄满轻波，236lp冲，被防+2，没有加强的轻旋风被防-3</li>
<li>前前+前kk，逆向+2</li>
<li>下轻脚+前kk卡+5</li>
</ul>
<p>板边，中老鹰踢结尾：</p>
<ul>
<li>反遥轻拳卡+5</li>
</ul>
<p>板边，重旋风结尾</p>
<ul>
<li>6kk+4，之后可以投择或者派生6kk跳压</li>
<li>投卡+3</li>
<li>加强重旋风，下中拳卡+5</li>
</ul>
<p>板边中风结局</p>
<ul>
<li>下中脚卡+4</li>
</ul>
<p>前投，</p>
<ul>
<li><p>重波后直接绿冲轻拳轻脚，不能抢</p>
</li>
<li><p>轻拳卡前重拳打到+5</p>
</li>
</ul>
<h2 id="叛忍保安"><a href="#叛忍保安" class="headerlink" title="叛忍保安"></a>叛忍保安</h2><p>1，下轻拳4，站轻拳5远，轻攻击打到+4，最速轻脚接轻炸弹，只有轻脚可以接轻炸弹+24</p>
<ul>
<li>轻剪刀打到+2贴脸，直接投，下轻脚择，直接后走即可打最速拆</li>
</ul>
<p>2，下中脚绿冲&#x2F;裸绿冲中拳，需要确认中拳是否命中</p>
<ul>
<li>命中，+10，下重拳接重炸弹+31</li>
<li>不命中<ul>
<li>绿冲中拳后+4，继续使用中拳打抢招，打中后相杀下中拳中炸弹+23</li>
<li>第二个中拳被防是平，对面喜欢这里抢4帧，中拳直接派生下重脚会打康，轻拳目押轻脚轻炸弹+24</li>
</ul>
</li>
</ul>
<p>3，绿冲下轻脚+2，接中拳和4帧相杀，两点确认打中后中炸弹+23</p>
<p>4，重拳摸却反，绿冲下中拳站中拳下中拳中炸弹&#x2F;中电钻+21</p>
<p>5，剪刀脚，打康，轻脚轻炸弹；却反，下中拳中炸弹</p>
<p>;远距离用中的，比轻的多一帧，只能和轻的摸到一样连法，重的发生太慢且距离没远多少</p>
<p>6，od电钻摸到+35，最速前前+16，直接重拳(19帧)，打中+4，轻脚轻炸弹</p>
<p>7,起飞直接拳，打防+5</p>
<p>8，跳中脚最少+5，直接站中拳(8)帧，打中下中拳接中炸弹</p>
<p>9，跳重脚最少+11，接后重脚(10)，打中加4，接轻脚炸弹，打防+1贴脸</p>
<p>10，跳中拳第二下放帧接重炸弹</p>
<h3 id="确反"><a href="#确反" class="headerlink" title="确反"></a>确反</h3><p>1，无资源：重脚+中拳前重拳tc+轻雷</p>
<p>2，下中拳中拳下中拳+od剪刀+中电钻推板</p>
<ul>
<li>在od剪刀脚的时候蓄力即可</li>
<li>用于自己近版推板</li>
<li>板边打斗反，od剪刀后换成前重拳轻炸弹</li>
</ul>
<p>3，重脚+前前(等浮空)+下重拳+od剪刀+前重拳+轻电钻+22</p>
<ul>
<li>前重拳触发时蓄力</li>
<li>用于自己近版推板</li>
</ul>
<p>4，重脚+前前+下重拳+od剪刀+重炸弹，版中使用，刚好推到板边</p>
<ul>
<li>可以使用重剪刀(22发动)代替重脚，伤害高些</li>
<li>板边换成前重拳+中炸弹(需要重脚确反浮空或者崩放确反浮空)</li>
</ul>
<p>5，重脚确反，最速od28派生踩+滑铲换边，用于精防和反崩+28</p>
<ul>
<li>前前中拳偷两帧，打防+2，打中+8，防斗反</li>
</ul>
<p>6，反崩：重脚+下中拳+od剪刀+中电钻&#x2F;重炸弹</p>
<ul>
<li>跳重拳+重拳+二气换边+23,66+4</li>
</ul>
<p>7，崩墙</p>
<ul>
<li>中拳前重拳tc接轻炸弹</li>
<li>下重拳+od剪刀+前重拳+中炸弹</li>
</ul>
<p>8，晕连</p>
<ul>
<li>前跳重脚+重脚+中拳+od剪刀+前重拳+轻炸弹</li>
</ul>
<p>9，斗反</p>
<ul>
<li>两个下中拳+od剪刀+····</li>
</ul>
<h3 id="追击"><a href="#追击" class="headerlink" title="追击"></a>追击</h3><h2 id="叛忍隆"><a href="#叛忍隆" class="headerlink" title="叛忍隆"></a>叛忍隆</h2><p>1，下轻拳和站轻脚才可以接轻驴踢，打中42安全跳</p>
<p>2，轻旋风打中，前前轻波掌偷帧+7，打防+2，打康打飞追击绿冲下中拳</p>
<p>3，重旋风换边用</p>
<p>4，重升龙后前前重拳中驴踢距离陷阱，用重拳差和</p>
<p>5，中旋风后绿冲中拳下中拳发轻波，也是陷阱，重拳差和</p>
<p>6，崩墙后，绿冲重拳重脚tc，轻脚偷崩，一帧反崩&#x2F;轻脚重驴踢，打中中升龙</p>
<p>带派竹节虫</p>
<ul>
<li>民工，绿冲下重拳接反遥重脚接正摇中脚</li>
</ul>
<p>1，下轻脚轻拳连打，接轻反遥脚，正摇脚也可以但是要站姿</p>
<p>2，轻反遥脚后绿冲放帧下中脚或者前中脚，上下择，打中接站中脚取消民工连</p>
<h2 id="不知火舞"><a href="#不知火舞" class="headerlink" title="不知火舞"></a>不知火舞</h2><h3 id="进攻"><a href="#进攻" class="headerlink" title="进攻"></a>进攻</h3><h1 id="贴身①远版：“下轻拳-3”-轻忍蜂【-27】——-三点确认，最速抢招"><a href="#贴身①远版：“下轻拳-3”-轻忍蜂【-27】——-三点确认，最速抢招" class="headerlink" title="贴身①远版：“下轻拳*3”+轻忍蜂【+27】—— 三点确认，最速抢招"></a>贴身①远版：“下轻拳*3”+轻忍蜂【+27】—— 三点确认，最速抢招</h1><p>​	└压起身①：前前卡帧+后重脚 —— 命中接后续tc，如果到了版边可以继续接中升龙</p>
<p>​	└└由于后重脚是偷帧，被防+1，如果到了版边可以下轻拳+下中拳尝试打乱动，版中就用下中拳打乱动</p>
<p>​	└└后重脚tc打完+48，建议前前<em>2卡帧+前走轻攻击</em>3三点确认压起身</p>
<h1 id="└压起身②：前前卡帧-前走投"><a href="#└压起身②：前前卡帧-前走投" class="headerlink" title="└压起身②：前前卡帧+前走投"></a>└压起身②：前前卡帧+前走投</h1><h1 id="└压起身③：绿冲前中拳-——-命中-6接下中拳"><a href="#└压起身③：绿冲前中拳-——-命中-6接下中拳" class="headerlink" title="└压起身③：绿冲前中拳 —— 命中+6接下中拳"></a>└压起身③：绿冲前中拳 —— 命中+6接下中拳</h1><p>​	└└会和对手4帧拳脚相杀，确认相杀接下重拳+下轻拳</p>
<p>​	└└被防+1，可接轻攻击*2&#x2F;轻脚tc</p>
<p>​	└└绿冲轻拳可骗凹骗拆</p>
<p>贴身①近版：“轻拳*3”+中龙炎舞【+35】—— 比上一套伤害高点</p>
<p>​	└压起身①：轻忍蜂 —— 偷帧命中+40，前前*2贴身+4</p>
<p>​	└└被防+3，可接轻攻击*2&#x2F;轻脚tc&#x2F;下中拳&#x2F;投</p>
<p>​	└压起身②：前前卡帧+下重拳 —— 这里不放帧的话只有第二下能打中，不过问题不大</p>
<p>​	└压起身③：前前卡帧+前走投</p>
<p>​	└压起身④：前前卡帧+绿冲后重脚 —— 命中+7接下中拳+重龙炎舞</p>
<p>​	└└被防+3接轻攻击*2&#x2F;轻脚tc&#x2F;下中拳，不能投，会被后走躲掉</p>
<p>​	└压起身⑤：轻拳卡帧+迸</p>
<h1 id="贴身①版边：“下轻拳-3”-重升龙【-31】——-伤害更高"><a href="#贴身①版边：“下轻拳-3”-重升龙【-31】——-伤害更高" class="headerlink" title="贴身①版边：“下轻拳*3”+重升龙【+31】—— 伤害更高"></a>贴身①版边：“下轻拳*3”+重升龙【+31】—— 伤害更高</h1><h1 id="└压起身①：下中拳卡帧-5-——-可选择下轻拳-轻脚tc-投-后走骗拆"><a href="#└压起身①：下中拳卡帧-5-——-可选择下轻拳-轻脚tc-投-后走骗拆" class="headerlink" title="└压起身①：下中拳卡帧+5 —— 可选择下轻拳&#x2F;轻脚tc&#x2F;投&#x2F;后走骗拆"></a>└压起身①：下中拳卡帧+5 —— 可选择下轻拳&#x2F;轻脚tc&#x2F;投&#x2F;后走骗拆</h1><ul>
<li>投</li>
<li>慌拆</li>
<li>绿冲中段</li>
</ul>
<p>​	└└下轻拳是偷帧，命中+6被防+1，复合下中拳两点确认</p>
<p>​	└压起身②：蓄力扇子 —— 命中+1被防-1，扇子择在<code>特殊</code>章节开头</p>
<h1 id="└压起身③：绿冲前中拳-——-这个不会相杀"><a href="#└压起身③：绿冲前中拳-——-这个不会相杀" class="headerlink" title="└压起身③：绿冲前中拳 —— 这个不会相杀"></a>└压起身③：绿冲前中拳 —— 这个不会相杀</h1><h1 id="贴身②：“轻脚tc”-空箭【-41】——-三点确认，这也是最速抢招"><a href="#贴身②：“轻脚tc”-空箭【-41】——-三点确认，这也是最速抢招" class="headerlink" title="贴身②：“轻脚tc”+空箭【+41】—— 三点确认，这也是最速抢招"></a>贴身②：“轻脚tc”+空箭【+41】—— 三点确认，这也是最速抢招</h1><p>​	└压起身①：前前<em>2卡帧+5 —— 可选择轻攻击</em>3&#x2F;轻脚tc&#x2F;下中拳&#x2F;投</p>
<p>​	└压起身②：前前卡帧+迸 —— 版边限定</p>
<p>​	└压起身③：伪安全跳 —— 非版边用跳中脚+下轻脚+下轻拳确认 </p>
<p>​	└└版边用跳重拳+后重脚确认，命中接后续tc+中升龙【+30】，+30的压起身在后面</p>
<p>贴身③：“下轻脚+下轻拳*2”+轻忍蜂&#x2F;重升龙【+27&#x2F;+31】—— 三点确认，偷下段</p>
<p>近距离非版边：“下轻拳打康+下中拳”+重忍蜂【+22】—— 两点确认，需要额外确认打康</p>
<p>​	└压起身①：前前卡帧+4 —— 可选择轻攻击*2&#x2F;轻脚tc&#x2F;下中拳&#x2F;投</p>
<p>​	└压起身②：轻拳卡帧+后重脚 —— 偷帧命中+5，接下轻拳或者打完后续tc，版边限定</p>
<p>​	└└被防+1，接下轻拳+下中拳尝试打乱动</p>
<p>​	└压起身③：直接迸，版边限定</p>
<p>近距离版边：“下轻拳打康+下中拳”+重升龙【+31】</p>
<p>中距离①：“下中脚复合轻龙炎舞”—— 偷下段，骚扰，控制好距离不会被确反</p>
<p>中距离②安全跳：“下中脚+绿冲取消后重脚”+轻脚tc+空箭【+42】—— 两点确认，安全跳</p>
<p>​	└后重脚会和对手4帧拳脚相杀，确认相杀接重拳+重龙炎舞+任意收尾</p>
<p>​	└被防+3接轻攻击*2&#x2F;轻脚tc&#x2F;下中拳，不能投，会被后走躲掉</p>
<p>中距离②非版边：“下中脚+绿冲取消后重脚”+下中拳+重龙炎舞+轻忍蜂【+30】—— 两点确认，偷下段</p>
<p>​	└压起身①：前前卡帧+放帧下重拳</p>
<p>​	└压起身②：前前卡帧+前走投</p>
<p>​	└压起身③：绿冲前中拳</p>
<p>​	└绿冲轻拳可骗凹骗拆</p>
<p>中距离②版边：“下中脚+绿冲取消后重脚”+下中拳+重龙炎舞+重升龙【+30】—— 比上一套伤害更高</p>
<p>​	└压起身：和+31的压起身唯一区别只有下轻拳无法偷帧接下中拳，其他一致</p>
<p>较远距离：“绿冲下轻脚+下中拳”+重龙炎舞+任意收尾 —— 两点确认，偷下段，偷到下段的话对手一般是站姿</p>
<p>远距离①：“绿冲后重脚”+下中拳+重龙炎舞+任意收尾 —— 绿冲后重脚确认</p>
<p>远距离②：“绿冲下中脚+绿冲取消后重脚”+下中拳+任意收尾 —— 两点确认，偷下段，斩杀用</p>
<p>远距离~全屏（一个跳入以外的距离）：“蓄力扇子”—— 神技，进攻利器，扇子择在<code>特殊</code>章节开头</p>
<p>跳入，近距离~较远距离：“跳轻脚+任意轻攻击连段”—— 无需确认正逆</p>
<p>跳入，远距离：“跳重脚+重拳”+重忍蜂&#x2F;重升龙【+22&#x2F;+31】—— 两点确认</p>
<p>这俩连段（后重脚tc+中升龙，重龙炎舞+重升龙）都可以改成轻升龙收尾【+29】，这个有利帧可以前前卡帧+后重脚偷帧压起身，命中+7接下中拳+重龙炎舞，被防+3可接轻攻击*2&#x2F;轻脚tc&#x2F;下中拳</p>
<h3 id="确反-1"><a href="#确反-1" class="headerlink" title="确反"></a>确反</h3><p>非版边零资源：中脚+重拳+重龙炎舞+轻忍蜂【+30】</p>
<p>非版边二斗气：重拳+蓄力OD扇子+重拳+重龙炎舞+轻忍蜂【+30】—— 最推荐的确反连段，打完回收将近一格斗气，不过要贴身才行</p>
<p>远版二斗气：中脚+重拳+OD龙炎舞+中忍蜂【+24】—— 伤害更高，推板更远</p>
<p>​	└压起身①：前前卡帧+下中拳 —— 偷帧命中+6，接下中拳，被防-2</p>
<p>​	└压起身②：直接迸</p>
<p>近版零资源：中脚+重拳+重龙炎舞+重升龙【+30】</p>
<p>版边零资源：下重拳+后重脚tc+中升龙【+30】</p>
<p>版边二斗气①：重拳+蓄力OD扇子+后重脚tc+中升龙【+30】—— 比上一套伤害高点，但必须贴近版边才成立（比如确反不了肯的OD升龙）</p>
<p>版边二斗气②：重拳+满蓄OD扇子+轻龙炎舞+重忍蜂+一气&#x2F;二气 —— 伤害可观，但必须贴近版边才成立</p>
<p>反迸远版：前前*2+重拳+重龙炎舞+重忍蜂 —— 重忍蜂偷帧命中+38，被防+3贴身打投择</p>
<p>反迸近版：前前*2+重拳+轻忍蜂+轻升龙【+29】</p>
<p>反迸版边：前前+后重脚tc+中升龙【+30】—— 前前是防止离版边太远接不上中升龙，去掉也可以</p>
<p>墙崩：后重脚tc+中升龙【+30】</p>
<p>晕连：跳重脚+后重脚tc+中升龙【+30】</p>
<p>非版边打拆投：下中拳+重拳+重龙炎舞+任意收尾</p>
<p>版边打拆投：下重拳+后重脚tc+中升龙【+30】</p>
<p>确反斗反：下中拳+重拳+重龙炎舞+任意收尾</p>
<p>重脚确反康：</p>
<p>①离得近接下中拳+重龙炎舞+任意收尾</p>
<p>②离得远接前前+下轻拳+重龙炎舞+任意收尾</p>
<p>③再远就接绿冲重拳+重龙炎舞+任意收尾</p>
<p>版边一气收尾防凹：</p>
<p>零资源：中脚+重拳+重龙炎舞+中龙炎舞+重升龙【+33】</p>
<p>​	└压起身①：下中拳卡帧+下中拳 —— 偷帧命中+7接下中拳，被防-1</p>
<p>​	└压起身②：绿冲迸</p>
<p>二斗气：重拳+蓄力OD扇子+前跳重脚+重拳+重龙炎舞+中龙炎舞+重升龙【+33】—— 打完斗气回复一格半，性价比拉满，一般在版边吃完一气再吃完这套基本就寄了，还活着就把重升龙换成OD升龙&#x2F;一气&#x2F;二气</p>
<h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><p>立回扇子择：</p>
<p>①建议用蓄力重扇子，掉落得最慢，可配合绿冲下中脚&#x2F;前中拳&#x2F;投进行多择</p>
<p>②如果对手离得近可以用前跳</p>
<p>③如果对手习惯用后后，就用绿冲重脚</p>
<p>​	└或者直接扔蓄力轻扇子，这个躲不掉</p>
<p>④如果对手习惯用跳跃，就用前前+重升龙</p>
<p>​	└也可以用跳中拳+空箭，回报更高</p>
<p>​	└或者直接扔蓄力轻扇子，这个跳不起来</p>
<p>⑤防空盯紧，看到对手前跳就升龙</p>
<p>⑥OD扇子目测掉落速度和蓄力中扇子差不多，绿冲下中脚&#x2F;前中拳&#x2F;投依然成立</p>
<p>⑦满蓄OD扇子更是重量级，一般对手虚损后会主动后退拉开距离，这时候就用它狠狠地择吧</p>
<p>压起身扇子择：</p>
<p>①一般用于版边升龙收尾之后，30有利帧左右刚好够扇子蓄力</p>
<p>②建议先用蓄力重扇子，发完点两个下轻拳确认是否乱动，乱动就接后重脚tc</p>
<p>​	└被防+16，随便择</p>
<p>③对手如果喜欢抢就改用蓄力中扇子，一抢一个不吱声</p>
<p>忍焰强化效果：</p>
<p>\1. 普通扇子可以吃掉一段波，抵消两段波</p>
<p>\2. 蓄力扇子同上，打不过豪鬼满蓄波</p>
<p>\3. OD扇子和蓄力OD扇子会和OD波抵消，满蓄OD扇子只会输卢克OD波派生，因为不够快</p>
<p>\4. 轻龙炎舞命中会击飞对手【+35】</p>
<p>\5. 轻龙炎舞打防-2，完全无责</p>
<p>\6. 无论对手在地面还是浮空，中龙炎舞收尾均+42，安全跳</p>
<p>\7. 重龙炎舞可接中龙炎舞+重升龙，3忍焰时版中就能接重升龙</p>
<p>​	└2忍焰时版边才能接重升龙</p>
<p>​	└1忍焰时版边只能接轻升龙</p>
<p>\8. OD龙炎舞可接重龙炎舞+重升龙，1忍焰版中就能接</p>
<p>\9. 升龙范围变大，有利帧增加</p>
<p>\10. 忍蜂除了伤害增加以外没什么变化</p>
<p>\11. 普通空箭有利帧+1</p>
<p>\12. OD空箭命中浮空高度增加，可接重龙炎舞+轻忍蜂&#x2F;重升龙，1忍焰版中就能接</p>
<p>​	└版边能接OD龙炎舞+轻忍蜂+轻升龙&#x2F;一气&#x2F;二气</p>
<p>\13. 一气范围变大</p>
<p>\14. 二气推板距离增加，可穿波</p>
<p>前投【+21】压起身：</p>
<p>①绿冲重脚 —— 命中+7，对手原地受身就接下中拳，后退受身就慢点出重脚</p>
<p>​	└会和对手4帧拳脚相杀，确认相杀接重拳</p>
<p>​	└被防+1</p>
<p>​	└绿冲轻拳可骗凹骗拆</p>
<p>②绿冲后重脚 —— 偷帧命中+10，接重拳+重龙炎舞，版边或投到确反康限定</p>
<p>​	└被防+6，接中脚尝试打乱动，确认打康接下中脚</p>
<p>③前前卡帧+3 —— 很微妙的距离，可以选择连投&#x2F;下轻脚+下轻拳&#x2F;后走骗拆，版边限定</p>
<p>后投【+17】压起身：</p>
<p>绿冲后重脚 —— 命中+7接下中拳+重龙炎舞，被防+3，版边或投到确反康限定</p>
<p>​	└绿冲轻拳无法骗凹</p>
<p>地面OD升龙【+20】压起身：</p>
<p>①绿冲下重拳 —— 命中+8接下中拳，被防+1</p>
<p>②前前卡帧+2 —— 可接轻攻击*3&#x2F;轻脚tc&#x2F;下中拳&#x2F;投，版边限定</p>
<p>斗反【+23】压起身：</p>
<p>①绿冲重脚 —— 命中+7接下中脚，被防+1</p>
<p>②前前卡帧+5 —— 可接轻攻击*3&#x2F;轻脚tc&#x2F;下中拳&#x2F;投，版边限定</p>
<p>③直接迸 —— 版边限定</p>
<p>版边地面一气&#x2F;OD空箭+一气收尾【+26】压起身：</p>
<p>前前卡帧+下中拳 —— 偷帧命中+8接下中拳，被防平帧</p>
<p>版边重龙炎舞+一气&#x2F;后重脚tc+一气【+27】压起身：</p>
<p>同地面轻忍蜂收尾压起身</p>
<p>三气收尾【+19】压起身：</p>
<p>①前前+轻攻击两点确认</p>
<p>②绿冲后重脚</p>
<p>​	└绿冲轻拳可骗凹</p>
<p>黄血三气收尾【+20】压起身：</p>
<p>版边可以前前+两点轻攻击&#x2F;投，版中只能绿冲后重脚</p>
<p>虚损磨血：</p>
<p>①下轻拳+下中拳+轻龙炎舞+下轻拳+下中拳+轻龙炎舞+…… —— 轻龙炎舞被防其实是平帧，对手抢4帧拳脚会相杀，不过蹭血的目的也达到了</p>
<p>②OD扇子+轻忍蜂+下轻拳+下中拳+OD扇子+下轻拳+前前+下中拳+OD扇子+下轻拳+前前+重拳+迸 —— 推板用的，有缝，但对手完全抢不出拳脚只能凹</p>
<h3 id="斩杀"><a href="#斩杀" class="headerlink" title="斩杀"></a>斩杀</h3><h4 id="无忍焰"><a href="#无忍焰" class="headerlink" title="无忍焰"></a>无忍焰</h4><p>零斗气版边确反一气斩杀连：下重拳+后重脚tc+一气【3720】</p>
<p>零斗气确反二气斩杀连：中脚+重拳+重龙炎舞+二气【3960】</p>
<p>零斗气确反三气斩杀连：中脚+重拳+重龙炎舞+轻忍蜂+三气【4760】</p>
<p>低斗气确反一气&#x2F;二气斩杀连：中脚+重拳+OD龙炎舞+一气&#x2F;二气【3840&#x2F;4400】</p>
<p>低斗气版边确反一气&#x2F;二气斩杀连：重拳+满蓄OD扇子+轻龙炎舞+重忍蜂+一气&#x2F;二气【4110&#x2F;4430】</p>
<p>低斗气确反三气斩杀连：中脚+重拳+绿冲取消重脚+下中拳+重龙炎舞+轻忍蜂+三气【5286】</p>
<p>一斗气重脚确反三气斩杀连：重脚+绿冲重拳+OD龙炎舞+重忍蜂+三气【4724】</p>
<p>二斗气确反一气&#x2F;二气斩杀连：重拳+蓄力OD扇子+重拳+OD龙炎舞+一气&#x2F;二气【4100&#x2F;4580】</p>
<p>二斗气确反三气斩杀连：重拳+蓄力OD扇子+重拳+绿冲取消重脚+下中拳+重龙炎舞+轻忍蜂+三气【5573】</p>
<p>三斗气版边偷下段一气斩杀连：下中脚+绿冲取消后重脚+下中拳+绿冲取消下重拳+后重脚tc+一气【3150】</p>
<p>三斗气偷下段三气斩杀连：下中脚+绿冲取消后重脚+下中拳+绿冲取消重脚+下中拳+重龙炎舞+轻忍蜂+三气【4517】</p>
<p>四斗气确反二气斩杀连：中脚+重拳+OD龙炎舞+OD忍蜂+跳中拳+OD空箭+二气【4900】</p>
<p>五斗气确反一气斩杀连：重拳+蓄力OD扇子+重拳+绿冲取消重脚+下中拳+OD龙炎舞+一气【4137】</p>
<p>五斗气版边确反一气斩杀连：重拳+蓄力OD扇子+重拳+绿冲取消重拳+满蓄OD扇子+轻龙炎舞+重忍蜂+一气【4374】</p>
<p>五斗气确反三气斩杀连：重拳+蓄力OD扇子+重拳+绿冲取消重脚+下中拳+绿冲取消重脚+下中拳+重龙炎舞+轻忍蜂+三气【5883】</p>
<h4 id="有忍焰"><a href="#有忍焰" class="headerlink" title="有忍焰"></a>有忍焰</h4><p>低斗气确反一气斩杀连：重拳+蓄力OD扇子+前跳重脚+重拳+重龙炎舞+一气【4550】—— 最少需要3忍焰</p>
<p>低斗气版边确反一气斩杀连：重拳+蓄力OD扇子+前跳重脚+重拳+重龙炎舞+中升龙+一气【4920】—— 最少需要3忍焰</p>
<p>低斗气确反二气斩杀连：重拳+蓄力OD扇子+前跳重脚+重拳+重龙炎舞+二气+重升龙【5290】—— 最少需要1忍焰，强化二气推到版边才能接重升龙</p>
<p>低斗气确反三气斩杀连：重拳+蓄力OD扇子+前跳重脚+重拳+重龙炎舞+轻龙炎舞+三气【5850】—— 最少需要2忍焰</p>
<p>二斗气确反一二三气斩杀连：中脚+重拳+重龙炎舞+OD忍蜂+跳中拳+OD空箭+一气&#x2F;二气&#x2F;三气【4920&#x2F;5200&#x2F;6000】—— 最少需要3忍焰，如果有5忍焰，二气推全版而且后面还能接重升龙</p>
<p>三斗气确反一二三气斩杀连：重拳+蓄力OD扇子+前跳重脚+重拳+重龙炎舞+OD忍蜂+跳中拳+OD空箭+一气&#x2F;二气&#x2F;三气【5170&#x2F;5680&#x2F;6480】—— 最少需要4忍焰，如果有5忍焰，二气推全版而且后面还能接重升龙</p>
<p>五斗气重脚确反一二三气斩杀连：重脚+绿冲重拳+OD龙炎舞*2+前跳中拳+OD空箭+一气&#x2F;二气&#x2F;轻龙炎舞+三气【4216&#x2F;4830&#x2F;5751】—— 最少需要2忍焰，但只能用一次OD龙炎舞</p>
<p>五斗气版中确反三气斩杀连：重拳+蓄力OD扇子+前跳重脚+重拳+绿冲取消重拳+蓄力OD扇子+前跳重脚+重拳+重龙炎舞+中扇子+轻忍蜂+三气【6307】—— 最少需要4忍焰，起手二气即可攒出三气</p>
<p>全资源斩杀连：重拳+蓄力OD扇子+前跳重脚+重拳+OD龙炎舞+OD忍蜂+跳中拳+OD空箭+不知火流·炎舞仇樱【6600】—— 最少需要4忍焰，实战用出来请务必@我见识一下</p>
<h1 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h1><p>两点下中脚直接抢下中拳</p>
<p>一段流醉拳-6，直接重拳打对面重拳，够不着</p>
]]></content>
      <categories>
        <category>happy</category>
      </categories>
      <tags>
        <tag>street fighter 6</tag>
      </tags>
  </entry>
  <entry>
    <title>亚马逊自学</title>
    <url>/2024/09/10/%E4%BA%9A%E9%A9%AC%E9%80%8A%E8%87%AA%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="关键词库"><a href="#关键词库" class="headerlink" title="关键词库"></a>关键词库</h2><p>1，搜集竞品的asin，在搜索框搜关键词，取头部的竞品asin，10个</p>
<p>2，使用卖家精灵下载关键词</p>
<ul>
<li>关键词反查，单个单个查，多个需要在表里去重</li>
<li>流量词拓展，多个asin一起查，自动去重</li>
</ul>
<p>3，对关键词指标分析，排序，例如月搜索量</p>
<p>TODO 搞清各个指标对关键词的影响</p>
<p>4，词频分析，判断频率最高的单个，两个单词组成短语，三个词汇组成短语</p>
<ul>
<li>AMZ123词频统计工具：<a href="https://www.amz123.com/tools-wordcounter%E3%80%81">https://www.amz123.com/tools-wordcounter、</a></li>
<li>单个单词词频卖家精灵自动完成</li>
</ul>
<p>5,相关性查询，直接在亚马逊前台搜索看相关性</p>
<ul>
<li>强相关会出现在listing和广告</li>
<li>不相关要否定并且不能出现在listing</li>
</ul>
<p>6，细分关键词</p>
<ul>
<li>例如：蓝牙无线耳机-&gt;蓝牙，无线，耳机做词根</li>
</ul>
<p>7，不同语种，同义词</p>
<p>8，TODO，用H10进行关键词反查</p>
]]></content>
      <categories>
        <category>DianShang</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>卖家大学</title>
    <url>/2024/08/19/%E5%8D%96%E5%AE%B6%E5%A4%A7%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="listing组成"><a href="#listing组成" class="headerlink" title="listing组成"></a>listing组成</h3><ul>
<li>listing: 对商品的具体介绍</li>
</ul>
<p>1，分类</p>
<p>2，关键词</p>
<p>3，图片</p>
<p>4，品牌</p>
<p>5，标题</p>
<p>6，5点</p>
<p>7，描述(有A+会被A+顶替)</p>
<p>8，A+图文详情</p>
<h3 id="北美产品认证"><a href="#北美产品认证" class="headerlink" title="北美产品认证"></a>北美产品认证</h3><p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20240819222904797.png" alt="image-20240819222904797"></p>
<ul>
<li><p>食品药品安全</p>
</li>
<li><p>儿童安全</p>
</li>
<li><p>无线电通讯产品</p>
</li>
<li><p>蓝牙产品</p>
</li>
<li><p>机动车和配件</p>
</li>
<li><p>ic？</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DianShang</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>ps</title>
    <url>/2024/08/18/ps/</url>
    <content><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="移动和选区"><a href="#移动和选区" class="headerlink" title="移动和选区"></a>移动和选区</h3>]]></content>
      <categories>
        <category>图片视频处理</category>
      </categories>
      <tags>
        <tag>ps教程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2024/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="1-给解压好的bochs配置安装文件-make编译，make-install安装"><a href="#1-给解压好的bochs配置安装文件-make编译，make-install安装" class="headerlink" title="1,给解压好的bochs配置安装文件,make编译，make install安装"></a>1,给解压好的bochs配置安装文件,make编译，make install安装</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">./configure</span> <span class="string">\</span> </span><br><span class="line"><span class="string">--prefix=/home/zxr/bochs_install</span> <span class="string">\</span> <span class="comment">#安装路径</span></span><br><span class="line"><span class="string">--enable-debugger</span> <span class="string">\</span> <span class="comment">#启用bochs自带的调试功能</span></span><br><span class="line"><span class="string">--enable-disasm</span> <span class="string">\</span> <span class="comment">#支持反汇编</span></span><br><span class="line"><span class="string">--enable-iodebug</span> <span class="string">\</span> <span class="comment">#开启io调试接口</span></span><br><span class="line"><span class="string">--enable-x86-debugger</span> <span class="string">\</span> <span class="comment">#支持x86调试器</span></span><br><span class="line"><span class="string">--with-x</span> <span class="string">\</span> <span class="comment">#使用xwindows</span></span><br><span class="line"><span class="string">--with-x11</span> <span class="comment">#x11图形用户界面</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意安装c和c++编译器，否则会编译失败</li>
</ul>
<h4 id="2-配置bochs的启动文件"><a href="#2-配置bochs的启动文件" class="headerlink" title="2,配置bochs的启动文件"></a>2,配置bochs的启动文件</h4><ul>
<li>启动文件不限定名字和后缀，使用bochsrc.disk放置安装根路径即可(输入的时候方便，只需要输入文件名)，也可以不在根，只不过要输入相对路径</li>
<li>配置虚拟计算机内存，硬盘启动，BIOS，VGABIOS，日志文件，鼠标，键盘映射，硬盘设置</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">megs:</span> <span class="number">32</span> <span class="comment">#内存大小</span></span><br><span class="line"><span class="comment">#BIOS</span></span><br><span class="line"><span class="attr">romimage:</span> <span class="string">file=/home/zxr/bochs_install/bochs/share/bochs/BIOS-bochs-latest</span> </span><br><span class="line"><span class="comment">#VGABIOS</span></span><br><span class="line"><span class="attr">vgaromimage:</span> <span class="string">file=/home/zxr/bochs_install/bochs/share/bochs/VGABIOS-lgpl-latest</span> </span><br><span class="line"><span class="comment">#硬盘启动</span></span><br><span class="line"><span class="attr">boot:</span> <span class="string">disk</span></span><br><span class="line"><span class="comment">#日志输出文件路径，根目录&#x27;/&#x27;省略了</span></span><br><span class="line"><span class="attr">log:</span> <span class="string">bochs.out</span></span><br><span class="line"><span class="comment">#禁用鼠标</span></span><br><span class="line"><span class="attr">mouse:</span> <span class="string">enabled=0</span></span><br><span class="line"><span class="comment">#keyboard_mapping: enabled=1</span></span><br><span class="line"><span class="comment">#键盘映射</span></span><br><span class="line"><span class="string">keyboard:keymap=/home/zxr/bochs_install/bochs/share/bochs/keymaps/x11-pc-us.map</span></span><br><span class="line"><span class="comment">#硬盘设置</span></span><br><span class="line"><span class="attr">ata0:</span> <span class="string">enabled=1,ioaddr1=0x1f0,ioaddr2=0x3f0,irq=14</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在安装根键入 bin&#x2F;bochs,打开程序</li>
</ul>
<p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20240813235503043.png" alt="image-20240813235503043"></p>
<ul>
<li>输入2选择bochs配置文件，输入配置文件路径，读取成功</li>
</ul>
<h4 id="创建启动盘"><a href="#创建启动盘" class="headerlink" title="创建启动盘"></a>创建启动盘</h4><ul>
<li>使用bochs虚拟机自带的bin&#x2F;bximage指令</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">bin/bximage</span> <span class="string">.</span></span><br><span class="line"><span class="string">-fd创建软盘。</span></span><br><span class="line"><span class="string">-hd</span> <span class="string">创建硬盘。</span></span><br><span class="line"><span class="string">-mode</span> <span class="string">创建硬盘的类型，有flat</span> <span class="string">、sparse</span> <span class="string">、growing</span> <span class="string">三种。</span></span><br><span class="line"><span class="string">-size</span> <span class="string">指创建多大的硬盘，以MB</span> <span class="string">为单位。</span></span><br><span class="line"><span class="string">-q</span> <span class="string">以静默模式创建，创建过程中不会和用户交互。</span></span><br><span class="line"><span class="comment">#bin/bochs -hd -mode=&quot;flat&quot; -size=60 -q hdM60.img</span></span><br><span class="line"><span class="comment">#创建启动硬盘，大小60m，静默创造，名字叫hdM60.img</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输入指令后，bochs会把需要写进配置文件的内容输出，复制进bochsrc.disk(配置文件)即可</li>
</ul>
<p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20240814235303276.png" alt="image-20240814235303276"></p>
<ul>
<li>启动硬盘创建完毕，注意，进入时是调试模式，输入c放行，q退出</li>
</ul>
<h3 id="编写mbr"><a href="#编写mbr" class="headerlink" title="编写mbr"></a>编写mbr</h3><p>1，为什么要把操作系统载入内存？</p>
<ul>
<li>内存的运行速度快</li>
<li>操作系统可以存在硬盘，软盘各种媒介，如果不统一放到一个地方，就会有对媒介的适配问题</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>自制操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>amazon</title>
    <url>/2024/08/03/amazon/</url>
    <content><![CDATA[<h3 id="货物运输状态管理"><a href="#货物运输状态管理" class="headerlink" title="货物运输状态管理"></a>货物运输状态管理</h3><p>在shipment管理里面，用运单号查询运输状态：</p>
<img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20240806154722502.png" alt="image-20240806154722502" style="zoom:50%;" />

<ul>
<li><p>1，注意选择后台的站点</p>
</li>
<li><p>2，点进shipment-&gt;manage Shipments，根据运单号搜要看的运单</p>
</li>
<li><p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20240806155433695.png" alt="image-20240806155433695"></p>
</li>
<li><p>运输状态</p>
<ul>
<li><p>working是没有确认，点击4，进去填上这个确认号：</p>
</li>
<li><p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/image-20240806155602064.png" alt="image-20240806155602064"></p>
</li>
<li><p>shipped是已发货</p>
</li>
<li><p>in transit是运输中，可以查询系统的到货时间，提交到表格：</p>
</li>
<li><p><img src="https://zxrpicbed.oss-cn-guangzhou.aliyuncs.com/image/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题"></p>
</li>
<li><p>设置到货时间为系统预测时间，并且更新时间到企业微信表格，日更···</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DianShang</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/08/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>AccessKey ID：zxrLTAI5tJ2X5xUgPqRDLZNLbfy</p>
<p>AccessKey Secret: zxrhXjVwZVaKBcswugf9kRJyMfQbzi8wF</p>
<p>bucketname:zxrpicbed</p>
<p>地域:oss-cn-guangzhou</p>
]]></content>
  </entry>
</search>
